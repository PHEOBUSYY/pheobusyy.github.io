<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">androidSwipeLayout源码分析</h1><h2 class="subtitle">2017-01-23</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#android-SwipeLayout源码分析"><span class="toc-number">1.</span> <span class="toc-text">android SwipeLayout源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内部view设置"><span class="toc-number">1.1.</span> <span class="toc-text">内部view设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内部view的类型"><span class="toc-number">1.1.1.</span> <span class="toc-text">内部view的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内部view的位置放置"><span class="toc-number">1.1.2.</span> <span class="toc-text">内部view的位置放置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ViewDragHelper相关配置"><span class="toc-number">1.1.3.</span> <span class="toc-text">ViewDragHelper相关配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#冲突解决与注意事项"><span class="toc-number">1.1.4.</span> <span class="toc-text">冲突解决与注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">1.2.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div><div class="post-text"><h2 id="android-SwipeLayout源码分析"><a href="#android-SwipeLayout源码分析" class="headerlink" title="android SwipeLayout源码分析"></a>android SwipeLayout源码分析</h2><p>swipeLayout是代码家写的一个支持手势滑动的开源库,初看的时候感觉特别惊艳,用户体验也非常的棒,特别好奇是怎么实现的,故抽时间研究了下.<br>通过分析代码结构得出swipeLayout主要分为三大部分:</p>
<ol>
<li>内部view初始设置</li>
<li>内部ViewDragHelper的callback实现</li>
<li>冲突解决与注意事项</li>
</ol>
<a id="more"></a>
<h3 id="内部view设置"><a href="#内部view设置" class="headerlink" title="内部view设置"></a>内部view设置</h3><p>这里说的内部各个view实际上指的是swipeLayout的子view,查看源码第一行发现swipeLayout继承的是FrameLayout,我们知道,如果在FrameLayout中你不设置子view的gravity的话,它们会全部叠放在一起,其中在xml中最底部声明的view是在顶层展现,依次类推.咱们这里指的就是这些个view.</p>
<h4 id="内部view的类型"><a href="#内部view的类型" class="headerlink" title="内部view的类型"></a>内部view的类型</h4><p>在swipeLayout中,作者把view分为两大类,顶层默认展示的view叫做 <em>surfaceView</em> ,通过滑动显示的下层的方向的4个view叫做 <em>bottomView</em> .滑动支持上下左右4个方向,所以这里bottomView放入一个view集合.对应下面的枚举和map集合:</p>
<pre><code class="java">public enum DragEdge {
       Left,
       Top,
       Right,
       Bottom
   }
</code></pre>
<pre><code class="java"> private LinkedHashMap&lt;DragEdge, View&gt; mDragEdges = new LinkedHashMap&lt;&gt;();
</code></pre>
<p>可以看到,这里通过 <em>DragEdge</em> 来对应上下左右4个方向的滑动,然后通过 <em>mDragEdges</em> 来存放4个方向对应的 <em>bottomView</em> .</p>
<h4 id="内部view的位置放置"><a href="#内部view的位置放置" class="headerlink" title="内部view的位置放置"></a>内部view的位置放置</h4><p>我们知道关于ViewGroup中child的位置放置是在 <em>onLayout</em> 方法中配置的.so,这里我们看一下swipeLayout的 <em>onLayout</em> 方法:</p>
<pre><code class="java">@Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        updateBottomViews();

        if (mOnLayoutListeners != null) for (int i = 0; i &lt; mOnLayoutListeners.size(); i++) {
            mOnLayoutListeners.get(i).onLayout(this);
        }
    }
</code></pre>
<p>这里重点进入 <em>updateBottomViews</em> 方法,下面的那个位置回调先不用考虑:</p>
<pre><code class="java">private void updateBottomViews() {
        View currentBottomView = getCurrentBottomView();
        if (currentBottomView != null) {
            if (mCurrentDragEdge == DragEdge.Left || mCurrentDragEdge == DragEdge.Right) {
                mDragDistance = currentBottomView.getMeasuredWidth() - dp2px(getCurrentOffset());
            } else {
                mDragDistance = currentBottomView.getMeasuredHeight() - dp2px(getCurrentOffset());
            }
        }
        //在这里对覆盖着的view做重新排列,按照需要
        if (mShowMode == ShowMode.PullOut) {
            layoutPullOut();
        } else if (mShowMode == ShowMode.LayDown) {
            layoutLayDown();
        }

        safeBottomView();
    }
</code></pre>
<p>这个 <em>updateBottomViews</em> 方法是swipeLayout中非常重要的一个方法,一定要明白其中的含义.下面来挨个说明一下:</p>
<ol>
<li><p>首先是获取 <em>currentBottomView</em> 也就是当前滑动方式要显示的下层view.进入 <em>getCurrentBottomView</em> 方法:</p>
<pre><code class="java">public View getCurrentBottomView() {
   List&lt;View&gt; bottoms = getBottomViews();
   if (mCurrentDragEdge.ordinal() &lt; bottoms.size()) {
       return bottoms.get(mCurrentDragEdge.ordinal());
   }
   return null;
}
</code></pre>
<p>在这个方法中,通过 <em>mCurrentDragEdge</em> 来获取到当前的滑动类型,然后从 <em>bottomView</em> 的集合中找到对应滑动类型的 <em>bottomView</em> .那么 <em>mCurrentDragEdge</em> 是在哪里配置的呢?</p>
<pre><code class="java">private static final DragEdge DefaultDragEdge = DragEdge.Right;

private DragEdge mCurrentDragEdge = DefaultDragEdge;
</code></pre>
<p>可以看到默认的 <em>mCurrentDragEdge</em> 是右侧滑动,除了初始化设置 <em>mCurrentDragEdge</em> 外,我们在代码中还可以发现一个方法 :</p>
<pre><code class="java">private void setCurrentDragEdge(DragEdge dragEdge) {
  mCurrentDragEdge = dragEdge;
  updateBottomViews();
}
</code></pre>
<p>这个方法用来设置滑动方式,再追踪这个方法可以发现是在touch方法中来根据touch的event参数来设置滑动方式的,这个后续讲到touch事件处理的时候再说.</p>
<p>再来看如何通过 <em>getBottomViews</em> 方法来获取所有的 <em>bottomView</em> 的.</p>
<pre><code class="java">public List&lt;View&gt; getBottomViews() {
 ArrayList&lt;View&gt; bottoms = new ArrayList&lt;View&gt;();
 for (DragEdge dragEdge : DragEdge.values()) {
     bottoms.add(mDragEdges.get(dragEdge));
 }
 return bottoms;
}
</code></pre>
<p>里面通过遍历上面提到的 <em>mDragEdges</em> 来获取所有的 <em>bottomView</em>.那这个 <em>mDragEdges</em> 又是在哪里设置的呢.通过查看代码调用我们在 <em>addView</em> 方法中找到了下面的代码:</p>
<pre><code class="java">
@Override
public void addView(View child, int index, ViewGroup.LayoutParams params) {
   if (child == null) return;
   int gravity = Gravity.NO_GRAVITY;
   try {
       gravity = (Integer) params.getClass().getField(&quot;gravity&quot;).get(params);
   } catch (Exception e) {
       e.printStackTrace();
   }

   if (gravity &gt; 0) {
       gravity = GravityCompat.getAbsoluteGravity(gravity, ViewCompat.getLayoutDirection(this));

       if ((gravity &amp; Gravity.LEFT) == Gravity.LEFT) {
           mDragEdges.put(DragEdge.Left, child);
       }
       if ((gravity &amp; Gravity.RIGHT) == Gravity.RIGHT) {
           mDragEdges.put(DragEdge.Right, child);
       }
       if ((gravity &amp; Gravity.TOP) == Gravity.TOP) {
           mDragEdges.put(DragEdge.Top, child);
       }
       if ((gravity &amp; Gravity.BOTTOM) == Gravity.BOTTOM) {
           mDragEdges.put(DragEdge.Bottom, child);
       }
   } else {
       for (Map.Entry&lt;DragEdge, View&gt; entry : mDragEdges.entrySet()) {
           if (entry.getValue() == null) {
               //means used the drag_edge attr, the no gravity child should be use set
               mDragEdges.put(entry.getKey(), child);
               break;
           }
       }
   }
   if (child.getParent() == this) {
       return;
   }
   super.addView(child, index, params);
}
</code></pre>
<p>addView是所有的viewGroup都要调用的方法,在这里我们可以看到是通过 <em>gravity</em> 属性来配置到对应的滑动类型的.如果没有配置 <em>gravity</em> 属性,就会遍历 <em>mDragEdges</em> 依次塞入不同的滑动类型中,那 <em>mDragEdges</em> 的默认值又是在哪里配置的呢?通过作者的注释我们看到应该和xml中声明的属性有关,进入构造方法中找到了答案:</p>
<pre><code class="java">public SwipeLayout(Context context, AttributeSet attrs, int defStyle) {
  super(context, attrs, defStyle);
  mDragHelper = ViewDragHelper.create(this, mDragHelperCallback);
  mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();

  TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SwipeLayout);
  int dragEdgeChoices = a.getInt(R.styleable.SwipeLayout_drag_edge, DRAG_RIGHT);
  mEdgeSwipesOffset[DragEdge.Left.ordinal()] = a.getDimension(R.styleable.SwipeLayout_leftEdgeSwipeOffset, 0);
  mEdgeSwipesOffset[DragEdge.Right.ordinal()] = a.getDimension(R.styleable.SwipeLayout_rightEdgeSwipeOffset, 0);
  mEdgeSwipesOffset[DragEdge.Top.ordinal()] = a.getDimension(R.styleable.SwipeLayout_topEdgeSwipeOffset, 0);
  mEdgeSwipesOffset[DragEdge.Bottom.ordinal()] = a.getDimension(R.styleable.SwipeLayout_bottomEdgeSwipeOffset, 0);
  setClickToClose(a.getBoolean(R.styleable.SwipeLayout_clickToClose, mClickToClose));

  if ((dragEdgeChoices &amp; DRAG_LEFT) == DRAG_LEFT) {
      mDragEdges.put(DragEdge.Left, null);
  }
  if ((dragEdgeChoices &amp; DRAG_TOP) == DRAG_TOP) {
      mDragEdges.put(DragEdge.Top, null);
  }
  if ((dragEdgeChoices &amp; DRAG_RIGHT) == DRAG_RIGHT) {
      mDragEdges.put(DragEdge.Right, null);
  }
  if ((dragEdgeChoices &amp; DRAG_BOTTOM) == DRAG_BOTTOM) {
      mDragEdges.put(DragEdge.Bottom, null);
  }
  int ordinal = a.getInt(R.styleable.SwipeLayout_show_mode, ShowMode.PullOut.ordinal());
  mShowMode = ShowMode.values()[ordinal];
  a.recycle();

}
</code></pre>
<p>可以看到这里,通过获取 <em>SwipeLayout_drag_edge</em> 属性来获取在xml中定义的drag类型,然后分别把对应的滑动类型放入 <em>mDragEdges</em> 中.如果在xml中没有声明,使用默认的滑动方式 <em>DRAG_RIGHT</em> 也就是从右侧滑动.</p>
</li>
<li><p>再来看 <em>updateBottomViews</em> 方法下面的部分,如何获取滑动的最大距离 <em>mDragDistance</em> :</p>
<pre><code class="java"> if (currentBottomView != null) {
     if (mCurrentDragEdge == DragEdge.Left || mCurrentDragEdge == DragEdge.Right) {
         mDragDistance = currentBottomView.getMeasuredWidth() - dp2px(getCurrentOffset());
     } else {
         mDragDistance = currentBottomView.getMeasuredHeight() - dp2px(getCurrentOffset());
     }
 }
</code></pre>
<p> 这个 <em>mDragDistance</em> 关系到顶层surfaceView可以滑动的最大距离是多少.实际上就是 <em>currentBottomView</em> 的宽度或者高度加上偏移量.</p>
</li>
<li><p>再来看如何调整各个view的位置的</p>
<pre><code class="java"> //在这里对覆盖着的view做重新排列,按照需要
 if (mShowMode == ShowMode.PullOut) {
     layoutPullOut();
 } else if (mShowMode == ShowMode.LayDown) {
     layoutLayDown();
 }
</code></pre>
<p> 这里对两种showMode做一下说明:<br> a) pullout: 字面理解是拉出的意思,也就是说在拖拉上层view的时候,下层view是跟着拖拽出现的,比如你从左往右拖动上层的view,那下层的view也是通过从左往右出现的,也就是所谓的联动状态<br> b) laydown: 字面解释是沉积和搁置的意思,也就是说在拖拽上层view的时候,下层view是不动的,下层view在上层拖动的时候慢慢展示.</p>
<p> 两种展示方式对应两种bottomView的放置方法, <em>layoutPullOut</em> 和 <em>layoutLayDown</em> 方法内部实现类似,这里只是讲一下第一个方法 :</p>
<pre><code class="java"> void layoutPullOut() {
   View surfaceView = getSurfaceView();
   Rect surfaceRect = mViewBoundCache.get(surfaceView);
   if(surfaceRect == null) surfaceRect = computeSurfaceLayoutArea(false);
   if (surfaceView != null) {
       surfaceView.layout(surfaceRect.left, surfaceRect.top, surfaceRect.right, surfaceRect.bottom);
       //把这个view放在最前面
       bringChildToFront(surfaceView);
   }
   View currentBottomView = getCurrentBottomView();
   Rect bottomViewRect = mViewBoundCache.get(currentBottomView);
   //计算下层view的位置
   if(bottomViewRect == null) bottomViewRect = computeBottomLayoutAreaViaSurface(ShowMode.PullOut, surfaceRect);
   if (currentBottomView != null) {
       currentBottomView.layout(bottomViewRect.left, bottomViewRect.top, bottomViewRect.right, bottomViewRect.bottom);
   }
 }
</code></pre>
<p> 这个方法分成两部分,一部分是设置 <em>surfaceView</em> 的位置,一部分是设置 <em>currentBottomView</em> 的位置.同时把设置的位置参数存入缓存集合 <em>mViewBoundCache</em> 中.<br> 来看配置surfaceView位置的方法 <em>computeSurfaceLayoutArea</em> :</p>
<pre><code class="java"> private Rect computeSurfaceLayoutArea(boolean open) {
   int l = getPaddingLeft(), t = getPaddingTop();
   if (open) {
       if (mCurrentDragEdge == DragEdge.Left)
           l = getPaddingLeft() + mDragDistance;
       else if (mCurrentDragEdge == DragEdge.Right)
           l = getPaddingLeft() - mDragDistance;
       else if (mCurrentDragEdge == DragEdge.Top)
           t = getPaddingTop() + mDragDistance;
       else t = getPaddingTop() - mDragDistance;
   }
   return new Rect(l, t, l + getMeasuredWidth(), t + getMeasuredHeight());
 }
</code></pre>
<p> 如果是覆盖状态,那么顶层view的上下左右应该和swipeLayout的上下左右相同.<br> 如果是打开状态,那么根据上下左右的滑动情况结合 <em>mDragDistance</em> 来调整位置,非常容易理解,如果看不明白代码的话可以在纸上划一下就明白了.</p>
<p> 再来看设置 <em>bottomView</em> 位置的方法 <em>computeBottomLayoutAreaViaSurface</em> :</p>
<pre><code class="java"> private Rect computeBottomLayoutAreaViaSurface(ShowMode mode, Rect surfaceArea) {
  Rect rect = surfaceArea;
  View bottomView = getCurrentBottomView();

  int bl = rect.left, bt = rect.top, br = rect.right, bb = rect.bottom;
  if (mode == ShowMode.PullOut) {
      if (mCurrentDragEdge == DragEdge.Left)
          bl = rect.left - mDragDistance;
      else if (mCurrentDragEdge == DragEdge.Right)
          bl = rect.right;
      else if (mCurrentDragEdge == DragEdge.Top)
          bt = rect.top - mDragDistance;
      else bt = rect.bottom;

      if (mCurrentDragEdge == DragEdge.Left || mCurrentDragEdge == DragEdge.Right) {
          bb = rect.bottom;
          br = bl + (bottomView == null ? 0 : bottomView.getMeasuredWidth());
      } else {
          bb = bt + (bottomView == null ? 0 : bottomView.getMeasuredHeight());
          br = rect.right;
      }
  } else if (mode == ShowMode.LayDown) {
      if (mCurrentDragEdge == DragEdge.Left)
          br = bl + mDragDistance;
      else if (mCurrentDragEdge == DragEdge.Right)
          bl = br - mDragDistance;
      else if (mCurrentDragEdge == DragEdge.Top)
          bb = bt + mDragDistance;
      else bt = bb - mDragDistance;

  }
  return new Rect(bl, bt, br, bb);

 }
</code></pre>
<p> 这个方法直接根据不同的showMode来设置 <em>bottomView</em> 的位置.其实很好理解,如果是 <em>PullOut</em> 的话bottomView是在SwipeLayout的外部4个方向上,然后跟着滑动再慢慢进入swipeLayout中展示;而 <em>LayDown</em> 是bottomView本来就在swipeLayout中对应要显示的位置上,只是被上层view给盖住了而已.</p>
</li>
<li><p>最后来看 <em>safeBottomView</em> 方法:</p>
<pre><code class="java"> private void safeBottomView() {
   Status status = getOpenStatus();
   List&lt;View&gt; bottoms = getBottomViews();

   if (status == Status.Close) {
       for (View bottom : bottoms) {
           if (bottom != null &amp;&amp; bottom.getVisibility() != INVISIBLE) {
               bottom.setVisibility(INVISIBLE);
           }
       }
   } else {
       View currentBottomView = getCurrentBottomView();
       if (currentBottomView != null &amp;&amp; currentBottomView.getVisibility() != VISIBLE) {
           currentBottomView.setVisibility(VISIBLE);
       }
   }
 }
</code></pre>
<p> 通过判断当前顶层surfaceView的状态来控制bottomView的隐藏显示,如果是 <em>close</em> 状态,所有的bottomView都隐藏,反之显示当前滑动状态对应的bottomView.</p>
</li>
</ol>
<h4 id="ViewDragHelper相关配置"><a href="#ViewDragHelper相关配置" class="headerlink" title="ViewDragHelper相关配置"></a>ViewDragHelper相关配置</h4><pre><code>进过上面的各类view的配置完成后,就进入view滑动的核心控制类ViewDragHelper的配置了,进过之前讲解 *ViewDragHelper的用法与源码分析* 我们明白想要让View可以被拖动的核心是实现ViewDragHelper中callback的各个接口方法.下面就来看一下swipeLayout中callback的实现.
```java
private ViewDragHelper.Callback mDragHelperCallback = new ViewDragHelper.Callback() {

   @Override
   public int clampViewPositionHorizontal(View child, int left, int dx) {
       if (child == getSurfaceView()) {
           //顶层view可以滑动的最大横向距离
           switch (mCurrentDragEdge) {
               case Top:
               case Bottom:
                   return getPaddingLeft();
               case Left:
                   if (left &lt; getPaddingLeft()) return getPaddingLeft();
                   if (left &gt; getPaddingLeft() + mDragDistance)
                       return getPaddingLeft() + mDragDistance;
                   break;
               case Right:
                   if (left &gt; getPaddingLeft()) return getPaddingLeft();
                   if (left &lt; getPaddingLeft() - mDragDistance)
                       return getPaddingLeft() - mDragDistance;
                   break;
           }
       } else if (getCurrentBottomView() == child) {

           switch (mCurrentDragEdge) {
               case Top:
               case Bottom:
                   return getPaddingLeft();
               case Left:
                   if (mShowMode == ShowMode.PullOut) {
                       if (left &gt; getPaddingLeft()) return getPaddingLeft();
                   }
                   break;
               case Right:
                   if (mShowMode == ShowMode.PullOut) {
                       if (left &lt; getMeasuredWidth() - mDragDistance) {
                           return getMeasuredWidth() - mDragDistance;
                       }
                   }
                   break;
           }
       }
       return left;
   }

   @Override
   public int clampViewPositionVertical(View child, int top, int dy) {
       if (child == getSurfaceView()) {
           switch (mCurrentDragEdge) {
               case Left:
               case Right:
                   return getPaddingTop();
               case Top:
                   if (top &lt; getPaddingTop()) return getPaddingTop();
                   if (top &gt; getPaddingTop() + mDragDistance)
                       return getPaddingTop() + mDragDistance;
                   break;
               case Bottom:
                   if (top &lt; getPaddingTop() - mDragDistance) {
                       return getPaddingTop() - mDragDistance;
                   }
                   if (top &gt; getPaddingTop()) {
                       return getPaddingTop();
                   }
           }
       } else {
           View surfaceView = getSurfaceView();
           int surfaceViewTop = surfaceView == null ? 0 : surfaceView.getTop();
           switch (mCurrentDragEdge) {
               case Left:
               case Right:
                   return getPaddingTop();
               case Top:
                   if (mShowMode == ShowMode.PullOut) {
                       if (top &gt; getPaddingTop()) return getPaddingTop();
                   } else {
                       if (surfaceViewTop + dy &lt; getPaddingTop())
                           return getPaddingTop();
                       if (surfaceViewTop + dy &gt; getPaddingTop() + mDragDistance)
                           return getPaddingTop() + mDragDistance;
                   }
                   break;
               case Bottom:
                   if (mShowMode == ShowMode.PullOut) {
                       if (top &lt; getMeasuredHeight() - mDragDistance)
                           return getMeasuredHeight() - mDragDistance;
                   } else {
                       if (surfaceViewTop + dy &gt;= getPaddingTop())
                           return getPaddingTop();
                       if (surfaceViewTop + dy &lt;= getPaddingTop() - mDragDistance)
                           return getPaddingTop() - mDragDistance;
                   }
           }
       }
       return top;
   }

   @Override
   public boolean tryCaptureView(View child, int pointerId) {
       //这里相当于所有的子view都可以被滑动
       boolean result = child == getSurfaceView() || getBottomViews().contains(child);
       if (result) {
           isCloseBeforeDrag = getOpenStatus() == Status.Close;
       }
       return result;
   }

   @Override
   public int getViewHorizontalDragRange(View child) {
       return mDragDistance;
   }

   @Override
   public int getViewVerticalDragRange(View child) {
       return mDragDistance;
   }

   boolean isCloseBeforeDrag = true;

   @Override
   public void onViewReleased(View releasedChild, float xvel, float yvel) {
       super.onViewReleased(releasedChild, xvel, yvel);
       processHandRelease(xvel, yvel, isCloseBeforeDrag);
       for (SwipeListener l : mSwipeListeners) {
           l.onHandRelease(SwipeLayout.this, xvel, yvel);
       }

       invalidate();
   }

   @Override
   public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
       View surfaceView = getSurfaceView();
       if (surfaceView == null) return;
       View currentBottomView = getCurrentBottomView();
       int evLeft = surfaceView.getLeft(),
               evRight = surfaceView.getRight(),
               evTop = surfaceView.getTop(),
               evBottom = surfaceView.getBottom();
       if (changedView == surfaceView) {
           //通知下层的view也移动对应的距离,因为你拖动上层view的时候,下层view是不会自己动的
           if (mShowMode == ShowMode.PullOut &amp;&amp; currentBottomView != null) {
               if (mCurrentDragEdge == DragEdge.Left || mCurrentDragEdge == DragEdge.Right) {
                   currentBottomView.offsetLeftAndRight(dx);
               } else {
                   currentBottomView.offsetTopAndBottom(dy);
               }
           }

       } else if (getBottomViews().contains(changedView)) {

           if (mShowMode == ShowMode.PullOut) {
               surfaceView.offsetLeftAndRight(dx);
               surfaceView.offsetTopAndBottom(dy);
           } else {
               Rect rect = computeBottomLayDown(mCurrentDragEdge);
               if (currentBottomView != null) {
                   //下层view保持不变
                   currentBottomView.layout(rect.left, rect.top, rect.right, rect.bottom);
               }

               int newLeft = surfaceView.getLeft() + dx, newTop = surfaceView.getTop() + dy;

               if (mCurrentDragEdge == DragEdge.Left &amp;&amp; newLeft &lt; getPaddingLeft())
                   newLeft = getPaddingLeft();
               else if (mCurrentDragEdge == DragEdge.Right &amp;&amp; newLeft &gt; getPaddingLeft())
                   newLeft = getPaddingLeft();
               else if (mCurrentDragEdge == DragEdge.Top &amp;&amp; newTop &lt; getPaddingTop())
                   newTop = getPaddingTop();
               else if (mCurrentDragEdge == DragEdge.Bottom &amp;&amp; newTop &gt; getPaddingTop())
                   newTop = getPaddingTop();
               //上层的view移动
               surfaceView.layout(newLeft, newTop, newLeft + getMeasuredWidth(), newTop + getMeasuredHeight());
           }
       }
       //回调
       dispatchRevealEvent(evLeft, evTop, evRight, evBottom);
       //回调
       dispatchSwipeEvent(evLeft, evTop, dx, dy);

       invalidate();
       //保持一下下层view的位置,方便layout的时候直接调用
       captureChildrenBound();
   }
};
```
我们来按照实现顺序重点讲解一下这几个接口方法:
1. *tryCaptureView(View child, int pointerId)*
    这个方法用来判断当前手势滑动的view是否是我们允许滑动的view,如果返回false说明当前不允许这个view滑动,true的话是运行滑动.
    ```java
    @Override
   public boolean tryCaptureView(View child, int pointerId) {
       //这里相当于所有的子view都可以被滑动
       boolean result = child == getSurfaceView() || getBottomViews().contains(child);
       if (result) {
           isCloseBeforeDrag = getOpenStatus() == Status.Close;
       }
       return result;
    }
    ```
    在这里可以看到,所有的bottomView和surfaceView都是可以滑动的.
2. *getViewHorizontalDragRange* 和 *getViewVerticalDragRange*
    这两个方法用来配置横向和纵向可以滑动的最大距离,这里统一用的就是上面计算出的 *mDragDistance*
    ```java
    @Override
    public int getViewHorizontalDragRange(View child) {
        return mDragDistance;
    }

    @Override
    public int getViewVerticalDragRange(View child) {
        return mDragDistance;
    }
    ```
3. *clampViewPositionHorizontal* 和 *clampViewPositionVertical*
    这个方法用来控制横向和纵向允许滑动的最大距离,防止滑动越界.这里讲解一下横向的计算方式,纵向和这个类似就不重复了.
    ```java
    @Override
    public int clampViewPositionHorizontal(View child, int left, int dx) {
        if (child == getSurfaceView()) {
            //顶层view可以滑动的最大横向距离
            switch (mCurrentDragEdge) {
                case Top:
                case Bottom:
                    return getPaddingLeft();
                case Left:
                    if (left &lt; getPaddingLeft()) return getPaddingLeft();
                    if (left &gt; getPaddingLeft() + mDragDistance)
                        return getPaddingLeft() + mDragDistance;
                    break;
                case Right:
                    if (left &gt; getPaddingLeft()) return getPaddingLeft();
                    if (left &lt; getPaddingLeft() - mDragDistance)
                        return getPaddingLeft() - mDragDistance;
                    break;
            }
        } else if (getCurrentBottomView() == child) {

            switch (mCurrentDragEdge) {
                case Top:
                case Bottom:
                    return getPaddingLeft();
                case Left:
                    if (mShowMode == ShowMode.PullOut) {
                        if (left &gt; getPaddingLeft()) return getPaddingLeft();
                    }
                    break;
                case Right:
                    if (mShowMode == ShowMode.PullOut) {
                        if (left &lt; getMeasuredWidth() - mDragDistance) {
                            return getMeasuredWidth() - mDragDistance;
                        }
                    }
                    break;
            }
        }
        return left;
    }
    ```
    分两部分来看,首先是surfaceView
    如果是上下两个方向的滑动,那么相当于在横向上是不允许移动的,这里不设置为0是因为要考虑padding,所以返回left只能是getPaddingLeft.
    如果是横向滑动的话,又分为左右两个方向处理.
    如果drag类型是 *left* ,说明是向右滑动露出左边,这个left只能大于 *getPaddingLeft* 小于  *getPaddingLeft + mDragDistance* (正值).
    如果是 *right* ,说明向左拉动,露出右边,这个时候left只能是小于 *getPaddingLeft* 大于 *getPaddingLeft - mDragDistance* (负值).

    再来看bottomView
    上下两个方向不允许滑动,所以返回 *getPaddingLeft* .
    如果drag类型是 *left*
    a) pullout 这个时候bottomView是在swipeLayout的左侧外部,所以它可以滑动到的最大left只能是从负的到正的 *getPaddingLeft*
    如果drag类型是 *right*
    a) pullout 这个时候bottomView是在swipeLayout的右侧外部,所以它最多可以划进来自己本身宽度那么大的距离,所以这里用的 *getMeasuredWidth() - mDragDistance* ,用SwipeLayout的宽度减去bottomView的宽度,就是距离左边的距离.
4. *onViewPositionChanged*
    ```java
    @Override
   public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
       View surfaceView = getSurfaceView();
       if (surfaceView == null) return;
       View currentBottomView = getCurrentBottomView();
       int evLeft = surfaceView.getLeft(),
               evRight = surfaceView.getRight(),
               evTop = surfaceView.getTop(),
               evBottom = surfaceView.getBottom();
       if (changedView == surfaceView) {
           //通知下层的view也移动对应的距离,因为你拖动上层view的时候,下层view是不会自己动的
           if (mShowMode == ShowMode.PullOut &amp;&amp; currentBottomView != null) {
               if (mCurrentDragEdge == DragEdge.Left || mCurrentDragEdge == DragEdge.Right) {
                   currentBottomView.offsetLeftAndRight(dx);
               } else {
                   currentBottomView.offsetTopAndBottom(dy);
               }
           }

       } else if (getBottomViews().contains(changedView)) {

           if (mShowMode == ShowMode.PullOut) {
               surfaceView.offsetLeftAndRight(dx);
               surfaceView.offsetTopAndBottom(dy);
           } else {
               Rect rect = computeBottomLayDown(mCurrentDragEdge);
               if (currentBottomView != null) {
                   //下层view保持不变
                   currentBottomView.layout(rect.left, rect.top, rect.right, rect.bottom);
               }

               int newLeft = surfaceView.getLeft() + dx, newTop = surfaceView.getTop() + dy;

               if (mCurrentDragEdge == DragEdge.Left &amp;&amp; newLeft &lt; getPaddingLeft())
                   newLeft = getPaddingLeft();
               else if (mCurrentDragEdge == DragEdge.Right &amp;&amp; newLeft &gt; getPaddingLeft())
                   newLeft = getPaddingLeft();
               else if (mCurrentDragEdge == DragEdge.Top &amp;&amp; newTop &lt; getPaddingTop())
                   newTop = getPaddingTop();
               else if (mCurrentDragEdge == DragEdge.Bottom &amp;&amp; newTop &gt; getPaddingTop())
                   newTop = getPaddingTop();
               //上层的view移动
               surfaceView.layout(newLeft, newTop, newLeft + getMeasuredWidth(), newTop + getMeasuredHeight());
           }
       }
       //回调
       dispatchRevealEvent(evLeft, evTop, evRight, evBottom);
       //回调
       dispatchSwipeEvent(evLeft, evTop, dx, dy);

       invalidate();
       //保持一下下层view的位置,方便layout的时候直接调用
       captureChildrenBound();
    }
    ```
    这个方法是在滑动view的时候位置发生变化的回调方法,也是我们实现view滑动效果的关键.
    重点是对应 *pullout* 这种方式,因为是如果是这种显示模式的话,是要两个view联动,一个是ViewDragHelper帮我们滑动的那个view,另一个是要联动的另一个view.这个是联动的关键.
    先来看if判断第一部分,如果滑动的是surfaceView,让 *currentBottomView* 跟着surfaceView一起滑动相应的距离.
    再来看if判断的第二部分,如果滑动的是bottomView,这个时候要判断是否是pullout方式
      a) 是,那么也要保证在滑动bottomView的时候,surfaceView也要跟着移动对应的距离
      b) 不是,那么保证bottomView不要动也就是一直设置bottomView的固定位置,同时让surfaceView反向移动.
    最后来看剩下的几个方法:
      a) *dispatchRevealEvent* 和 *dispatchSwipeEvent* 这两个方法用来做滑动事件的回调,这里不做展开
      b) *invalidate* 重新要求swipeLayout绘制,实现滑动的关键方法
      c) *captureChildrenBound* 保存一下surfaceView和bottomView的位置信息,节省下次计算时间.

5. onViewReleased
  ```java
  @Override
   public void onViewReleased(View releasedChild, float xvel, float yvel) {
       super.onViewReleased(releasedChild, xvel, yvel);
       processHandRelease(xvel, yvel, isCloseBeforeDrag);
       for (SwipeListener l : mSwipeListeners) {
           l.onHandRelease(SwipeLayout.this, xvel, yvel);
       }

       invalidate();
   }
  ```
  根据方法名称可以知道是用来处理手指松开之后的事件处理的.核心处理在 *processHandRelease* 方法.
  ```java
  protected void processHandRelease(float xvel, float yvel, boolean isCloseBeforeDragged) {
    float minVelocity = mDragHelper.getMinVelocity();
    View surfaceView = getSurfaceView();
    DragEdge currentDragEdge = mCurrentDragEdge;
    if (currentDragEdge == null || surfaceView == null) {
        return;
    }
    float willOpenPercent = (isCloseBeforeDragged ? mWillOpenPercentAfterClose : mWillOpenPercentAfterOpen);
    if (currentDragEdge == DragEdge.Left) {
        if (xvel &gt; minVelocity) open();
        else if (xvel &lt; -minVelocity) close();
        else {
            float openPercent = 1f * getSurfaceView().getLeft() / mDragDistance;
            if (openPercent &gt; willOpenPercent) open();
            else close();
        }
    } else if (currentDragEdge == DragEdge.Right) {
        if (xvel &gt; minVelocity) close();
        else if (xvel &lt; -minVelocity) open();
        else {
            float openPercent = 1f * (-getSurfaceView().getLeft()) / mDragDistance;
            if (openPercent &gt; willOpenPercent) open();
            else close();
        }
    } else if (currentDragEdge == DragEdge.Top) {
        if (yvel &gt; minVelocity) open();
        else if (yvel &lt; -minVelocity) close();
        else {
            float openPercent = 1f * getSurfaceView().getTop() / mDragDistance;
            if (openPercent &gt; willOpenPercent) open();
            else close();
        }
    } else if (currentDragEdge == DragEdge.Bottom) {
        if (yvel &gt; minVelocity) close();
        else if (yvel &lt; -minVelocity) open();
        else {
            float openPercent = 1f * (-getSurfaceView().getTop()) / mDragDistance;
            if (openPercent &gt; willOpenPercent) open();
            else close();
        }
    }
}
```
里面是大量的临界判断,比如当你拖拽的距离超过最大距离一半时松手时,那么应该进入到展开状态,反之就进入关闭状态,这是良好用户体验的基础.坐标判断就不展开了,来看最终的状态处理 *open* 和 *close* 方法.

```java
public void close(boolean smooth, boolean notify) {
    View surface = getSurfaceView();
    if (surface == null) {
        return;
    }
    int dx, dy;
    if (smooth)
        mDragHelper.smoothSlideViewTo(getSurfaceView(), getPaddingLeft(), getPaddingTop());
    else {
        Rect rect = computeSurfaceLayoutArea(false);
        dx = rect.left - surface.getLeft();
        dy = rect.top - surface.getTop();
        surface.layout(rect.left, rect.top, rect.right, rect.bottom);
        if (notify) {
            dispatchRevealEvent(rect.left, rect.top, rect.right, rect.bottom);
            dispatchSwipeEvent(rect.left, rect.top, dx, dy);
        } else {
            safeBottomView();
        }
    }
    invalidate();
}
```
可以看到这里用到了 *smoothSlideViewTo* 这个方法,让surfaceView来复位,最后再重回swipeLayout.这里关于ViewDragHelper的 *smoothSlideViewTo* 方法有个关键点,在后面的注意事项中我们再说.
```java
public void open(boolean smooth, boolean notify) {
   View surface = getSurfaceView(), bottom = getCurrentBottomView();
   if (surface == null) {
       return;
   }
   int dx, dy;
   Rect rect = computeSurfaceLayoutArea(true);
   if (smooth) {
       mDragHelper.smoothSlideViewTo(surface, rect.left, rect.top);
   } else {
       dx = rect.left - surface.getLeft();
       dy = rect.top - surface.getTop();
       surface.layout(rect.left, rect.top, rect.right, rect.bottom);
       if (getShowMode() == ShowMode.PullOut) {
           Rect bRect = computeBottomLayoutAreaViaSurface(ShowMode.PullOut, rect);
           if (bottom != null) {
               bottom.layout(bRect.left, bRect.top, bRect.right, bRect.bottom);
           }
       }
       if (notify) {
           dispatchRevealEvent(rect.left, rect.top, rect.right, rect.bottom);
           dispatchSwipeEvent(rect.left, rect.top, dx, dy);
       } else {
           safeBottomView();
       }
   }
   invalidate();
}
```
open方法和close方法类似,也是通过 *smoothSlideViewTo* 来完成最终的展开的.
</code></pre><p>  到这里,callback的核心接口方法就讲完了,实际上swipeLayout的主要流程到这里就基本讲完了,可以看到主要实现就是callback中的逻辑处理.剩下的就是关于swipeLayout的一些注意事项和容易忽略的地方讲解.</p>
<h4 id="冲突解决与注意事项"><a href="#冲突解决与注意事项" class="headerlink" title="冲突解决与注意事项"></a>冲突解决与注意事项</h4><p>  到这里,你可能很好奇,为什么没有找到ViewDragHelper的调用地方,那是因为这里有两个关键点容易以往,在这里来重点讲解一下.先来看swipeLayout的触摸拦截方法 <em>onInterceptTouchEvent</em></p>
<pre><code class="java">  @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (!isSwipeEnabled()) {
            return false;
        }
        if (mClickToClose &amp;&amp; getOpenStatus() == Status.Open &amp;&amp; isTouchOnSurface(ev)) {
            return true;
        }
        for (SwipeDenier denier : mSwipeDeniers) {
            if (denier != null &amp;&amp; denier.shouldDenySwipe(ev)) {
                return false;
            }
        }

        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                mDragHelper.processTouchEvent(ev);
                mIsBeingDragged = false;
                sX = ev.getRawX();
                sY = ev.getRawY();
                //if the swipe is in middle state(scrolling), should intercept the touch
                if (getOpenStatus() == Status.Middle) {
                    mIsBeingDragged = true;
                }
                break;
            case MotionEvent.ACTION_MOVE:
                boolean beforeCheck = mIsBeingDragged;
                checkCanDrag(ev);
                if (mIsBeingDragged) {
                    //向父类申请不要拦截触摸事件,注意这里是viewGroup向它的父类申请不要拦截触摸事件
                    ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                if (!beforeCheck &amp;&amp; mIsBeingDragged) {
                    //let children has one chance to catch the touch, and request the swipe not intercept
                    //useful when swipeLayout wrap a swipeLayout or other gestural layout
                    return false;
                }
                break;

            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                mIsBeingDragged = false;
                mDragHelper.processTouchEvent(ev);
                break;
            default://handle other action, such as ACTION_POINTER_DOWN/UP
                mDragHelper.processTouchEvent(ev);
        }
        return mIsBeingDragged;
    }
</code></pre>
<p>  在这里主要目的是为了解决如果和父类滑动事件冲突的时候如何处理呢,比如把swipeLayout放入listView,如果你沿着斜上方来滑动listView,很容易对swipeLayout造成影响,这个时候我们在 <em>ACTION_MOVE</em> 方法中,通过一个变量 <em>mIsBeingDragged</em> 判断是否要求父类不要拦截我们的swipeLayout的滑动事件.要求父类不要拦截滑动事件可以调用</p>
<pre><code class="java">  ViewParent parent = getParent();
  if (parent != null) {
      parent.requestDisallowInterceptTouchEvent(true);
  }
</code></pre>
<p>  <em>mIsBeingDragged</em> 是通过 <em>checkCanDrag</em> 方法来赋值的.</p>
<pre><code class="java">  //根据滑动的方式来判断是哪一种类型的drag方式
    private void checkCanDrag(MotionEvent ev) {
        if (mIsBeingDragged) return;
        if (getOpenStatus() == Status.Middle) {
            mIsBeingDragged = true;
            return;
        }
        Status status = getOpenStatus();
        float distanceX = ev.getRawX() - sX;
        float distanceY = ev.getRawY() - sY;
        float angle = Math.abs(distanceY / distanceX);
        angle = (float) Math.toDegrees(Math.atan(angle));
        if (getOpenStatus() == Status.Close) {
            //通过角度判断滑动的方向
            DragEdge dragEdge;
            if (angle &lt; 45) {
                if (distanceX &gt; 0 &amp;&amp; isLeftSwipeEnabled()) {
                    dragEdge = DragEdge.Left;
                } else if (distanceX &lt; 0 &amp;&amp; isRightSwipeEnabled()) {
                    dragEdge = DragEdge.Right;
                } else return;

            } else {
                if (distanceY &gt; 0 &amp;&amp; isTopSwipeEnabled()) {
                    dragEdge = DragEdge.Top;
                } else if (distanceY &lt; 0 &amp;&amp; isBottomSwipeEnabled()) {
                    dragEdge = DragEdge.Bottom;
                } else return;
            }
            setCurrentDragEdge(dragEdge);
        }

        boolean doNothing = false;
        if (mCurrentDragEdge == DragEdge.Right) {
            boolean suitable = (status == Status.Open &amp;&amp; distanceX &gt; mTouchSlop)
                    || (status == Status.Close &amp;&amp; distanceX &lt; -mTouchSlop);
            suitable = suitable || (status == Status.Middle);

            if (angle &gt; 30 || !suitable) {
                doNothing = true;
            }
        }

        if (mCurrentDragEdge == DragEdge.Left) {
            boolean suitable = (status == Status.Open &amp;&amp; distanceX &lt; -mTouchSlop)
                    || (status == Status.Close &amp;&amp; distanceX &gt; mTouchSlop);
            suitable = suitable || status == Status.Middle;

            if (angle &gt; 30 || !suitable) {
                doNothing = true;
            }
        }

        if (mCurrentDragEdge == DragEdge.Top) {
            boolean suitable = (status == Status.Open &amp;&amp; distanceY &lt; -mTouchSlop)
                    || (status == Status.Close &amp;&amp; distanceY &gt; mTouchSlop);
            suitable = suitable || status == Status.Middle;

            if (angle &lt; 60 || !suitable) {
                doNothing = true;
            }
        }

        if (mCurrentDragEdge == DragEdge.Bottom) {
            boolean suitable = (status == Status.Open &amp;&amp; distanceY &gt; mTouchSlop)
                    || (status == Status.Close &amp;&amp; distanceY &lt; -mTouchSlop);
            suitable = suitable || status == Status.Middle;

            if (angle &lt; 60 || !suitable) {
                doNothing = true;
            }
        }
        mIsBeingDragged = !doNothing;
    }
</code></pre>
<p>  抛开滑动方式,展示方式之后,这个方法就是通过判断滑动角度来判断是否满足swipeLayout的滑动条件.如果满足就返回 true,通知父类不要拦截事件,反之,就任由父类来拦截处理了.</p>
<p>  最后来看下 <em>onTouchEvent</em> 方法.</p>
<pre><code class="java">  @Override
   public boolean onTouchEvent(MotionEvent event) {
       if (!isSwipeEnabled()) return super.onTouchEvent(event);

       int action = event.getActionMasked();
       gestureDetector.onTouchEvent(event);

       switch (action) {
           case MotionEvent.ACTION_DOWN:
               mDragHelper.processTouchEvent(event);
               sX = event.getRawX();
               sY = event.getRawY();


           case MotionEvent.ACTION_MOVE: {
               //the drag state and the direction are already judged at onInterceptTouchEvent
               checkCanDrag(event);
               if (mIsBeingDragged) {
                   //向父类申请不要拦截触摸事件,注意这里是viewGroup向它的父类申请不要拦截触摸事件
                   getParent().requestDisallowInterceptTouchEvent(true);
                   mDragHelper.processTouchEvent(event);
               }
               break;
           }
           case MotionEvent.ACTION_UP:
           case MotionEvent.ACTION_CANCEL:
               mIsBeingDragged = false;
               mDragHelper.processTouchEvent(event);
               break;

           default://handle other action, such as ACTION_POINTER_DOWN/UP
               mDragHelper.processTouchEvent(event);
       }

       return super.onTouchEvent(event) || mIsBeingDragged || action == MotionEvent.ACTION_DOWN;
   }
</code></pre>
<p>  这个方法与 <em>onInterceptTouchEvent</em> 方法一样,也是要判断滑动的条件是否满足才通知父类是否拦截事件.</p>
<p>  最后的最后,我自己在照着swipeLayout自己实现一个简单的侧滑viewGroup的时候,发现调用 <em>smoothSlideViewTo</em> 不起作用,开始以为是像网上说的 <em>invalidate</em> 在不同手机上无效的问题,后来发现是没有好好理解ViewDragHelper的 <em>smoothSlideViewTo</em> 方法原理.<br>  看下 <em>smoothSlideViewTo</em> 方法,我们可以发现内部是通过 <em>scroller</em> 来实现的view的移动的,如果我们不继承实现 <em>computeScroll</em> 是无法让view移动的.<br>  最后在swipeLayout中发现了方法 <em>computeScroll</em> .</p>
<pre><code class="java">    @Override
    public void computeScroll() {
        super.computeScroll();
        if (mDragHelper.continueSettling(true)) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }
</code></pre>
<p>到这里,swipeLayout的主要实现就讲完了,回头看一下核心点就是在ViewDragHelper的使用上面,所以还是感觉有以为的同学可以看一下之前写的的一篇 <em>ViewDragHelper源码分析</em> 讲解来对照学习.就到这里吧 .</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/0911/1680.html" title="ViewDragHelper详解" target="_blank" rel="external">ViewDragHelper详解</a></p>
<p><a href="https://github.com/daimajia/AndroidSwipeLayout" title="github androidSwipeLayout" target="_blank" rel="external">github androidSwipeLayout</a></p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>