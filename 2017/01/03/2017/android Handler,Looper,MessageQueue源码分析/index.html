<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> android Handler,Looper,MessageQueue源码分析 · pheobusyy</title><meta name="description" content="android Handler,Looper,MessageQueue源码分析 - yanyi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://pheobusyy.github.io/atom.xml" title="pheobusyy"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">android Handler,Looper,MessageQueue源码分析</h1><div class="post-info">Jan 3, 2017</div><div class="post-content"><h2 id="android-Handler-Looper-MessageQueue源码分析"><a href="#android-Handler-Looper-MessageQueue源码分析" class="headerlink" title="android Handler,Looper,MessageQueue源码分析"></a>android Handler,Looper,MessageQueue源码分析</h2><p>  Handler是一个在android开发过程中经常用到的类,同时在面试的时候也会经常问道其中的实现原理,那今天就重点讲解一下Handler的用法和实现原理.</p>
<blockquote>
<p>一个Handler可以使你发送并处理一个消息或者线程通过关联一个 <em>MessageQueue</em> .每一个handler的实例都唯一关联一个线程和 <em>MessageQueue</em> .当你创建一个Handler它就和当前线程和线程的 <em>MessageQueue</em> 绑定在一起了.它会发送消息或者线程到对应 <em>MessageQueue</em> ,并且在从 <em>MessageQueue</em> 取出的时候执行它们.<br>Handler主要有两个作用:一个是可以在未来的某个时间点执行消息或者线程 ;另一个是在你当前拥有的另一个线程中排队执行一些任务.<br>发送消息一般可以使用 post(Runnable),postAtTime(Runnable,long),postDelay(Runnable,long),sendEmptyMessage(int),sendMessage(Message),sendMessageAtTime(Message,long) 和 sendMessageDelay(Message,long).这几个方法.post开头的方法可以在消息队列入队的时候调用.而sendMessage开头的方法允许把一个带有bundle对象的消息对象入队,并在未来交给 <em>handleMessage(Message)</em> 去处理.</p>
</blockquote>
<p>  上面这个是我照着官方文档翻译的,水平有限,说白了就是Handler可以把消息对象或者线程放入消息队列中,等到出列的时候调用.<br>  比如当子线程中发送网络请求之后回调可以通过给主线程的handler发送一个message,这样可以把网络请求的回调结果返回到主线程中处理.</p>
<p>  下面开始分析Handler的源码:</p>
<h3 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h3><p>  我们先从Handler的使用入口来看,也就是那一堆post和sendMessage开头的方法入手,可以看到所有的传递事件的方法最终都是调用了 <em>sendMessageAtTime</em> :</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">      MessageQueue queue = mQueue;</div><div class="line">      <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">          RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                  <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">          Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>  post方法开头的只是多做了一部处理,把Runnable对象作为message的回调使用了,然后也是调用了 <em>sendMessageAtTime</em> :<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">    Message m = Message.obtain();</div><div class="line">    m.callback = r;</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  可以看到在 <em>sendMessageAtTime</em> 的方法刚开始的时候显示判断消息队列 <em>MessageQueue</em> 是否为空,如果为空的直接返回false不予执行.那这个消息队列是从哪里来的的呢?这个时候回到Handler的构造方法:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">*.......</div><div class="line">*<span class="doctag">@hide</span></div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>(<span class="keyword">null</span>, async);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">         <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">         <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                 (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">             Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                 klass.getCanonicalName());</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     mLooper = Looper.myLooper();</div><div class="line">     <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">             <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">     &#125;</div><div class="line">     mQueue = mLooper.mQueue;</div><div class="line">     mCallback = callback;</div><div class="line">     mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  这里有个细节就是6个构造函数的其中一个是不对外开放的,就是那个加了 <em>@hide</em> 注解的构造函数.也就是这个构造函数只能在手机自己内部调用,和android的internal包戏下面的代码一样,都是不对外开发的.</p>
<p>  可以看到在构造方法顶部有一个tip提示,就是说如果这里handler不是静态的话可能导致内存泄漏,这种情况是很常见的,内部类持有外部类的引用,也就是当前handler持有外部的activity对象,当activity销毁的时候,如果handler中还是有任务没有完成的,activity是无法被内存回收的.这就会导致内存泄漏,解决方法就是把handler设置为static并且把activity的关联设置为弱引用(WeakReference).</p>
<p>  继续往下看,开始调用 Looper.myLooper() 如果Looper对象为空的话抛出异常,看来handler必须能够获取到looper对象,否者没法往下执行.到了后面我们就知道,looper的作用是用来不停的从消息队列中取出消息来交给Handler来执行的.所以没有looper的话handler获取不到消息就没有了意义.<br>  在往下就会发现handler里面的 MessageQueue用的就是looper里面的mQueue.后面我们在分析looper的实现.现在消息队列有了,我们回到上面的 <em>sendMessageAtTime</em> 方法中.可以看到该方法最终调用了 <em>enqueueMessage</em> 方法.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">     msg.target = <span class="keyword">this</span>;</div><div class="line">     <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">         msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  非常简单,调用消息队列自己的 <em>enqueueMessage</em> 方法,这里如果handler设置为异步(mAsynchronous)的话,那发送的消息类型也是异步的.至于异步有啥作用,我们后面会提到.<br>  可以看到Handler的代码非常的见到,就是把消息放入消息队列中就完成任务了.那怎么从消息队列中取出消息来回调了,这个功能就交给下面要讲的looper实现了.</p>
<h3 id="Looper的实现"><a href="#Looper的实现" class="headerlink" title="Looper的实现"></a>Looper的实现</h3><p>  上面看Handler得源码发现,其内部的消息队列指向的是Looper的内部的消息队列,那可以断定这个消息队列是由looper来维护的,同时由于每个线程都有一个唯一的线程队列,这个是怎么实现呢,可以马上想到之前我们学习过的 <em>ThreadLocal</em> 每个线程都拥有自己唯一的变量对象.这里就是 <em>ThreadLocal</em> 的典型实现场景了.</p>
<p>  可以看到Looper的构造函数是私有的,外面只能通过调用 <em>myLooper</em> 方法来获取到当前线程中的Looper对象.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div></pre></td></tr></table></figure>
<p>  刚才说了Handler在发送之前必须得能通过 <em>myLooper</em> 方法获取到looper对象.但是这里的sThreadLocal并没有实现 <em>initialValue</em> 方法,所以必须得外部调用一个方法来给ThreadLocal赋值,这里使用的是 <em>prepare</em> 方法.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">      prepare(<span class="keyword">true</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">      &#125;</div><div class="line">      sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  通过 <em>prepare</em> 方法,就可以是当前线程中的looper对象不为空了,同时handler就可以来发送消息了.so,可以看到在创建Handler之前的必备步骤必须先得调用一下Looper.prepare()方法,这样才能正常运行.<br>  这个时候有人可能会说,为啥在activity的使用过程中,我们并没有显式的调用 <em>Looper.prepare()</em> 方法呢,其实是activity在创建的时候已经在底层帮我们调用过了,这样朱祥成中的looper对象就不为空,我们就可以随便创建新的Handler而不用担心looper为空了.</p>
<p>  looper为主线程的looper提供了直接调用方法:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">     prepare(<span class="keyword">false</span>);</div><div class="line">     <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">         <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">         &#125;</div><div class="line">         sMainLooper = myLooper();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  这个方法就是用来给UI主线程来生成唯一的looper的.我们平时经常通 <em>Looper.myLooper() == Looper.getMainLooper()</em> 来判断当前是不是在UI主线程中就是这个道理.<br>  looper的初始化完成后,怎么才能让消息队列的消息出列呢.这里是通过调用 <em>loop</em> 方法来完成的<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">     <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">     <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">     Binder.clearCallingIdentity();</div><div class="line">     <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">     <span class="keyword">for</span> (;;) &#123;</div><div class="line">         Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">         <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">         Printer logging = me.mLogging;</div><div class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">             logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                     msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">             logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">         <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">         <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">         <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">             Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                     + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                     + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                     + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                     + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         msg.recycleUnchecked();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  这里去掉无用信息之后,实际上就是调用了消息队列的 <em>next</em> 方法,如果取到新的消息对象,就交给消息对象的target也就是handler来处理.同时也看到在注释写到消息队列的next方法可能会阻塞.回到了handler的 <em>dispatchMessage</em> 方法中了</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">       message.callback.run();</div><div class="line">   &#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* Subclasses must implement this to receive messages.</div><div class="line">*/</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>  这里可以看到,如果是post的时候,调用callBack,如果是sendMessage的话直接调用handleMessage,这个方法是个空方法,是交给我们自己根据需求去实现的.</p>
<p>  这里其实一直有一个疑问,就是明明在线程中调用Handler的post方法,传入一个线程对象,为啥就说这玩意是在主线程中运行的呢?明明代码都在线程里面的,要运行也应该是在子线程中运行,为啥大家都说是在主线程中运行?<br>  今天才明白了,一直忽略了一个细节,就是上面的 <em>handleCallback</em> 的内部实现,细细看它里面内部调用的居然是callback的 <em>run</em> 方法,而不是咱们一直使用的 <em>start</em> 方法,二者唯一的区别就是start是新开一个线程来执行run方法中的代码,而run方法是直接在当前线程中执行run方法中的代码,这是二者的不同之处,so,这里其实是在主线程中直接执行了run方法中的代码,那个子线程根本就没有运行,相当于一个普通的对象.</p>
<p>  到这里looper的功能就讲完了,可以看到looper就是不断的从消息队列中取消息的作用.<br>  下面我们进入消息队列的具体实现,来重点看一下两个方法 <em>enqueueMessage</em> , <em>next</em>:</p>
<h3 id="MessageQueue的实现"><a href="#MessageQueue的实现" class="headerlink" title="MessageQueue的实现"></a>MessageQueue的实现</h3><p>  先来看 <em>enqueueMessage</em> 的实现:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></div><div class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></div><div class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></div><div class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">        <span class="keyword">if</span> (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  可以很明显的看出消息队列实际上是一个单向链表的实现.这里的全局变量 <em>mMessages</em> 代表着初始的头结点,如果刚开始列表为空的话就把当前的入队的message作为头结点,如果不为空的话就遍历整个列表直到找到触发时间(when)小于当前的message的消息,把message插入他的后面.</p>
<p>  这里的needWake变量是用来处理如果是异步任务的时候来h唤醒队列用的,平时我们用不到,这里不深入讲了</p>
<p>  下面再来看下 <em>next</em> 方法是如何阻塞线程的:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// Return here if the message loop has already quit and been disposed.</span></div><div class="line">      <span class="comment">// This can happen if the application tries to restart a looper after quit</span></div><div class="line">      <span class="comment">// which is not supported.</span></div><div class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">      <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">      <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">      <span class="keyword">for</span> (;;) &#123;</div><div class="line">          <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">              Binder.flushPendingCommands();</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">              <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">              Message prevMsg = <span class="keyword">null</span>;</div><div class="line">              Message msg = mMessages;</div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class="line">                  <span class="keyword">do</span> &#123;</div><div class="line">                      prevMsg = msg;</div><div class="line">                      msg = msg.next;</div><div class="line">                  &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                      <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">                      nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                      <span class="comment">// Got a message.</span></div><div class="line">                      mBlocked = <span class="keyword">false</span>;</div><div class="line">                      <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                          prevMsg.next = msg.next;</div><div class="line">                      &#125; <span class="keyword">else</span> &#123;</div><div class="line">                          mMessages = msg.next;</div><div class="line">                      &#125;</div><div class="line">                      msg.next = <span class="keyword">null</span>;</div><div class="line">                      <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                      msg.markInUse();</div><div class="line">                      <span class="keyword">return</span> msg;</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">// No more messages.</span></div><div class="line">                  nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// Process the quit message now that all pending messages have been handled.</span></div><div class="line">              <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                  dispose();</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// If first time idle, then get the number of idlers to run.</span></div><div class="line">              <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></div><div class="line">              <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                      &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                  pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">                  mBlocked = <span class="keyword">true</span>;</div><div class="line">                  <span class="keyword">continue</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">                  mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">              &#125;</div><div class="line">              mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">// Run the idle handlers.</span></div><div class="line">          <span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">              <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">              mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">              <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  keep = idler.queueIdle();</div><div class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                  Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (!keep) &#123;</div><div class="line">                  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                      mIdleHandlers.remove(idler);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">          pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">          <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">          <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">          nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  可以看到这里已经来就弄出一个死循环来,就是这么的霸气,通过这个循环来不断从链表中获取头结点的message对象,for循环开始有一个 <em>nativePollOnce</em><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nativePollOnce(ptr, nextPollTimeoutMillis);</div></pre></td></tr></table></figure></p>
<p>  这个方法是一个native方法,作用就是在指定的时间内唤醒ptr,也就是消息队列的内存地址.</p>
<p>  那这个参数 <em>nextPollTimeoutMillis</em> 就很是关键点了.如果头结点不为空的话,判断一下当前事件是不是小于message的when,如果小于说明还没有到消息出列的时候,把 <em>nextPollTimeoutMillis</em> 调整为二者的差值,等待下次的唤醒.如果时间正好,就把头结点返回,链表前移.<br>  有点像你定了6点闹钟上班,5点半醒了发现没到点就继续睡半小时的,等到了6点闹钟响了你就起床上班了.差不多就是这个意思.</p>
<p>  核心逻辑走完之后地下出现了一个 <em>IdleHandler</em> 数组,并调用了 <em>queueIdle</em> 这个东西的作用就是用来在消息队列空闲的时候执行一些额外的工作.比如GC说明的,你可以根据需要调用消息队列的 <em>addIdleHandler</em><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(@NonNull IdleHandler handler)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Can't add a null IdleHandler"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">         mIdleHandlers.add(handler);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIdleHandler</span><span class="params">(@NonNull IdleHandler handler)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            mIdleHandlers.remove(handler);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  最后的最后我们可以看到在 <em>next</em> 方法中判断如果message的target为空的时候的处理.那什么情况下message的target为空的,是在消息队列中的 <em>postSyncBarrier</em><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">      <span class="comment">// Enqueue a new sync barrier token.</span></div><div class="line">      <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></div><div class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">          <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</div><div class="line">          <span class="keyword">final</span> Message msg = Message.obtain();</div><div class="line">          msg.markInUse();</div><div class="line">          msg.when = when;</div><div class="line">          msg.arg1 = token;</div><div class="line"></div><div class="line">          Message prev = <span class="keyword">null</span>;</div><div class="line">          Message p = mMessages;</div><div class="line">          <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</div><div class="line">              <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</div><div class="line">                  prev = p;</div><div class="line">                  p = p.next;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></div><div class="line">              msg.next = p;</div><div class="line">              prev.next = msg;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              msg.next = p;</div><div class="line">              mMessages = msg;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> token;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  这个barrier的作用翻译过来叫栅栏,也就是用来阻隔消息继续发送的.如果你调用了 <em>postSyncBarrier</em> 那这个时间点之后的同步消息都不会执行了,除非了你把它移除掉,调用 <em>removeSyncBarrier</em> .这里不包括异步消息,异步消息还是可以继续执行的.我们平时调用的都是同步消息,异步消息应该是系统内部使用的.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</div><div class="line">     <span class="comment">// Remove a sync barrier token from the queue.</span></div><div class="line">     <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></div><div class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">         Message prev = <span class="keyword">null</span>;</div><div class="line">         Message p = mMessages;</div><div class="line">         <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</div><div class="line">             prev = p;</div><div class="line">             p = p.next;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></div><div class="line">                     + <span class="string">" barrier token has not been posted or has already been removed."</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</div><div class="line">         <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">             prev.next = p.next;</div><div class="line">             needWake = <span class="keyword">false</span>;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             mMessages = p.next;</div><div class="line">             needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</div><div class="line">         &#125;</div><div class="line">         p.recycleUnchecked();</div><div class="line"></div><div class="line">         <span class="comment">// If the loop is quitting then it is already awake.</span></div><div class="line">         <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></div><div class="line">         <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</div><div class="line">             nativeWake(mPtr);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  消息队列的大概流程就讲完了,最后我们来看下Message对象的内部实现:</p>
<h3 id="Message源码"><a href="#Message源码" class="headerlink" title="Message源码"></a>Message源码</h3><p>  可以看到在Message中提供了一系列的obtain方法来用来初始赋值,这里有个简单对象池的实现,值得我们注意下:</p>
<p>  在上面的looper的loop方法中,当取出message之后并交给message的target执行完成后,后面有一句 <em>msg.recycleUnchecked();</em> 用来回收message对象<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></div><div class="line">    <span class="comment">// Clear out all other details.</span></div><div class="line">    flags = FLAG_IN_USE;</div><div class="line">    what = <span class="number">0</span>;</div><div class="line">    arg1 = <span class="number">0</span>;</div><div class="line">    arg2 = <span class="number">0</span>;</div><div class="line">    obj = <span class="keyword">null</span>;</div><div class="line">    replyTo = <span class="keyword">null</span>;</div><div class="line">    sendingUid = -<span class="number">1</span>;</div><div class="line">    when = <span class="number">0</span>;</div><div class="line">    target = <span class="keyword">null</span>;</div><div class="line">    callback = <span class="keyword">null</span>;</div><div class="line">    data = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">            next = sPool;</div><div class="line">            sPool = <span class="keyword">this</span>;</div><div class="line">            sPoolSize++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  可以看到这里把用完的对象清空属性之后赋给了sPool,达到了回收的目的.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">         <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</div><div class="line">             Message m = sPool;</div><div class="line">             sPool = m.next;</div><div class="line">             m.next = <span class="keyword">null</span>;</div><div class="line">             m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></div><div class="line">             sPoolSize--;</div><div class="line">             <span class="keyword">return</span> m;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Message();</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  可以看到在obtain的时候优先从sPool中获取是否有么有使用的Message对象,如果有的话就直接使用了,没有的时候才创建新的Message对象.所以为了节约内存,最好还是使用obtain方法.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看了下Handler,Looper,MessageQueue的源码感觉难点是在 MessageQueue的内部 <em>next</em> 方法中,里面有一些底层native的东西,自己不是很了解,耽搁了点时间来消化.至于Handler和Looper上层实现还是比较简单的.那么,handler的讲解就到这里.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://hjdzone.gitbooks.io/thinkandroid/content/ThreadMessage/Chapter_1_6.html" title="MessageQueue源码分析" target="_blank" rel="external">MessageQueue源码分析</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/01/04/2017/java线程池源码分析/" class="prev">PREV</a><a href="/2017/01/01/2017/android universal image loader源码分析/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://pheobusyy.github.io">yanyi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>