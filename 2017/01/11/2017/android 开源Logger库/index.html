<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">android 开源Logger库</h1><h2 class="subtitle">2017-01-11</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#android-开源Logger库"><span class="toc-number">1.</span> <span class="toc-text">android 开源Logger库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#需要明白的问题"><span class="toc-number">1.1.</span> <span class="toc-text">需要明白的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主要代码分析"><span class="toc-number">1.2.</span> <span class="toc-text">主要代码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">1.3.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div><div class="post-text"><h2 id="android-开源Logger库"><a href="#android-开源Logger库" class="headerlink" title="android 开源Logger库"></a>android 开源Logger库</h2><h3 id="需要明白的问题"><a href="#需要明白的问题" class="headerlink" title="需要明白的问题"></a>需要明白的问题</h3><ol>
<li><p>如何打印当前线程的名称的<br>直接Thread.currentThread.getName调用的</p>
</li>
<li><p>如何打印调用方法的名称和行数的<br>通过StackTraceElement来获取到引用的数组</p>
</li>
<li><p>StackTraceElement的概念<br>StackTraceElement是java1.5新增的用来输出方法调用栈信息的对象,通过它我们可以打印出当前线程中方法的调用栈,从里面可以可以获取到方法名称,行数,类名称等我们想要的信息</p>
</li>
<li><p>如何增加分割线的和边框的<br>为了把打印日志用方框圈起来,这里把整个日志分成了两部分,顶部叫header+剩下的我们真正需要的信息.<br>header又包含了当前顶部分割线,线程名称,方法调用栈信息<br>最后再把底部分割线加上,正好组合成一个方框,这个方框是没有右边的,因为分割线都是顶满整行的</p>
</li>
<li><p>如何保证打印日志没有超过最大字符个数限制<br>由于原生api的单次打印最大字符限制是4M,所以判断如果要打印的字符串超过4M就把字符串拆开成多段来分别打印</p>
</li>
<li><p>如何处理JSON数据<br>JSONObject原生api居然提供了一个带缩进的toString方法….<br>同时Arrays居然也提供了一个deepToString的方法…..</p>
</li>
<li><p>如何处理XML<br>通过java提供的Transformer API来打印XML</p>
</li>
</ol>
<h3 id="主要代码分析"><a href="#主要代码分析" class="headerlink" title="主要代码分析"></a>主要代码分析</h3><p>其他的方法都非常简单,核心方法就是下面这个log方法:</p>
<pre><code class="java">@Override public synchronized void log(int priority, String tag, String message, Throwable throwable) {
   if (settings.getLogLevel() == LogLevel.NONE) {
     return;
   }
   if (throwable != null &amp;&amp; message != null) {
     message += &quot; : &quot; + Helper.getStackTraceString(throwable);
   }
   if (throwable != null &amp;&amp; message == null) {
     message = Helper.getStackTraceString(throwable);
   }
   if (message == null) {
     message = &quot;No message/exception is set&quot;;
   }
   int methodCount = getMethodCount();
   if (Helper.isEmpty(message)) {
     message = &quot;Empty/NULL log message&quot;;
   }

   logTopBorder(priority, tag);
   logHeaderContent(priority, tag, methodCount);

   //get bytes of message with system&#39;s default charset (which is UTF-8 for Android)
   byte[] bytes = message.getBytes();
   int length = bytes.length;
   if (length &lt;= CHUNK_SIZE) {
     if (methodCount &gt; 0) {
       logDivider(priority, tag);
     }
     logContent(priority, tag, message);
     logBottomBorder(priority, tag);
     return;
   }
   if (methodCount &gt; 0) {
     logDivider(priority, tag);
   }
   for (int i = 0; i &lt; length; i += CHUNK_SIZE) {
     int count = Math.min(length - i, CHUNK_SIZE);
     //create a new String with system&#39;s default charset (which is UTF-8 for Android)
     logContent(priority, tag, new String(bytes, i, count));
   }
   logBottomBorder(priority, tag);
 }
</code></pre>
<p>注意,这里加锁来保证数据顺序的正确性<br>通过 <em>logHeaderContent(priority, tag, methodCount);</em> 来打印线程信息和方法调用栈信息.</p>
<pre><code class="java">private void logHeaderContent(int logType, String tag, int methodCount) {
   StackTraceElement[] trace = Thread.currentThread().getStackTrace();
   if (settings.isShowThreadInfo()) {
     logChunk(logType, tag, HORIZONTAL_DOUBLE_LINE + &quot; Thread: &quot; + Thread.currentThread().getName());
     logDivider(logType, tag);
   }
   String level = &quot;&quot;;

   int stackOffset = getStackOffset(trace) + settings.getMethodOffset();

   //corresponding method count with the current stack may exceeds the stack trace. Trims the count
   if (methodCount + stackOffset &gt; trace.length) {
     methodCount = trace.length - stackOffset - 1;
   }

   for (int i = methodCount; i &gt; 0; i--) {
     int stackIndex = i + stackOffset;
     if (stackIndex &gt;= trace.length) {
       continue;
     }
     StringBuilder builder = new StringBuilder();
     builder.append(&quot;║ &quot;)
         .append(level)
         .append(getSimpleClassName(trace[stackIndex].getClassName()))
         .append(&quot;.&quot;)
         .append(trace[stackIndex].getMethodName())
         .append(&quot; &quot;)
         .append(&quot; (&quot;)
         .append(trace[stackIndex].getFileName())
         .append(&quot;:&quot;)
         .append(trace[stackIndex].getLineNumber())
         .append(&quot;)&quot;);
     level += &quot;   &quot;;
     logChunk(logType, tag, builder.toString());
   }
 }
</code></pre>
<p>获取到调用栈信息,从第三个开始获取,因为前两个都是系统的调用信息,忽略不计,从第三个开始真正的方法调用的.再加上设置里面要求打印的方法个数,组成了要打印的方法的最终个数.</p>
<pre><code class="java">private int getStackOffset(StackTraceElement[] trace) {
   for (int i = MIN_STACK_OFFSET; i &lt; trace.length; i++) {
     StackTraceElement e = trace[i];
     String name = e.getClassName();
     if (!name.equals(LoggerPrinter.class.getName()) &amp;&amp; !name.equals(Logger.class.getName())) {
       return --i;
     }
   }
   return -1;
 }
</code></pre>
<p>剩下的打印主要信息的时候做个容量判断,如果没超过原声API的最大字符串限制直接打印,如果超了就拆成几段分别打印.</p>
<pre><code class="java">byte[] bytes = message.getBytes();
   int length = bytes.length;
   if (length &lt;= CHUNK_SIZE) {
     if (methodCount &gt; 0) {
       logDivider(priority, tag);
     }
     logContent(priority, tag, message);
     logBottomBorder(priority, tag);
     return;
   }
   if (methodCount &gt; 0) {
     logDivider(priority, tag);
   }
   for (int i = 0; i &lt; length; i += CHUNK_SIZE) {
     int count = Math.min(length - i, CHUNK_SIZE);
     //create a new String with system&#39;s default charset (which is UTF-8 for Android)
     logContent(priority, tag, new String(bytes, i, count));
   }
   logBottomBorder(priority, tag)
</code></pre>
<p>非常的简单.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/orhanobut/logger" title="logger github" target="_blank" rel="external">logger github</a></p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>