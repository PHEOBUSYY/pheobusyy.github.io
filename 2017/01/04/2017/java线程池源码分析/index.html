<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">java线程池源码分析</h1><h2 class="subtitle">2017-01-04</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java线程池源码分析"><span class="toc-number">1.</span> <span class="toc-text">java线程池源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor接口"><span class="toc-number">1.1.</span> <span class="toc-text">Executor接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExecutorService接口方法"><span class="toc-number">1.2.</span> <span class="toc-text">ExecutorService接口方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunnableFuture-接口"><span class="toc-number">1.3.</span> <span class="toc-text">RunnableFuture 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-和-FutureTask"><span class="toc-number">1.4.</span> <span class="toc-text">Future 和 FutureTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">1.5.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newFixedThreadPool-newSingleThreadExecutor-newCachedThreadPool-newScheduledThreadPool-四种类型的区别"><span class="toc-number">1.6.</span> <span class="toc-text">newFixedThreadPool,newSingleThreadExecutor,newCachedThreadPool,newScheduledThreadPool 四种类型的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable和Runnable"><span class="toc-number">1.7.</span> <span class="toc-text">Callable和Runnable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">1.9.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div><div class="post-text"><h2 id="java线程池源码分析"><a href="#java线程池源码分析" class="headerlink" title="java线程池源码分析"></a>java线程池源码分析</h2><h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><pre><code class="java">public interface Executor {
    void execute(Runnable command);
}
</code></pre>
<p>线程池的基础接口</p>
<h3 id="ExecutorService接口方法"><a href="#ExecutorService接口方法" class="headerlink" title="ExecutorService接口方法"></a>ExecutorService接口方法</h3><pre><code class="java">public interface ExecutorService extends Executor {


    void shutdown();


    List&lt;Runnable&gt; shutdownNow();


    boolean isShutdown();


    boolean isTerminated();


    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;


    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);


    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);


    Future&lt;?&gt; submit(Runnable task);


    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        throws InterruptedException;

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        throws InterruptedException, ExecutionException;


    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>
<p>线程池相关操作的定义接口</p>
<h3 id="RunnableFuture-接口"><a href="#RunnableFuture-接口" class="headerlink" title="RunnableFuture 接口"></a>RunnableFuture 接口</h3><pre><code class="java">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
</code></pre>
<p>通过适配器把两个不相关的对象组合在一起了.</p>
<h3 id="Future-和-FutureTask"><a href="#Future-和-FutureTask" class="headerlink" title="Future 和 FutureTask"></a>Future 和 FutureTask</h3><pre><code class="java">public interface Future&lt;V&gt; {


    boolean cancel(boolean mayInterruptIfRunning);


    boolean isCancelled();

    boolean isDone();


    V get() throws InterruptedException, ExecutionException;


    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>
<p>FutureTask是实现返回值的关键类,里面的核心方法就是 <em>get</em> 方法,下面来看一下具体实现:</p>
<pre><code class="java">public V get() throws InterruptedException, ExecutionException {
       int s = state;
       if (s &lt;= COMPLETING)
           s = awaitDone(false, 0L);
       return report(s);
   }

   /**
    * @throws CancellationException {@inheritDoc}
    */
   public V get(long timeout, TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
       if (unit == null)
           throw new NullPointerException();
       int s = state;
       if (s &lt;= COMPLETING &amp;&amp;
           (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)
           throw new TimeoutException();
       return report(s);
   }
</code></pre>
<p>很明显的就是通过state的状态来判断是否需要返回结果,还没有完成就进入 <em>awaitDone</em> ,目的是为了在结果没有返回的时候阻塞等待.</p>
<pre><code class="java">private int awaitDone(boolean timed, long nanos)
       throws InterruptedException {
       // The code below is very delicate, to achieve these goals:
       // - call nanoTime exactly once for each call to park
       // - if nanos &lt;= 0, return promptly without allocation or nanoTime
       // - if nanos == Long.MIN_VALUE, don&#39;t underflow
       // - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic
       //   and we suffer a spurious wakeup, we will do no worse than
       //   to park-spin for a while
       long startTime = 0L;    // Special value 0L means not yet parked
       WaitNode q = null;
       boolean queued = false;
       for (;;) {
           int s = state;
           if (s &gt; COMPLETING) {
               if (q != null)
                   q.thread = null;
               return s;
           }
           else if (s == COMPLETING)
               // We may have already promised (via isDone) that we are done
               // so never return empty-handed or throw InterruptedException
               Thread.yield();
           else if (Thread.interrupted()) {
               removeWaiter(q);
               throw new InterruptedException();
           }
           else if (q == null) {
               if (timed &amp;&amp; nanos &lt;= 0L)
                   return s;
               q = new WaitNode();
           }
           else if (!queued)
               queued = U.compareAndSwapObject(this, WAITERS,
                                               q.next = waiters, q);
           else if (timed) {
               final long parkNanos;
               if (startTime == 0L) { // first time
                   startTime = System.nanoTime();
                   if (startTime == 0L)
                       startTime = 1L;
                   parkNanos = nanos;
               } else {
                   long elapsed = System.nanoTime() - startTime;
                   if (elapsed &gt;= nanos) {
                       removeWaiter(q);
                       return state;
                   }
                   parkNanos = nanos - elapsed;
               }
               // nanoTime may be slow; recheck before parking
               if (state &lt; COMPLETING)
                   LockSupport.parkNanos(this, parkNanos);
           }
           else
               LockSupport.park(this);
       }
   }
</code></pre>
<p>具体的细节就不说了,最终就是如果状态是运行中的话就阻塞线程等待,直到那边run方法执行完成之后,修改线程状态:</p>
<pre><code class="java">public void run() {
      if (state != NEW ||
          !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))
          return;
      try {
          Callable&lt;V&gt; c = callable;
          if (c != null &amp;&amp; state == NEW) {
              V result;
              boolean ran;
              try {
                  result = c.call();
                  ran = true;
              } catch (Throwable ex) {
                  result = null;
                  ran = false;
                  setException(ex);
              }
              if (ran)
                  set(result);
          }
      } finally {
          // runner must be non-null until state is settled to
          // prevent concurrent calls to run()
          runner = null;
          // state must be re-read after nulling runner to prevent
          // leaked interrupts
          int s = state;
          if (s &gt;= INTERRUPTING)
              handlePossibleCancellationInterrupt(s);
      }
  }
</code></pre>
<p>执行完成之后进入set(result):</p>
<pre><code class="java">protected void set(V v) {
       if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) {
           outcome = v;
           U.putOrderedInt(this, STATE, NORMAL); // final state
           finishCompletion();
       }
   }
</code></pre>
<pre><code class="java">private void finishCompletion() {
      // assert state &gt; COMPLETING;
      for (WaitNode q; (q = waiters) != null;) {
          if (U.compareAndSwapObject(this, WAITERS, q, null)) {
              for (;;) {
                  Thread t = q.thread;
                  if (t != null) {
                      q.thread = null;
                      LockSupport.unpark(t);
                  }
                  WaitNode next = q.next;
                  if (next == null)
                      break;
                  q.next = null; // unlink to help gc
                  q = next;
              }
              break;
          }
      }

      done();

      callable = null;        // to reduce footprint
  }
</code></pre>
<p>在这里唤醒线程,通知get方法,已经完成处理了,可以获取返回值了.</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>ThreadPoolExecutor中的一个难点是在如何通过一个int值来代表两个作用,一个是线程池状态,一个是线程池运行任务的个数.</p>
<pre><code class="java">   private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
   private static final int COUNT_BITS = Integer.SIZE - 3;
   private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

   // runState is stored in the high-order bits
   private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
   private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
   private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
   private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
   private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

   // Packing and unpacking ctl
   private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
   private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
   private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>
<p>把一个int值的高位3为作为线程池的状态,后面的29位作为线程池的任务个数.<br>这里的 <em>COUNT_BITS</em> 是29,那么 <em>CAPACITY</em> 就是 00011111111111111111111111111111 ,这样 <em>~CAPACITY</em> 为 11100000000000000000000000000000,这样通过与操作就可以分别处理两个属性了.非常的巧妙.</p>
<p>然后要明白两个重要的属性 <em>corePoolSize</em> 和 <em>maximumPoolSize</em> . corePoolSize是用来表示当前允许运行的最小任务个数,也叫核心任务数.maximumPoolSize是指线程池运行运行的最大任务数.</p>
<p>正常情况下,如果没有满足 corePoolSize 的话就创建新的 <em>worker</em> 然后执行,如果超过了 corePoolSize 的话一般是进入阻塞队列中等待.如果连阻塞队列都满了的话,尝试在创建新的线程来执行任务,前提是运行的任务数不能超过最大的任务数,也就是 maximumPoolSize .这就是两个size的作用.4中不同的线程池类型的区别主要就在这两个参数上面.<br>举个例子,比如现在总共有12个任务, corePoolSize 为2,阻塞队列容量为5,最大线程数 maximumPoolSize为10,那首先会优先满足corePoolSize ,1号,2号运行,然后剩下的5个也就是,3,4,5,6,7进入阻塞队列,然后8,9,10号创建新线程来执行填满最大线程数,还剩下的11,12就不予执行了.</p>
<p>上面的这个流程就是线程池的核心流程原理,下面来看具体的代码实现:<br>ThreadPoolExecutor调用任务有两个方法一个是submit,一个是execute,二者的唯一区别就是submit有返回值,但是内部都是调用了execute方法.</p>
<pre><code class="java">public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
       if (task == null) throw new NullPointerException();
       RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);
       execute(ftask);
       return ftask;
   }


   public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
       if (task == null) throw new NullPointerException();
       RunnableFuture&lt;T&gt; ftask = newTaskFor(task);
       execute(ftask);
       return ftask;
   }
</code></pre>
<p>这里传入的就是FutureTask对象啦,FutureTask的细节前面已经说过了,先看 <em>execute</em> 方法的实现:</p>
<pre><code class="java">public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn&#39;t, by returning false.
         *
         * 如果要执行的任务数量小于corePoolSize,直接通过调用addWorker方法来执行任务.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 如果线程池处于运行状态并且任务成功的进入阻塞队列,二次检查线程池的状态,如果状态变为非运行的时候,尝试回退任务
         * 如果运行中的任务个数为0,运行一个空的任务到addWorker
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         * 如果不能入列,那尝试直接通过addWorker运行任务,如果失败说明线程池已经停止了或者已经满了,拒绝任务
         */
        int c = ctl.get();
        if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
</code></pre>
<p>这里就对应上面的三种情况,核心任务数没满直接addWorker,如果满了就放入阻塞队列中,如果阻塞队列也满了尝试直接运行,那如何运行任务就进入addWorker方法了.</p>
<pre><code class="java">private boolean addWorker(Runnable firstTask, boolean core) {
      /**
      * 通过一个循环标示来控制一个两层的死循环
      * 首先是判断线程池的状态,如果是停止或以上的状态直接返回false
      * 另外就是前面的 *execute* 方法的传入的 *addWorker(null, false);* 这种情况下说明阻塞队列还有任务没有执行完成,所以要继续把阻塞队列里面的任务执行完才可以,这种情况就会进入底下的第二个循环里面.
      * 第二个循环直接更改运行的线程数,如果成功就跳出循环,如果超出最大限制就返回false
      * 如果发现线程池的状态变化了就重新更新一下
      */
       retry:
       for (;;) {
           int c = ctl.get();
           int rs = runStateOf(c);

           // Check if queue empty only if necessary.
           if (rs &gt;= SHUTDOWN &amp;&amp;
               ! (rs == SHUTDOWN &amp;&amp;
                  firstTask == null &amp;&amp;
                  ! workQueue.isEmpty()))
               return false;

           for (;;) {
               int wc = workerCountOf(c);
               if (wc &gt;= CAPACITY ||
                   wc &gt;= (core ? corePoolSize : maximumPoolSize))
                   return false;
               if (compareAndIncrementWorkerCount(c))
                   break retry;
               c = ctl.get();  // Re-read ctl
               if (runStateOf(c) != rs)
                   continue retry;
               // else CAS failed due to workerCount change; retry inner loop
           }
       }
        /**
        * 如果进入这里说明任务可以执行了
        */
       boolean workerStarted = false;
       boolean workerAdded = false;
       Worker w = null;
       try {
          //包装一个worker对象
           w = new Worker(firstTask);
           //这里的Thread是通过线程池构造函数的ThreadFactory来创建出来的,这里的线程就是worker对象用来执行任务的线程对象,这个对象会陪伴着worker从生到死,不断的执行任务,如果阻塞队列中没有任务的时候,它会阻塞挂起,除非设置了keepAliveTime参数.
           final Thread t = w.thread;
           if (t != null) {
               final ReentrantLock mainLock = this.mainLock;
               mainLock.lock();
               try {
                   // Recheck while holding lock.
                   // Back out on ThreadFactory failure or if
                   // shut down before lock acquired.
                   int rs = runStateOf(ctl.get());
                    //运行态或者停止之后但是阻塞队列还有任务没有完成,设置workerAdded true
                   if (rs &lt; SHUTDOWN ||
                       (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                       if (t.isAlive()) // precheck that t is startable
                           throw new IllegalThreadStateException();
                       workers.add(w);
                       int s = workers.size();
                       //设置当前最大的运行任务数
                       if (s &gt; largestPoolSize)
                           largestPoolSize = s;
                       workerAdded = true;
                   }
               } finally {
                   mainLock.unlock();
               }
               if (workerAdded) {
                 //这里调用worker线程的start方法,最后进入了 *runWorker* 方法
                   t.start();
                   workerStarted = true;
               }
           }
       } finally {
           if (! workerStarted)
               addWorkerFailed(w);
       }
       return workerStarted;
   }
</code></pre>
<p>当调用worker的中线程的start方法实际上进入了runWorker方法中,先看下work对象的实现:</p>
<pre><code class="java">private final class Worker
      extends AbstractQueuedSynchronizer
      implements Runnable
  {
      /**
       * This class will never be serialized, but we provide a
       * serialVersionUID to suppress a javac warning.
       */
      private static final long serialVersionUID = 6138294804551838833L;

      /** Thread this worker is running in.  Null if factory fails. */
      final Thread thread;
      /** Initial task to run.  Possibly null. */
      Runnable firstTask;
      /** Per-thread task counter */
      volatile long completedTasks;

      /**
       * Creates with given first task and thread from ThreadFactory.
       * @param firstTask the first task (null if none)
       */
      Worker(Runnable firstTask) {
          setState(-1); // inhibit interrupts until runWorker
          this.firstTask = firstTask;
          this.thread = getThreadFactory().newThread(this);
      }

      /** Delegates main run loop to outer runWorker. */
      public void run() {
          runWorker(this);
      }

      // Lock methods
      //
      // The value 0 represents the unlocked state.
      // The value 1 represents the locked state.

      protected boolean isHeldExclusively() {
          return getState() != 0;
      }

      protected boolean tryAcquire(int unused) {
          if (compareAndSetState(0, 1)) {
              setExclusiveOwnerThread(Thread.currentThread());
              return true;
          }
          return false;
      }

      protected boolean tryRelease(int unused) {
          setExclusiveOwnerThread(null);
          setState(0);
          return true;
      }

      public void lock()        { acquire(1); }
      public boolean tryLock()  { return tryAcquire(1); }
      public void unlock()      { release(1); }
      public boolean isLocked() { return isHeldExclusively(); }

      void interruptIfStarted() {
          Thread t;
          if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {
              try {
                  t.interrupt();
              } catch (SecurityException ignore) {
              }
          }
      }
  }
</code></pre>
<p>worker是一个AQS的简单实现,其中要注意的就是它的构造函数,首先通过setState(-1)来把对象锁定,防止中断操作,然后就是thread对象,这里是通过ThreadFactory的newThread来创建出来的新线程,这个线程用来调用传入线程池的任务,相当于任务的载体.这个Thread对象就是worker用来执行任务的环境了,它会和worker一起丛生到死.</p>
<p>线程池是是如何减少了线程的创建的呢?<br>比如我有100个任务,那你直接调用100个任务的start方法相当于创建了100个线程对不对.而交给线程池却不会傻傻的创建100个线程对象,它会创建你设置的 <em>corePoolSize</em> 个worker对象,在worker对象的Thread中来执行任务代码,也就是说每个worker对象不仅仅只是运行一个任务就完了,它会不断的运行任务,从阻塞队列中不断的去取任务,直到没有任务给它处理为止.这个时候它会阻塞,一直等着阻塞队列有数据进来.</p>
<p>注意这里说的worker对象不止执行一个任务是理解线程池的关键.通过这样才能减少线程的创建和消耗,重点要理解worker是怎么处理任务的.下面我们来看runWorker方法的实现:</p>
<pre><code class="java">final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
          //这里getTask是从阻塞队列中取没有运行的任务,一直到阻塞队列中没有数据为止
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &amp;&amp;
                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                  //这个方法是个钩子函数
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                      //运行任务
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
</code></pre>
<p>这里就是调用任务的核心所在了,之所以有这么代码判断是为了处理线程池状态的变化的,比如正在运行任务的过程中,线程池调用了shutDown方法或者shutDownNow方法的时候,要协调这些任务的运行状态.<br>方法中while的判断,如果worker中的task为空的时候,就对应上面addWorker的时候线程池已经停止了,但是在阻塞队列中还是有任务,就得把阻塞队列中的任务取出来处理.这里就调用的是 <em>getTask</em> 方法,从阻塞队列中取任务.</p>
<pre><code class="java">private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;

            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
              //从阻塞队列中获取一个任务
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
</code></pre>
<p>这样就保证了只要worker活着它就会不断的从阻塞队列取数据并执行,这种阻塞了等待着执行任务的worker成为IdleWorker,也是在后面会被回收的worker对象.在每次执行完成任务之后来判断一下是不是需要回收闲置的worker对象.关键点就在这里的 <em>workQueue.poll</em> 和 <em>workQueue.take</em> ,poll支持超时,如果在指定的 <em>keepAliveTime</em> 的时间内,阻塞队列中还是没有数据,那么就返回null,如果是 <em>take</em> 的话,就会阻塞,等待有新的数据进入阻塞队列中.这个关键点是实现后面要讲的 <em>newCachedThreadPool</em> 关键所在.也就是在keepAliveTime的时间内,还是没有新的任务,那么这个worker对象就会被回收.<br>最后,如果是设置了keepAliveTime的话,超时没有取到数据,就会设置timedOut为true,再次进入上面的 <em>timed &amp;&amp; timedOut</em> 就会满足条件了,然后返回null,回到上面的runWoker的while循环并跳出,交给下面的 <em>processWorkerExit</em> 方法.</p>
<pre><code class="java">private void processWorkerExit(Worker w, boolean completedAbruptly) {
        if (completedAbruptly) // If abrupt, then workerCount wasn&#39;t adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }

        tryTerminate();

        int c = ctl.get();
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 &amp;&amp; ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) &gt;= min)
                    return; // replacement not needed
            }
            addWorker(null, false);
        }
    }
</code></pre>
<p>这里通过重入锁锁定之后修改workers集合的数据,把运行完成的worker移除.如果线程池还没到stop的状态,继续调用addWorker执行阻塞队列中的任务.同时还尝试结束线程池,再来看其中的 <em>tryTerminate</em> 方法:</p>
<pre><code class="java">final void tryTerminate() {
        for (;;) {
            int c = ctl.get();
            if (isRunning(c) ||
                runStateAtLeast(c, TIDYING) ||
                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))
                return;
            if (workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ONLY_ONE);
                return;
            }

            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                      //空方法,没有实现
                        terminated();
                    } finally {
                        ctl.set(ctlOf(TERMINATED, 0));
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }
</code></pre>
<p>如果现在状态是shutDown,但是阻塞队列中还是有任务就退出,不中止线程池.如果核心线程还是有在运行的时候,调用 <em>interruptIdleWorkers</em></p>
<pre><code class="java">private void interruptIdleWorkers(boolean onlyOne) {
      final ReentrantLock mainLock = this.mainLock;
      mainLock.lock();
      try {
          for (Worker w : workers) {
              Thread t = w.thread;
              if (!t.isInterrupted() &amp;&amp; w.tryLock()) {
                  try {
                      t.interrupt();
                  } catch (SecurityException ignore) {
                  } finally {
                      w.unlock();
                  }
              }
              if (onlyOne)
                  break;
          }
      } finally {
          mainLock.unlock();
      }
  }
</code></pre>
<p>如果是空闲线程,也就是没有任务在运行,所以可以获得锁,就把worker所在的线程中断.</p>
<p>到这里,就会引出两个中断方法的差异,shutDown和showDownNow的区别是:shutDown是中断之后,后续的加入的任务就无法直接运行了,已经在运行和阻塞队列中的还是会继续执行,而shutDownNow是直接中断全部的任务,不管是否在队列中,也不管是否在运行;</p>
<pre><code class="java">public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            advanceRunState(SHUTDOWN);
            interruptIdleWorkers();
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }
</code></pre>
<p>可以看到这里调用的是 <em>interruptIdleWorkers</em> 方法.</p>
<pre><code class="java">public List&lt;Runnable&gt; shutdownNow() {
       List&lt;Runnable&gt; tasks;
       final ReentrantLock mainLock = this.mainLock;
       mainLock.lock();
       try {
           checkShutdownAccess();
           advanceRunState(STOP);
           interruptWorkers();
           tasks = drainQueue();
       } finally {
           mainLock.unlock();
       }
       tryTerminate();
       return tasks;
   }
</code></pre>
<pre><code class="java">private void interruptWorkers() {
       final ReentrantLock mainLock = this.mainLock;
       mainLock.lock();
       try {
           for (Worker w : workers)
               w.interruptIfStarted();
       } finally {
           mainLock.unlock();
       }
   }
</code></pre>
<p>然后回到worker的内部interruptIfStarted:</p>
<pre><code class="java">void interruptIfStarted() {
           Thread t;
           if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {
               try {
                   t.interrupt();
               } catch (SecurityException ignore) {
               }
           }
       }
</code></pre>
<p>可以看到这里调用的 <em>interruptWorkers</em> 方法.这就是两个shutdown方法的区别所在.一个是中断空闲任务,一个是中断所有任务.</p>
<h3 id="newFixedThreadPool-newSingleThreadExecutor-newCachedThreadPool-newScheduledThreadPool-四种类型的区别"><a href="#newFixedThreadPool-newSingleThreadExecutor-newCachedThreadPool-newScheduledThreadPool-四种类型的区别" class="headerlink" title="newFixedThreadPool,newSingleThreadExecutor,newCachedThreadPool,newScheduledThreadPool 四种类型的区别"></a>newFixedThreadPool,newSingleThreadExecutor,newCachedThreadPool,newScheduledThreadPool 四种类型的区别</h3><p>这4种常用的线程池的创建都交给Executors来完成的,实际上就是创建了不同的ThreadPoolExecutor.</p>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) {
      return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;());
  }
</code></pre>
<p>可以看到核心任务数和最大任务数是一样的,那就是说线程池支持最多有 <em>nThreads</em> 个worker在运行,剩下的任务全部放入阻塞中,等待前面的任务完成后才取出来继续执行.</p>
<pre><code class="java">public static ExecutorService newSingleThreadExecutor() {
       return new FinalizableDelegatedExecutorService
           (new ThreadPoolExecutor(1, 1,
                                   0L, TimeUnit.MILLISECONDS,
                                   new LinkedBlockingQueue&lt;Runnable&gt;()));
   }
</code></pre>
<p>可以看到核心线程和最大线程数都是1,也就是说同一时间只能有一个任务执行,后续的任务挨个按顺序执行.</p>
<pre><code class="java">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue&lt;Runnable&gt;(),
                                    threadFactory);
  }
</code></pre>
<p>可以重复使用线程的线程池,直接把所有任务同时创建worker来运行,不管有多少个,同时由于设置了超时keepAliveTime,到了制定的时候就会回收空闲的worker对象,达到回收资源的目的.注意这里只是回收 <em>空闲</em> 的worker,正在运行的worker是不会回收的.</p>
<pre><code class="java">public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
    }
</code></pre>
<p>支持指定时间的任务的线程池,这里内部通过一个 <em>DelayedWorkQueue</em> 来完成定时操作,就不多做解释了.</p>
<h3 id="Callable和Runnable"><a href="#Callable和Runnable" class="headerlink" title="Callable和Runnable"></a>Callable和Runnable</h3><p>Callable是具有返回值的Runnable,这是两个区别.</p>
<pre><code class="java">public interface Callable&lt;V&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
</code></pre>
<pre><code class="java">public interface Runnable {

    /**
     * Starts executing the active part of the class&#39; code. This method is
     * called when a thread is started that has been created with a class which
     * implements {@code Runnable}.
     */
    public void run();
}
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程池的实现难点都在于 ThreadPoolExecutor 中,主要是对其中worker工作方式的理解,还有线程的运行和任务的运行的区别.这是关键,底层还是通过CAS来自旋判断线程的运行状态等属性变化,可以看到CAS是java多线程的核心基础.<br>刚开始完全不理解worker的实现,后来耐着性子看了好几遍别人的博客总于弄明白个大概,不得不说线程池的实现非常的巧妙.首先是一个int表示两个属性,然后是worker的实现思路来减少线程的创建消耗,对线程的理解更进一步.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/" title="Java线程池ThreadPoolExecutor源码分析" target="_blank" rel="external">Java线程池ThreadPoolExecutor源码分析</a></p>
<p><a href="http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor" title="Java并发包源码学习之线程池（一）ThreadPoolExecutor源码分析" target="_blank" rel="external">Java并发包源码学习之线程池（一）ThreadPoolExecutor源码分析</a></p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>