<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="欢迎来到JustinYan的个人blog" type="application/atom+xml" />






<meta name="description" content="android ButterKnife源码解析ButterKnife基本原理通过初次查看代码结构,发现原理大致和EventBus相同,通过定义不同的注解,然后通过注解分析器来生成新的源文件代码,在里面完成view的初始化和事件绑定,最后通过 ButterKnife.bind 方法来反射调用生成的新的源文件的中的初始化方法,来完成view的初始化和时间绑定.
可以这样理解,实际上以前是把findVi">
<meta property="og:type" content="article">
<meta property="og:title" content="android ButterKnife源码解析">
<meta property="og:url" content="http://pheobusyy.github.io/2017/01/16/2017/android ButterKnife源码解析/index.html">
<meta property="og:site_name" content="欢迎来到JustinYan的个人blog">
<meta property="og:description" content="android ButterKnife源码解析ButterKnife基本原理通过初次查看代码结构,发现原理大致和EventBus相同,通过定义不同的注解,然后通过注解分析器来生成新的源文件代码,在里面完成view的初始化和事件绑定,最后通过 ButterKnife.bind 方法来反射调用生成的新的源文件的中的初始化方法,来完成view的初始化和时间绑定.
可以这样理解,实际上以前是把findVi">
<meta property="og:updated_time" content="2017-02-25T01:12:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="android ButterKnife源码解析">
<meta name="twitter:description" content="android ButterKnife源码解析ButterKnife基本原理通过初次查看代码结构,发现原理大致和EventBus相同,通过定义不同的注解,然后通过注解分析器来生成新的源文件代码,在里面完成view的初始化和事件绑定,最后通过 ButterKnife.bind 方法来反射调用生成的新的源文件的中的初始化方法,来完成view的初始化和时间绑定.
可以这样理解,实际上以前是把findVi">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pheobusyy.github.io/2017/01/16/2017/android ButterKnife源码解析/"/>





  <title>android ButterKnife源码解析 | 欢迎来到JustinYan的个人blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">欢迎来到JustinYan的个人blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">永远不要因为你觉得某个目标无法实现就否决它-《原则》</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/16/2017/android ButterKnife源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">android ButterKnife源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-16T08:56:00+08:00">
                2017-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="android-ButterKnife源码解析"><a href="#android-ButterKnife源码解析" class="headerlink" title="android ButterKnife源码解析"></a>android ButterKnife源码解析</h2><h3 id="ButterKnife基本原理"><a href="#ButterKnife基本原理" class="headerlink" title="ButterKnife基本原理"></a>ButterKnife基本原理</h3><p>通过初次查看代码结构,发现原理大致和EventBus相同,通过定义不同的注解,然后通过注解分析器来生成新的源文件代码,在里面完成view的初始化和事件绑定,最后通过 <em>ButterKnife.bind</em> 方法来反射调用生成的新的源文件的中的初始化方法,来完成view的初始化和时间绑定.</p>
<p>可以这样理解,实际上以前是把findViewById等语句放在一个方法里面了,而这个方法在onCreate里面调用.现在是onCreate里面调用了 <em>ButterKnif.bind</em> 方法,里面还是findViewById那一套,只不过是通过注解分析器提前生成了源代码,里面是findViewById那些相关的声明语句.</p>
<p>注意,通过注解预编译这种方式可以达到在编译阶段来完成view的初始化和事件绑定,相对于反射是基本上没有性能消耗,所以是值得提倡的一种的技术方式.包括之前研究的Router也是通过这种方式来达到模块之间的相互调用的功能的.</p>
<h3 id="ButterKnife源代码分析"><a href="#ButterKnife源代码分析" class="headerlink" title="ButterKnife源代码分析"></a>ButterKnife源代码分析</h3><h4 id="ButterKnife的Bind方法调用"><a href="#ButterKnife的Bind方法调用" class="headerlink" title="ButterKnife的Bind方法调用"></a>ButterKnife的Bind方法调用</h4><p>先从ButterKnife的入口来分析,比如在Activity中我们调用 <em>ButterKnife.bind(this)</em> 方法,来看其内部实现:</p>
<pre><code class="java">@NonNull @UiThread
 public static Unbinder bind(@NonNull Activity target) {
   View sourceView = target.getWindow().getDecorView();
   return createBinding(target, sourceView);
 }
</code></pre>
<p>这里获取到的是顶层DecorView,target是activity对象本身,然后交给 <em>createBinding</em> 方法.</p>
<pre><code class="java">private static Unbinder createBinding(@NonNull Object target, @NonNull View source) {
   Class&lt;?&gt; targetClass = target.getClass();
   if (debug) Log.d(TAG, &quot;Looking up binding for &quot; + targetClass.getName());
   Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);

   if (constructor == null) {
     return Unbinder.EMPTY;
   }

   //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.
   try {
     return constructor.newInstance(target, source);
   } catch (IllegalAccessException e) {
     throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);
   } catch (InstantiationException e) {
     throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);
   } catch (InvocationTargetException e) {
     Throwable cause = e.getCause();
     if (cause instanceof RuntimeException) {
       throw (RuntimeException) cause;
     }
     if (cause instanceof Error) {
       throw (Error) cause;
     }
     throw new RuntimeException(&quot;Unable to create binding instance.&quot;, cause);
   }
 }
</code></pre>
<p>这里可以看到 根据类名称来通过 <em>findBindingConstructorForClass</em> 查找该类具有两个参数的构造函数.</p>
<pre><code class="java">@Nullable @CheckResult @UiThread
  private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) {
    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);
    if (bindingCtor != null) {
      if (debug) Log.d(TAG, &quot;HIT: Cached in binding map.&quot;);
      return bindingCtor;
    }
    String clsName = cls.getName();
    if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)) {
      if (debug) Log.d(TAG, &quot;MISS: Reached framework class. Abandoning search.&quot;);
      return null;
    }
    try {
      Class&lt;?&gt; bindingClass = Class.forName(clsName + &quot;_ViewBinding&quot;);
      //noinspection unchecked
      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);
      if (debug) Log.d(TAG, &quot;HIT: Loaded binding class and constructor.&quot;);
    } catch (ClassNotFoundException e) {
      if (debug) Log.d(TAG, &quot;Not found. Trying superclass &quot; + cls.getSuperclass().getName());
      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());
    } catch (NoSuchMethodException e) {
      throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e);
    }
    BINDINGS.put(cls, bindingCtor);
    return bindingCtor;
  }
</code></pre>
<pre><code class="java">@VisibleForTesting
 static final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();
</code></pre>
<p>这里 BINDINGS 是一个LinkedHashMap,存放的是类对象和它的构造函数对应关系.相当于一个缓存的作用,注意这里找的class对象是获取activity的类名称再加上 <em>_ViewBinding</em> 后缀.当使用ButterKnife编译完成之后,我们可以在我们工程中的build目录中找到 这些中间类.比如 你的activity名称叫做 “MainActivity”,那么生成的<br>中间类就叫做 “MainActivity_ViewBinding”.可以查看下里面的代码.就像这样:</p>
<pre><code class="java">public class SimpleActivity_ViewBinding&lt;T extends SimpleActivity&gt; implements Unbinder {
  protected T target;

  private View view2130968578;

  private View view2130968579;

  @UiThread
  public SimpleActivity_ViewBinding(final T target, View source) {
    this.target = target;

    View view;
    target.title = Utils.findRequiredViewAsType(source, R.id.title, &quot;field &#39;title&#39;&quot;, TextView.class);
    target.subtitle = Utils.findRequiredViewAsType(source, R.id.subtitle, &quot;field &#39;subtitle&#39;&quot;, TextView.class);
    view = Utils.findRequiredView(source, R.id.hello, &quot;field &#39;hello&#39;, method &#39;sayHello&#39;, and method &#39;sayGetOffMe&#39;&quot;);
    target.hello = Utils.castView(view, R.id.hello, &quot;field &#39;hello&#39;&quot;, Button.class);
    view2130968578 = view;
    view.setOnClickListener(new DebouncingOnClickListener() {
      @Override
      public void doClick(View p0) {
        target.sayHello();
      }
    });
    view.setOnLongClickListener(new View.OnLongClickListener() {
      @Override
      public boolean onLongClick(View p0) {
        return target.sayGetOffMe();
      }
    });
    view = Utils.findRequiredView(source, R.id.list_of_things, &quot;field &#39;listOfThings&#39; and method &#39;onItemClick&#39;&quot;);
    target.listOfThings = Utils.castView(view, R.id.list_of_things, &quot;field &#39;listOfThings&#39;&quot;, ListView.class);
    view2130968579 = view;
    ((AdapterView&lt;?&gt;) view).setOnItemClickListener(new AdapterView.OnItemClickListener() {
      @Override
      public void onItemClick(AdapterView&lt;?&gt; p0, View p1, int p2, long p3) {
        target.onItemClick(p2);
      }
    });
    target.footer = Utils.findRequiredViewAsType(source, R.id.footer, &quot;field &#39;footer&#39;&quot;, TextView.class);
    target.headerViews = Utils.listOf(
        Utils.findRequiredView(source, R.id.title, &quot;field &#39;headerViews&#39;&quot;),
        Utils.findRequiredView(source, R.id.subtitle, &quot;field &#39;headerViews&#39;&quot;),
        Utils.findRequiredView(source, R.id.hello, &quot;field &#39;headerViews&#39;&quot;));
  }

  @Override
  @CallSuper
  public void unbind() {
    T target = this.target;
    if (target == null) throw new IllegalStateException(&quot;Bindings already cleared.&quot;);

    target.title = null;
    target.subtitle = null;
    target.hello = null;
    target.listOfThings = null;
    target.footer = null;
    target.headerViews = null;

    view2130968578.setOnClickListener(null);
    view2130968578.setOnLongClickListener(null);
    view2130968578 = null;
    ((AdapterView&lt;?&gt;) view2130968579).setOnItemClickListener(null);
    view2130968579 = null;

    this.target = null;
  }
}
</code></pre>
<p>这个java类是通过注解解析器完成通过代码来生成的.可以看到里面就是一些view的初始化和事件绑定.唯一要注意的一点是,这里的中间类都是实现了unBinder接口,实现了unBind方法,里面是对view和各种事件的回收.主要是用在 <em>fragment</em> 中的使用的,看下ButterKnife的说明会看到,在 fragment使用完成之后必须调用 <em>ViewBinder.unBinder</em> 方法来完成view的回收.<br>下面的代码来着ButterKnife的说明:</p>
<pre><code class="java">BINDING RESET

Fragments have a different view lifecycle than activities. When binding a fragment in onCreateView, set the views to null in onDestroyView. Butter Knife returns an Unbinder instance when you call bind to do this for you. Call its unbind method in the appropriate lifecycle callback.

public class FancyFragment extends Fragment {
  @BindView(R.id.button1) Button button1;
  @BindView(R.id.button2) Button button2;
  private Unbinder unbinder;

  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fancy_fragment, container, false);
    unbinder = ButterKnife.bind(this, view);
    // TODO Use fields...
    return view;
  }

  @Override public void onDestroyView() {
    super.onDestroyView();
    unbinder.unbind();
  }
}
</code></pre>
<h4 id="注解分析器AnnotationProcessor的逻辑分析"><a href="#注解分析器AnnotationProcessor的逻辑分析" class="headerlink" title="注解分析器AnnotationProcessor的逻辑分析"></a>注解分析器AnnotationProcessor的逻辑分析</h4><p>核心点就在 <em>ButterKnifeProcessor</em> 里面.</p>
<pre><code class="java">@Override public Set&lt;String&gt; getSupportedAnnotationTypes() {
    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();
    for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) {
      types.add(annotation.getCanonicalName());
    }
    return types;
  }

  private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() {
    Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;();

    annotations.add(BindArray.class);
    annotations.add(BindBitmap.class);
    annotations.add(BindBool.class);
    annotations.add(BindColor.class);
    annotations.add(BindDimen.class);
    annotations.add(BindDrawable.class);
    annotations.add(BindFloat.class);
    annotations.add(BindInt.class);
    annotations.add(BindString.class);
    annotations.add(BindView.class);
    annotations.add(BindViews.class);
    annotations.addAll(LISTENERS);

    return annotations;
  }
  private static final List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList(//
       OnCheckedChanged.class, //
       OnClick.class, //
       OnEditorAction.class, //
       OnFocusChange.class, //
       OnItemClick.class, //
       OnItemLongClick.class, //
       OnItemSelected.class, //
       OnLongClick.class, //
       OnPageChange.class, //
       OnTextChanged.class, //
       OnTouch.class //
   );
</code></pre>
<p>可以通过 <em>getSupportedAnnotationTypes</em> 方法看到都支持哪些注解的处理.<br>重点的处理方法就在 <em>process</em> 方法中:</p>
<pre><code class="java">@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {
   Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);

   for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) {
     TypeElement typeElement = entry.getKey();
     BindingSet binding = entry.getValue();

     JavaFile javaFile = binding.brewJava(sdk);
     try {
       javaFile.writeTo(filer);
     } catch (IOException e) {
       error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage());
     }
   }

   return false;
 }
</code></pre>
<p>可以看到第一行就是通过遍历扫描来找到对应类的所有 <em>ButterKnife</em> 注解,然后一次性来生成每个类的新的源文件类.</p>
<p>下面来看 <em>findAndParseTargets</em> 方法.</p>
<pre><code class="java">private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) {
    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;();
    Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;();

    scanForRClasses(env);

    // Process each @BindArray element.
    for (Element element : env.getElementsAnnotatedWith(BindArray.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceArray(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindArray.class, e);
      }
    }

    // Process each @BindBitmap element.
    for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceBitmap(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindBitmap.class, e);
      }
    }

    // Process each @BindBool element.
    for (Element element : env.getElementsAnnotatedWith(BindBool.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceBool(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindBool.class, e);
      }
    }

    // Process each @BindColor element.
    for (Element element : env.getElementsAnnotatedWith(BindColor.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceColor(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindColor.class, e);
      }
    }

    // Process each @BindDimen element.
    for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceDimen(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindDimen.class, e);
      }
    }

    // Process each @BindDrawable element.
    for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceDrawable(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindDrawable.class, e);
      }
    }

    // Process each @BindFloat element.
    for (Element element : env.getElementsAnnotatedWith(BindFloat.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceFloat(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindFloat.class, e);
      }
    }

    // Process each @BindInt element.
    for (Element element : env.getElementsAnnotatedWith(BindInt.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceInt(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindInt.class, e);
      }
    }

    // Process each @BindString element.
    for (Element element : env.getElementsAnnotatedWith(BindString.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceString(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindString.class, e);
      }
    }

    // Process each @BindView element.
    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
      // we don&#39;t SuperficialValidation.validateElement(element)
      // so that an unresolved View type can be generated by later processing rounds
      try {
        parseBindView(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindView.class, e);
      }
    }

    // Process each @BindViews element.
    for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
      // we don&#39;t SuperficialValidation.validateElement(element)
      // so that an unresolved View type can be generated by later processing rounds
      try {
        parseBindViews(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindViews.class, e);
      }
    }

    // Process each annotation that corresponds to a listener.
    for (Class&lt;? extends Annotation&gt; listener : LISTENERS) {
      findAndParseListener(env, listener, builderMap, erasedTargetNames);
    }

    // Associate superclass binders with their subclass binders. This is a queue-based tree walk
    // which starts at the roots (superclasses) and walks to the leafs (subclasses).
    Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =
        new ArrayDeque&lt;&gt;(builderMap.entrySet());
    Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;();
    while (!entries.isEmpty()) {
      Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();

      TypeElement type = entry.getKey();
      BindingSet.Builder builder = entry.getValue();

      TypeElement parentType = findParentType(type, erasedTargetNames);
      if (parentType == null) {
        bindingMap.put(type, builder.build());
      } else {
        BindingSet parentBinding = bindingMap.get(parentType);
        if (parentBinding != null) {
          builder.setParent(parentBinding);
          bindingMap.put(type, builder.build());
        } else {
          // Has a superclass binding but we haven&#39;t built it yet. Re-enqueue for later.
          entries.addLast(entry);
        }
      }
    }

    return bindingMap;
  }
</code></pre>
<p>这个 <em>findAndParseTargets</em> 方法看着很长,实际上分成了3部分,顶部是用来生成id和view的对应关系,中间是各种注解的处理后放入builderMap中,第三部分是遍历builderMap来生成BindingMap的.<br>先看如何生成ID的对应关系:</p>
<pre><code class="java">  scanForRClasses(env);
</code></pre>
<pre><code class="java">private void scanForRClasses(RoundEnvironment env) {
   if (trees == null) return;

   RClassScanner scanner = new RClassScanner();

   for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) {
     for (Element element : env.getElementsAnnotatedWith(annotation)) {
       JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation));
       if (tree != null) { // tree can be null if the references are compiled types and not source
         tree.accept(scanner);
       }
     }
   }

   for (String rClass : scanner.getRClasses()) {
     parseRClass(rClass);
   }
 }

 private void parseRClass(String rClass) {
   Element element;

   try {
     element = elementUtils.getTypeElement(rClass);
   } catch (MirroredTypeException mte) {
     element = typeUtils.asElement(mte.getTypeMirror());
   }

   JCTree tree = (JCTree) trees.getTree(element);
   if (tree != null) { // tree can be null if the references are compiled types and not source
     IdScanner idScanner =
         new IdScanner(symbols, elementUtils.getPackageOf(element).getQualifiedName().toString());
     tree.accept(idScanner);
   } else {
     parseCompiledR((TypeElement) element);
   }
 }

 private void parseCompiledR(TypeElement rClass) {
   for (Element element : rClass.getEnclosedElements()) {
     String innerClassName = element.getSimpleName().toString();
     if (SUPPORTED_TYPES.contains(innerClassName)) {
       for (Element enclosedElement : element.getEnclosedElements()) {
         if (enclosedElement instanceof VariableElement) {
           VariableElement variableElement = (VariableElement) enclosedElement;
           Object value = variableElement.getConstantValue();

           if (value instanceof Integer) {
             int id = (Integer) value;
             ClassName rClassName =
                 ClassName.get(elementUtils.getPackageOf(variableElement).toString(), &quot;R&quot;,
                     innerClassName);
             String resourceName = variableElement.getSimpleName().toString();
             symbols.put(id, new Id(id, rClassName, resourceName));
           }
         }
       }
     }
   }
 }

 private static class RClassScanner extends TreeScanner {
   private final Set&lt;String&gt; rClasses = new LinkedHashSet&lt;&gt;();

   @Override public void visitSelect(JCTree.JCFieldAccess jcFieldAccess) {
     Symbol symbol = jcFieldAccess.sym;
     if (symbol != null
         &amp;&amp; symbol.getEnclosingElement() != null
         &amp;&amp; symbol.getEnclosingElement().getEnclosingElement() != null
         &amp;&amp; symbol.getEnclosingElement().getEnclosingElement().enclClass() != null) {
       rClasses.add(symbol.getEnclosingElement().getEnclosingElement().enclClass().className());
     }
   }

   Set&lt;String&gt; getRClasses() {
     return rClasses;
   }
 }

 private static class IdScanner extends TreeScanner {
   private final Map&lt;Integer, Id&gt; ids;
   private final String packageName;

   IdScanner(Map&lt;Integer, Id&gt; ids, String packageName) {
     this.ids = ids;
     this.packageName = packageName;
   }

   @Override public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {
     for (JCTree tree : jcClassDecl.defs) {
       if (tree instanceof ClassTree) {
         ClassTree classTree = (ClassTree) tree;
         String className = classTree.getSimpleName().toString();
         if (SUPPORTED_TYPES.contains(className)) {
           ClassName rClassName = ClassName.get(packageName, &quot;R&quot;, className);
           VarScanner scanner = new VarScanner(ids, rClassName);
           ((JCTree) classTree).accept(scanner);
         }
       }
     }
   }
 }

 private static class VarScanner extends TreeScanner {
   private final Map&lt;Integer, Id&gt; ids;
   private final ClassName className;

   private VarScanner(Map&lt;Integer, Id&gt; ids, ClassName className) {
     this.ids = ids;
     this.className = className;
   }

   @Override public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl) {
     if (&quot;int&quot;.equals(jcVariableDecl.getType().toString())) {
       int id = Integer.valueOf(jcVariableDecl.getInitializer().toString());
       String resourceName = jcVariableDecl.getName().toString();
       ids.put(id, new Id(id, className, resourceName));
     }
   }
 }
</code></pre>
<p>这里,如何关于如何生成这个对应关系的里面用到一些api我不是很了解,网上的资料也很少,后续等到研究明白了再补充吧,只是通过字面理解应该是通过遍历java的语法分析树找到R文件中对应的filed的ID,组合成一个 <em>Id</em> .<br>中间的部分就是用来做生成builderMap的,我们挑其中的一个方法来看,大部分的方法都是类似的.</p>
<pre><code class="java">private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,
                              Set&lt;TypeElement&gt; erasedTargetNames) {
       TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();

       // Start by verifying common generated code restrictions.
       boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, &quot;fields&quot;, element)
               || isBindingInWrongPackage(BindView.class, element);

       // Verify that the target type extends from View.
       TypeMirror elementType = element.asType();
       if (elementType.getKind() == TypeKind.TYPEVAR) {
           TypeVariable typeVariable = (TypeVariable) elementType;
           elementType = typeVariable.getUpperBound();
       }
       if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) {
           if (elementType.getKind() == TypeKind.ERROR) {
               note(element, &quot;@%s field with unresolved type (%s) &quot;
                               + &quot;must elsewhere be generated as a View or interface. (%s.%s)&quot;,
                       BindView.class.getSimpleName(), elementType, enclosingElement.getQualifiedName(),
                       element.getSimpleName());
           } else {
               error(element, &quot;@%s fields must extend from View or be an interface. (%s.%s)&quot;,
                       BindView.class.getSimpleName(), enclosingElement.getQualifiedName(),
                       element.getSimpleName());
               hasError = true;
           }
       }

       if (hasError) {
           return;
       }

       // Assemble information on the field.
       int id = element.getAnnotation(BindView.class).value();

       BindingSet.Builder builder = builderMap.get(enclosingElement);
       if (builder != null) {
           String existingBindingName = builder.findExistingBindingName(getId(id));
           if (existingBindingName != null) {
               error(element, &quot;Attempt to use @%s for an already bound ID %d on &#39;%s&#39;. (%s.%s)&quot;,
                       BindView.class.getSimpleName(), id, existingBindingName,
                       enclosingElement.getQualifiedName(), element.getSimpleName());
               return;
           }
       } else {
           builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
       }

       String name = element.getSimpleName().toString();
       TypeName type = TypeName.get(elementType);
       boolean required = isFieldRequired(element);

       builder.addField(getId(id), new FieldViewBinding(name, type, required));

       // Add the type-erased version to the valid binding targets set.
       erasedTargetNames.add(enclosingElement);
   }
</code></pre>
<p>这个方法前半部分用来做ID校验,防止有重复的Id定义出现错误.<br>后半部分生成一个 <em>BindingSet.Builder</em> 对象,这个对象就是用来后续通过 <em>javapoet</em> 来生成制定的java源文件的.builderMap的key是声明注解的类,通常是我们的Activity或者viewHolder.<br>然后把 <em>FieldViewBinding</em> 放入builder中,其中 filed的key就是view本身的ID.</p>
<p><em>findAndParseTargets</em> 的最后一部分是用来生成bindingMap的,key是声明类,value是BindingSet对象.<br>通过中间生成的 <em>builderMap</em> 来完成.主要是用来子类和父类如果同时声明的时把两者合并成一个BindingSet对象.</p>
<p><em>BindingSet</em> 对象就是用来交给javaPoet来生成中间源文件的对象.</p>
<p>生成了BindingMap之后回到顶层的 <em>process</em> 方法:</p>
<pre><code class="java">for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) {
            TypeElement typeElement = entry.getKey();
            BindingSet binding = entry.getValue();

            JavaFile javaFile = binding.brewJava(sdk);
            try {
                javaFile.writeTo(filer);
            } catch (IOException e) {
                error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage());
            }
        }
</code></pre>
<p>可以看到这里调用的是 <em>bindingSet</em> 对象的 <em>brewJava</em> 方法来完成java源文件的写入的:</p>
<pre><code class="java">
  JavaFile brewJava(int sdk) {
    return JavaFile.builder(bindingClassName.packageName(), createType(sdk))
        .addFileComment(&quot;Generated code from Butter Knife. Do not modify!&quot;)
        .build();
  }
</code></pre>
<p>然后调用 <em>createType</em> 方法:</p>
<pre><code class="java">private TypeSpec createType(int sdk) {
    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())
        .addModifiers(PUBLIC);
    if (isFinal) {
      result.addModifiers(FINAL);
    }

    if (parentBinding != null) {
      result.superclass(parentBinding.bindingClassName);
    } else {
      result.addSuperinterface(UNBINDER);
    }

    if (hasTargetField()) {
      result.addField(targetTypeName, &quot;target&quot;, PRIVATE);
    }

    if (!constructorNeedsView()) {
      // Add a delegating constructor with a target type + view signature for reflective use.
      result.addMethod(createBindingViewDelegateConstructor(targetTypeName));
    }
    result.addMethod(createBindingConstructor(targetTypeName, sdk));

    if (hasViewBindings() || parentBinding == null) {
      result.addMethod(createBindingUnbindMethod(result, targetTypeName));
    }

    return result.build();
  }
</code></pre>
<p><em>createType</em> 分为三部分,一部分是createBindingViewDelegateConstructor,一部分是createBindingConstructor,还有一部分是createBindingUnbindMethod</p>
<pre><code class="java">private MethodSpec createBindingViewDelegateConstructor(TypeName targetType) {
  return MethodSpec.constructorBuilder()
      .addJavadoc(&quot;@deprecated Use {@link #$T($T, $T)} for direct creation.\n    &quot;
              + &quot;Only present for runtime invocation through {@code ButterKnife.bind()}.\n&quot;,
          bindingClassName, targetType, CONTEXT)
      .addAnnotation(Deprecated.class)
      .addAnnotation(UI_THREAD)
      .addModifiers(PUBLIC)
      .addParameter(targetType, &quot;target&quot;)
      .addParameter(VIEW, &quot;source&quot;)
      .addStatement((&quot;this(target, source.getContext())&quot;))
      .build();
}
</code></pre>
<p>这个构造函数的作用暂时没有弄明白,看说明好像是用来在运行的时候反射用的.</p>
<pre><code class="java">private MethodSpec createBindingConstructor(TypeName targetType, int sdk) {
    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
        .addAnnotation(UI_THREAD)
        .addModifiers(PUBLIC);

    if (hasMethodBindings()) {
      constructor.addParameter(targetType, &quot;target&quot;, FINAL);
    } else {
      constructor.addParameter(targetType, &quot;target&quot;);
    }

    if (constructorNeedsView()) {
      constructor.addParameter(VIEW, &quot;source&quot;);
    } else {
      constructor.addParameter(CONTEXT, &quot;context&quot;);
    }

    if (hasUnqualifiedResourceBindings()) {
      // Aapt can change IDs out from underneath us, just suppress since all will work at runtime.
      constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
          .addMember(&quot;value&quot;, &quot;$S&quot;, &quot;ResourceType&quot;)
          .build());
    }

    if (hasOnTouchMethodBindings()) {
      constructor.addAnnotation(AnnotationSpec.builder(SUPPRESS_LINT)
          .addMember(&quot;value&quot;, &quot;$S&quot;, &quot;ClickableViewAccessibility&quot;)
          .build());
    }

    if (parentBinding != null) {
      if (parentBinding.constructorNeedsView()) {
        constructor.addStatement(&quot;super(target, source)&quot;);
      } else if (constructorNeedsView()) {
        constructor.addStatement(&quot;super(target, source.getContext())&quot;);
      } else {
        constructor.addStatement(&quot;super(target, context)&quot;);
      }
      constructor.addCode(&quot;\n&quot;);
    }
    if (hasTargetField()) {
      constructor.addStatement(&quot;this.target = target&quot;);
      constructor.addCode(&quot;\n&quot;);
    }

    if (hasViewBindings()) {
      if (hasViewLocal()) {
        // Local variable in which all views will be temporarily stored.
        constructor.addStatement(&quot;$T view&quot;, VIEW);
      }
      for (ViewBinding binding : viewBindings) {
        addViewBinding(constructor, binding);
      }
      for (FieldCollectionViewBinding binding : collectionBindings) {
        constructor.addStatement(&quot;$L&quot;, binding.render());
      }

      if (!resourceBindings.isEmpty()) {
        constructor.addCode(&quot;\n&quot;);
      }
    }

    if (!resourceBindings.isEmpty()) {
      if (constructorNeedsView()) {
        constructor.addStatement(&quot;$T context = source.getContext()&quot;, CONTEXT);
      }
      if (hasResourceBindingsNeedingResource(sdk)) {
        constructor.addStatement(&quot;$T res = context.getResources()&quot;, RESOURCES);
      }
      for (ResourceBinding binding : resourceBindings) {
        constructor.addStatement(&quot;$L&quot;, binding.render(sdk));
      }
    }

    return constructor.build();
  }
</code></pre>
<p>这个方法来生成中间类的构造函数,里面定义了view的findViewById和绑定事件,生成的结果在前面已经列出了,就是 <em>javaPoet</em> 的API调用,非常容易理解.</p>
<p>最后是生成filed和unbind方法的 <em>createBindingUnbindMethod</em>:</p>
<pre><code class="java">
  private MethodSpec createBindingUnbindMethod(TypeSpec.Builder bindingClass,
      TypeName targetType) {
    MethodSpec.Builder result = MethodSpec.methodBuilder(&quot;unbind&quot;)
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC);
    if (!isFinal &amp;&amp; parentBinding == null) {
      result.addAnnotation(CALL_SUPER);
    }

    if (hasTargetField()) {
      if (hasFieldBindings()) {
        result.addStatement(&quot;$T target = this.target&quot;, targetType);
      }
      result.addStatement(&quot;if (target == null) throw new $T($S)&quot;, IllegalStateException.class,
          &quot;Bindings already cleared.&quot;);
      result.addStatement(&quot;$N = null&quot;, hasFieldBindings() ? &quot;this.target&quot; : &quot;target&quot;);
      result.addCode(&quot;\n&quot;);
      for (ViewBinding binding : viewBindings) {
        if (binding.getFieldBinding() != null) {
          result.addStatement(&quot;target.$L = null&quot;, binding.getFieldBinding().getName());
        }
      }
      for (FieldCollectionViewBinding binding : collectionBindings) {
        result.addStatement(&quot;target.$L = null&quot;, binding.name);
      }
    }

    if (hasMethodBindings()) {
      result.addCode(&quot;\n&quot;);
      for (ViewBinding binding : viewBindings) {
        addFieldAndUnbindStatement(bindingClass, result, binding);
      }
    }

    if (parentBinding != null) {
      result.addCode(&quot;\n&quot;);
      result.addStatement(&quot;super.unbind()&quot;);
    }
    return result.build();
  }
</code></pre>
<p>这里unBind方法不做过多的解释,主要是来看</p>
<pre><code class="java">for (ViewBinding binding : viewBindings) {
  addFieldAndUnbindStatement(bindingClass, result, binding);
}
</code></pre>
<pre><code class="java">
  private void addFieldAndUnbindStatement(TypeSpec.Builder result, MethodSpec.Builder unbindMethod,
      ViewBinding bindings) {
    // Only add fields to the binding if there are method bindings.
    Map&lt;ListenerClass, Map&lt;ListenerMethod, Set&lt;MethodViewBinding&gt;&gt;&gt; classMethodBindings =
        bindings.getMethodBindings();
    if (classMethodBindings.isEmpty()) {
      return;
    }

    String fieldName = bindings.isBoundToRoot() ? &quot;viewSource&quot; : &quot;view&quot; + bindings.getId().value;
    result.addField(VIEW, fieldName, PRIVATE);

    // We only need to emit the null check if there are zero required bindings.
    boolean needsNullChecked = bindings.getRequiredBindings().isEmpty();
    if (needsNullChecked) {
      unbindMethod.beginControlFlow(&quot;if ($N != null)&quot;, fieldName);
    }

    for (ListenerClass listenerClass : classMethodBindings.keySet()) {
      // We need to keep a reference to the listener
      // in case we need to unbind it via a remove method.
      boolean requiresRemoval = !&quot;&quot;.equals(listenerClass.remover());
      String listenerField = &quot;null&quot;;
      if (requiresRemoval) {
        TypeName listenerClassName = bestGuess(listenerClass.type());
        listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
        result.addField(listenerClassName, listenerField, PRIVATE);
      }

      if (!VIEW_TYPE.equals(listenerClass.targetType())) {
        unbindMethod.addStatement(&quot;(($T) $N).$N($N)&quot;, bestGuess(listenerClass.targetType()),
            fieldName, removerOrSetter(listenerClass, requiresRemoval), listenerField);
      } else {
        unbindMethod.addStatement(&quot;$N.$N($N)&quot;, fieldName,
            removerOrSetter(listenerClass, requiresRemoval), listenerField);
      }

      if (requiresRemoval) {
        unbindMethod.addStatement(&quot;$N = null&quot;, listenerField);
      }
    }

    unbindMethod.addStatement(&quot;$N = null&quot;, fieldName);

    if (needsNullChecked) {
      unbindMethod.endControlFlow();
    }
  }
</code></pre>
<p>这个方法用来生成中间类的filed,也就是view和事件的声明.之前在前面找了半天如何生成filed的方法一直没有找到,后来这这里才发现的.<br>声明的view名称是View+ID这种格式.</p>
<p>到这里大概的流程就讲完了,可能还是有些细节没有讲到,不过没有关系,只要明白了大概的运行方式就可以了.可以看到作者的思路非常的新颖就是通过中间类来完成一些初始化工作,这个给我们后续的android的编程中提供了一套可借鉴的思路.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://jakewharton.github.io/butterknife/" title="butterKnife document" target="_blank" rel="external">butterKnife document</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/13/2017/java class基础知识/" rel="next" title="java class基础知识">
                <i class="fa fa-chevron-left"></i> java class基础知识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/19/2017/android asyncTask源码分析/" rel="prev" title="android asyncTask源码分析">
                android asyncTask源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JustinYan</p>
              <p class="site-description motion-element" itemprop="description">JustinYan的个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">Kategorien</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#android-ButterKnife源码解析"><span class="nav-number">1.</span> <span class="nav-text">android ButterKnife源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ButterKnife基本原理"><span class="nav-number">1.1.</span> <span class="nav-text">ButterKnife基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ButterKnife源代码分析"><span class="nav-number">1.2.</span> <span class="nav-text">ButterKnife源代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ButterKnife的Bind方法调用"><span class="nav-number">1.2.1.</span> <span class="nav-text">ButterKnife的Bind方法调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注解分析器AnnotationProcessor的逻辑分析"><span class="nav-number">1.2.2.</span> <span class="nav-text">注解分析器AnnotationProcessor的逻辑分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">1.3.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JustinYan</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
