<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">Android LruMemoryCache源码分析</h1><h2 class="subtitle">2017-02-17</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-LruMemoryCache源码分析"><span class="toc-number">1.</span> <span class="toc-text">Android LruMemoryCache源码分析</span></a></li></ol></div></div><div class="post-text"><h2 id="Android-LruMemoryCache源码分析"><a href="#Android-LruMemoryCache源码分析" class="headerlink" title="Android LruMemoryCache源码分析"></a>Android LruMemoryCache源码分析</h2><p>  在分析Univeral Image Loader的时候看到里面的缓存实现很不错.其中的内存缓存使用的是它自己写的 <em>LruMemoryCache</em> ,文件缓存使用的是 <em>DiskLruCache</em> ,其中的 <em>DiskLruCache</em> 的源码已经分析完了,下面简单讲下 <em>LruMemoryCache</em> 的实现.<br><a id="more"></a></p>
<pre><code class="java">  public class LruMemoryCache implements MemoryCache {

    private final LinkedHashMap&lt;String, Bitmap&gt; map;

    private final int maxSize;
    /** Size of this cache in bytes */
    private int size;

    /** @param maxSize Maximum sum of the sizes of the Bitmaps in this cache */
    public LruMemoryCache(int maxSize) {
        if (maxSize &lt;= 0) {
            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);
        }
        this.maxSize = maxSize;
        this.map = new LinkedHashMap&lt;String, Bitmap&gt;(0, 0.75f, true);
    }

    /**
     * Returns the Bitmap for {@code key} if it exists in the cache. If a Bitmap was returned, it is moved to the head
     * of the queue. This returns null if a Bitmap is not cached.
     */
    @Override
    public final Bitmap get(String key) {
        if (key == null) {
            throw new NullPointerException(&quot;key == null&quot;);
        }

        synchronized (this) {
            return map.get(key);
        }
    }

    /** Caches {@code Bitmap} for {@code key}. The Bitmap is moved to the head of the queue. */
    @Override
    public final boolean put(String key, Bitmap value) {
        if (key == null || value == null) {
            throw new NullPointerException(&quot;key == null || value == null&quot;);
        }

        synchronized (this) {
            size += sizeOf(key, value);
            Bitmap previous = map.put(key, value);
            if (previous != null) {
                size -= sizeOf(key, previous);
            }
        }

        trimToSize(maxSize);
        return true;
    }

    /**
     * Remove the eldest entries until the total of remaining entries is at or below the requested size.
     *
     * @param maxSize the maximum size of the cache before returning. May be -1 to evict even 0-sized elements.
     */
    private void trimToSize(int maxSize) {
        while (true) {
            String key;
            Bitmap value;
            synchronized (this) {
                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {
                    throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;);
                }

                if (size &lt;= maxSize || map.isEmpty()) {
                    break;
                }

                Map.Entry&lt;String, Bitmap&gt; toEvict = map.entrySet().iterator().next();
                if (toEvict == null) {
                    break;
                }
                key = toEvict.getKey();
                value = toEvict.getValue();
                map.remove(key);
                size -= sizeOf(key, value);
            }
        }
    }

    /** Removes the entry for {@code key} if it exists. */
    @Override
    public final Bitmap remove(String key) {
        if (key == null) {
            throw new NullPointerException(&quot;key == null&quot;);
        }

        synchronized (this) {
            Bitmap previous = map.remove(key);
            if (previous != null) {
                size -= sizeOf(key, previous);
            }
            return previous;
        }
    }

    @Override
    public Collection&lt;String&gt; keys() {
        synchronized (this) {
            return new HashSet&lt;String&gt;(map.keySet());
        }
    }

    @Override
    public void clear() {
        trimToSize(-1); // -1 will evict 0-sized elements
    }

    /**
     * Returns the size {@code Bitmap} in bytes.
     * &lt;p/&gt;
     * An entry&#39;s size must not change while it is in the cache.
     */
    private int sizeOf(String key, Bitmap value) {
        return value.getRowBytes() * value.getHeight();
    }

    @Override
    public synchronized final String toString() {
        return String.format(&quot;LruCache[maxSize=%d]&quot;, maxSize);
    }
  }
</code></pre>
<p>  整个代码大概一百多行,主要是通过维护一个LinkedhashMap来保存key对应的bitmap对象,同时内部通过size属性来表明总容量.<br>  当size超过最大限制的时候,就会触发 <em>trimToSize</em> 方法.</p>
<pre><code class="java">  private void trimToSize(int maxSize) {
    while (true) {
      String key;
      Bitmap value;
      synchronized (this) {
        if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {
          throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;);
        }

        if (size &lt;= maxSize || map.isEmpty()) {
          break;
        }

        Map.Entry&lt;String, Bitmap&gt; toEvict = map.entrySet().iterator().next();
        if (toEvict == null) {
          break;
        }
        key = toEvict.getKey();
        value = toEvict.getValue();
        map.remove(key);
        size -= sizeOf(key, value);
      }
    }
  }
</code></pre>
<p>  可以看到这里循环遍历map对象,从头到尾的删除对象,每删除一个对象之后计算size容量是否低于最大容量,直到满足小于最大容量限制.</p>
<p>  就是这么简单,over.<br>  可以看到所有 LRUXX 缓存类的实现都是基于这种思路,交给一个map容器,如果超过容量限制的时候就触发减容操作,直到满足条件.这里的数据结构很重要,都是用的 <em>LinkedHashMap</em> ,有序并且容易删除.</p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>