<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ViewDragHelper源码分析 · pheobusyy</title><meta name="description" content="ViewDragHelper源码分析 - yanyi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://pheobusyy.github.io/atom.xml" title="pheobusyy"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ViewDragHelper源码分析</h1><div class="post-info">Feb 9, 2017</div><div class="post-content"><h2 id="ViewDragHelper源码分析"><a href="#ViewDragHelper源码分析" class="headerlink" title="ViewDragHelper源码分析"></a>ViewDragHelper源码分析</h2><p>在学习第三方的一个开源库的时候,发现了系统居然已为viewGroup控制的子view的手势移动提供了相关的组件,就是今天要介绍的 <em>ViewDragHelper</em> ,看了一下发现功能非常的强大,基本满足了我们平时的使用要求,首先我们先讲解一下它的用法,然后再从源码层面来分析一下它的实现思路.</p>
<h3 id="ViewDragHelper的用法"><a href="#ViewDragHelper的用法" class="headerlink" title="ViewDragHelper的用法"></a>ViewDragHelper的用法</h3><p>先通过一个简单的demo来看一下ViewDragHelper的用法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDragLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ViewDragHelper mViewDragHelper;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> View mDragView;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDragLayout</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDragLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDragLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        mViewDragHelper = ViewDragHelper.create(<span class="keyword">this</span>, <span class="number">1f</span>, <span class="keyword">new</span> ViewDragCallBack());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragCallBack</span> <span class="keyword">extends</span> <span class="title">ViewDragHelper</span>.<span class="title">Callback</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> mDragView.getId() == child.getId();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 处理水平方向上的拖动</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> child 拖动的View</div><div class="line">         * <span class="doctag">@param</span> left  移动到x轴的距离</div><div class="line">         * <span class="doctag">@param</span> dx    建议的移动的x距离</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</div><div class="line">            <span class="comment">//两个if主要是让view在ViewGroup中</span></div><div class="line">            <span class="keyword">if</span> (left &lt; getPaddingLeft()) &#123;</div><div class="line">                <span class="keyword">return</span> getPaddingLeft();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (left &gt; getWidth() - child.getMeasuredWidth()) &#123;</div><div class="line">                <span class="keyword">return</span> getWidth() - child.getMeasuredWidth();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> left;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionVertical</span><span class="params">(View child, <span class="keyword">int</span> top, <span class="keyword">int</span> dy)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (top &lt; getPaddingTop()) &#123;</div><div class="line">                <span class="keyword">return</span> getPaddingTop();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (top &gt; getHeight() - child.getMeasuredHeight()) &#123;</div><div class="line">                <span class="keyword">return</span> getHeight() - child.getMeasuredHeight();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> top;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mViewDragHelper.shouldInterceptTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        mViewDragHelper.processTouchEvent(event);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onFinishInflate();</div><div class="line">        mDragView = findViewById(R.id.dragview);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先继承一个LinearLayout,然后在构造函数中调用 <em>init</em> 方法,在里面创建 <em>ViewDragHelper</em> 实例.然后在LinearLayout里面放入一个view,这个view就是我们要拖动的mDragView.运行程序,可以看到在布局中的view是可以在里面随便拖动的,同时也不会被拖出边界外面.是不是很简单呢?下面来分析一下使用方法:</p>
<p>使用ViewDragHelper需要三个步骤:</p>
<ol>
<li>创建ViewDragHelper实例</li>
<li>触摸相关的方法调用,主要包括 <em>shouldInterceptTouchEvent(MotionEvent ev)</em> <em>processTouchEvent(MotionEvent ev)</em> 这两个方法</li>
<li>ViewDragHelper.Callback实例的编写,用来完成各种事件的回调</li>
</ol>
<p>(一) 创建ViewDragHelper实例<br>  ViewDragHelper提供了两个创建方法,分别对应:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, Callback cb)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ViewDragHelper(forParent.getContext(), forParent, cb);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, <span class="keyword">float</span> sensitivity, Callback cb)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ViewDragHelper helper = create(forParent, cb);</div><div class="line">    helper.mTouchSlop = (<span class="keyword">int</span>) (helper.mTouchSlop * (<span class="number">1</span> / sensitivity));</div><div class="line">    <span class="keyword">return</span> helper;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  两个方法的区别在于第二个方法提供了一个 <em>sensitivity</em> 参数,这个参数用来表示拖动触发的灵敏度,越大便是越灵敏.因为这里 <em>helper.mTouchSlop</em> 是通过 <em>ViewConfiguration</em> 来获得当前设备的最小的触发距离的,距离越小表示越灵敏.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ViewDragHelper</span><span class="params">(Context context, ViewGroup forParent, Callback cb)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (forParent == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Parent view may not be null"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (cb == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Callback may not be null"</span>);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     mParentView = forParent;</div><div class="line">     mCallback = cb;</div><div class="line"></div><div class="line">     <span class="keyword">final</span> ViewConfiguration vc = ViewConfiguration.get(context);</div><div class="line">     <span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</div><div class="line">     mEdgeSize = (<span class="keyword">int</span>) (EDGE_SIZE * density + <span class="number">0.5f</span>);</div><div class="line"></div><div class="line">     mTouchSlop = vc.getScaledTouchSlop();</div><div class="line">     mMaxVelocity = vc.getScaledMaximumFlingVelocity();</div><div class="line">     mMinVelocity = vc.getScaledMinimumFlingVelocity();</div><div class="line">     mScroller = ScrollerCompat.create(context, sInterpolator);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>(二) 触摸相关方法调用<br>  可以看到在继承的LinearLayout中,我们复写了两个触摸事件相关的方法:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> mViewDragHelper.shouldInterceptTouchEvent(ev);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    mViewDragHelper.processTouchEvent(event);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  首先触摸事件会触发 <em>onInterceptTouchEvent</em> 如果该方法返回true,则表明当前的viewGroup要拦截该触摸事件,那么触摸事件就不会传递给下层的子类view.而是交由自己的 <em>onTouchEvent</em> 方法来处理. 而如果 <em>onInterceptTouchEvent</em> 方法返回false,则事件会传递给子类的 <em>onTouchEvent</em> 方法,如果子类view的 <em>onTouchEvent</em> 什么都没做返回false的话,事件会再次回到viewGroup的 <em>onTouchEvent</em> 方法来处理,反之事件被成功消化,不会回到上层的viewGroup了.这是android触摸事件的传递流程.还有一个 <em>dispatchTouchEvent</em> 方法来决定是否要分发触摸事件,事件的传递会先进入这个方法,然后在这个方法中通过判断 <em>onInterceptTouchEvent</em> 来决定是否要分发事件.</p>
<p>  回头来看这里的用到的触摸回调方法,先是在 <em>onInterceptTouchEvent</em> 方法,通过 <em>mViewDragHelper.shouldInterceptTouchEvent(ev)</em> 来决定是否分发事件给子view,如果这里返回true,就会进入 <em>onTouchEvent</em> 在里面调用 <em>mViewDragHelper.processTouchEvent(event)</em> 这个方法就是用来移动view的核心方法了.</p>
<p>  我们先来看 <em>shouldInterceptTouchEvent</em> 方法:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">          <span class="comment">// Reset things for a new event stream, just in case we didn't get</span></div><div class="line">          <span class="comment">// the whole previous stream.</span></div><div class="line">          cancel();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</div><div class="line">          mVelocityTracker = VelocityTracker.obtain();</div><div class="line">      &#125;</div><div class="line">      mVelocityTracker.addMovement(ev);</div><div class="line"></div><div class="line">      <span class="keyword">switch</span> (action) &#123;</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">              <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</div><div class="line">              <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(<span class="number">0</span>);</div><div class="line">              saveInitialMotion(x, y, pointerId);</div><div class="line"></div><div class="line">              <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</div><div class="line"></div><div class="line">              <span class="comment">// Catch a settling view if possible.</span></div><div class="line">              <span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;</div><div class="line">                  tryCaptureViewForDrag(toCapture, pointerId);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</div><div class="line">              <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</div><div class="line">                  mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_DOWN: &#123;</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(actionIndex);</div><div class="line">              <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</div><div class="line">              <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</div><div class="line"></div><div class="line">              saveInitialMotion(x, y, pointerId);</div><div class="line"></div><div class="line">              <span class="comment">// A ViewDragHelper can only manipulate one view at a time.</span></div><div class="line">              <span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</div><div class="line">                  <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</div><div class="line">                      mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDragState == STATE_SETTLING) &#123;</div><div class="line">                  <span class="comment">// Catch a settling view if possible.</span></div><div class="line">                  <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</div><div class="line">                  <span class="keyword">if</span> (toCapture == mCapturedView) &#123;</div><div class="line">                      tryCaptureViewForDrag(toCapture, pointerId);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">              <span class="keyword">if</span> (mInitialMotionX == <span class="keyword">null</span> || mInitialMotionY == <span class="keyword">null</span>) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="comment">// First to cross a touch slop over a draggable view wins. Also report edge drags.</span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = ev.getPointerCount();</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(i);</div><div class="line"></div><div class="line">                  <span class="comment">// If pointer is invalid then skip the ACTION_MOVE.</span></div><div class="line">                  <span class="keyword">if</span> (!isValidPointerForActionMove(pointerId)) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">                  <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(i);</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(i);</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</div><div class="line"></div><div class="line">                  <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);</div><div class="line">                  <span class="keyword">if</span> (pastSlop) &#123;</div><div class="line">                      <span class="comment">// check the callback's</span></div><div class="line">                      <span class="comment">// getView[Horizontal|Vertical]DragRange methods to know</span></div><div class="line">                      <span class="comment">// if you can move at all along an axis, then see if it</span></div><div class="line">                      <span class="comment">// would clamp to the same value. If you can't move at</span></div><div class="line">                      <span class="comment">// all in every dimension with a nonzero range, bail.</span></div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</div><div class="line">                              targetLeft, (<span class="keyword">int</span>) dx);</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,</div><div class="line">                              (<span class="keyword">int</span>) dy);</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</div><div class="line">                              toCapture);</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);</div><div class="line">                      <span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></div><div class="line">                              &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></div><div class="line">                              || verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</div><div class="line">                          <span class="keyword">break</span>;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">                  reportNewEdgeDrags(dx, dy, pointerId);</div><div class="line">                  <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</div><div class="line">                      <span class="comment">// Callback might have started an edge drag</span></div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  <span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              saveLastMotion(ev);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_UP: &#123;</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(actionIndex);</div><div class="line">              clearMotionHistory(pointerId);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</div><div class="line">              cancel();</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> mDragState == STATE_DRAGGING;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  可以看到里面还是对触摸事件的那几种基本的类型分别做处理,我们知道事件的触发类型对应: ACTION_DOWN –&gt; ACTION_MOVE –&gt; ACTION_MOVE –&gt; ACTION_UP .同时这里加入了对多点触摸的处理.在上面的 ACTION_DOWN 的判断中,如果当前通过 <em>findTopChildUnder</em> 捕获的view就是之前的移动的view,并且处于释放状态,就重新捕获该view并调整状态.这种情况对应快速拖动之后松开后view会自己滑动一些距离的情况.第一次拖动的时候不会触发.</p>
<p>  下面进入 ACTION_MOVE ,在这里看到顺序获取多个触摸点,如果有没有越界,如果没有问题的话就会 调用 <em>tryCaptureViewForDrag</em> 来捕获要滑动的view,并求改其状态.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryCaptureViewForDrag</span><span class="params">(View toCapture, <span class="keyword">int</span> pointerId)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123;</div><div class="line">           <span class="comment">// Already done!</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (toCapture != <span class="keyword">null</span> &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123;</div><div class="line">           mActivePointerId = pointerId;</div><div class="line">           captureChildView(toCapture, pointerId);</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>  该方法又会调用 <em>captureChildView</em> 方法:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureChildView</span><span class="params">(View childView, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (childView.getParent() != mParentView) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"captureChildView: parameter must be a descendant "</span></div><div class="line">                 + <span class="string">"of the ViewDragHelper's tracked parent view ("</span> + mParentView + <span class="string">")"</span>);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     mCapturedView = childView;</div><div class="line">     mActivePointerId = activePointerId;</div><div class="line">     mCallback.onViewCaptured(childView, activePointerId);</div><div class="line">     setDragState(STATE_DRAGGING);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  在这个方法中最后修改view的状态为 <em>STATE_DRAGGING</em> .回到上面的 <em>shouldInterceptTouchEvent</em> 看最后一行的返回条件判断 <em>return mDragState == STATE_DRAGGING;</em> 正好对应这里的修改状态.也就是说当我们手势移动的时候,这里就会认为我们在移动触摸点下面的view,并返回true,方法调用就会进入下面要将的 <em>processTouchEvent</em> 方法了.</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">          <span class="comment">// Reset things for a new event stream, just in case we didn't get</span></div><div class="line">          <span class="comment">// the whole previous stream.</span></div><div class="line">          cancel();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</div><div class="line">          mVelocityTracker = VelocityTracker.obtain();</div><div class="line">      &#125;</div><div class="line">      mVelocityTracker.addMovement(ev);</div><div class="line"></div><div class="line">      <span class="keyword">switch</span> (action) &#123;</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">              <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</div><div class="line">              <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(<span class="number">0</span>);</div><div class="line">              <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</div><div class="line"></div><div class="line">              saveInitialMotion(x, y, pointerId);</div><div class="line"></div><div class="line">              <span class="comment">// Since the parent is already directly processing this touch event,</span></div><div class="line">              <span class="comment">// there is no reason to delay for a slop before dragging.</span></div><div class="line">              <span class="comment">// Start immediately if possible.</span></div><div class="line">              tryCaptureViewForDrag(toCapture, pointerId);</div><div class="line"></div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</div><div class="line">              <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</div><div class="line">                  mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_DOWN: &#123;</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(actionIndex);</div><div class="line">              <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</div><div class="line">              <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</div><div class="line"></div><div class="line">              saveInitialMotion(x, y, pointerId);</div><div class="line"></div><div class="line">              <span class="comment">// A ViewDragHelper can only manipulate one view at a time.</span></div><div class="line">              <span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</div><div class="line">                  <span class="comment">// If we're idle we can do anything! Treat it like a normal down event.</span></div><div class="line"></div><div class="line">                  <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</div><div class="line">                  tryCaptureViewForDrag(toCapture, pointerId);</div><div class="line"></div><div class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</div><div class="line">                  <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</div><div class="line">                      mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCapturedViewUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y)) &#123;</div><div class="line">                  <span class="comment">// We're still tracking a captured view. If the same view is under this</span></div><div class="line">                  <span class="comment">// point, we'll swap to controlling it with this pointer instead.</span></div><div class="line">                  <span class="comment">// (This will still work if we're "catching" a settling view.)</span></div><div class="line"></div><div class="line">                  tryCaptureViewForDrag(mCapturedView, pointerId);</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">              <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</div><div class="line">                  <span class="comment">// If pointer is invalid then skip the ACTION_MOVE.</span></div><div class="line">                  <span class="keyword">if</span> (!isValidPointerForActionMove(mActivePointerId)) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> index = ev.findPointerIndex(mActivePointerId);</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(index);</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(index);</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (x - mLastMotionX[mActivePointerId]);</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> idy = (<span class="keyword">int</span>) (y - mLastMotionY[mActivePointerId]);</div><div class="line"></div><div class="line">                  dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);</div><div class="line"></div><div class="line">                  saveLastMotion(ev);</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">// Check to see if any pointer is now over a draggable view.</span></div><div class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = ev.getPointerCount();</div><div class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(i);</div><div class="line"></div><div class="line">                      <span class="comment">// If pointer is invalid then skip the ACTION_MOVE.</span></div><div class="line">                      <span class="keyword">if</span> (!isValidPointerForActionMove(pointerId)) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">                      <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(i);</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(i);</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</div><div class="line"></div><div class="line">                      reportNewEdgeDrags(dx, dy, pointerId);</div><div class="line">                      <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</div><div class="line">                          <span class="comment">// Callback might have started an edge drag.</span></div><div class="line">                          <span class="keyword">break</span>;</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</div><div class="line">                      <span class="keyword">if</span> (checkTouchSlop(toCapture, dx, dy)</div><div class="line">                              &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</div><div class="line">                          <span class="keyword">break</span>;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">                  saveLastMotion(ev);</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_UP: &#123;</div><div class="line">              <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(actionIndex);</div><div class="line">              <span class="keyword">if</span> (mDragState == STATE_DRAGGING &amp;&amp; pointerId == mActivePointerId) &#123;</div><div class="line">                  <span class="comment">// Try to find another pointer that's still holding on to the captured view.</span></div><div class="line">                  <span class="keyword">int</span> newActivePointer = INVALID_POINTER;</div><div class="line">                  <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = ev.getPointerCount();</div><div class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">int</span> id = ev.getPointerId(i);</div><div class="line">                      <span class="keyword">if</span> (id == mActivePointerId) &#123;</div><div class="line">                          <span class="comment">// This one's going away, skip.</span></div><div class="line">                          <span class="keyword">continue</span>;</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(i);</div><div class="line">                      <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(i);</div><div class="line">                      <span class="keyword">if</span> (findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y) == mCapturedView</div><div class="line">                              &amp;&amp; tryCaptureViewForDrag(mCapturedView, id)) &#123;</div><div class="line">                          newActivePointer = mActivePointerId;</div><div class="line">                          <span class="keyword">break</span>;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  <span class="keyword">if</span> (newActivePointer == INVALID_POINTER) &#123;</div><div class="line">                      <span class="comment">// We didn't find another pointer still touching the view, release it.</span></div><div class="line">                      releaseViewForPointerUp();</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              clearMotionHistory(pointerId);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">              <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</div><div class="line">                  releaseViewForPointerUp();</div><div class="line">              &#125;</div><div class="line">              cancel();</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</div><div class="line">              <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</div><div class="line">                  dispatchViewReleased(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">              &#125;</div><div class="line">              cancel();</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>  这个方法中也是对触摸事件情况的处理,其中的down和up和上面的 <em>shouldInterceptTouchEvent</em> 类似,重点就在 ACTION_MOVE 中,可以发现重点就在 <em>dragTo</em> 方法中:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> clampedX = left;</div><div class="line">     <span class="keyword">int</span> clampedY = top;</div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> oldLeft = mCapturedView.getLeft();</div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> oldTop = mCapturedView.getTop();</div><div class="line">     <span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</div><div class="line">         clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);</div><div class="line">         ViewCompat.offsetLeftAndRight(mCapturedView, clampedX - oldLeft);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</div><div class="line">         clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);</div><div class="line">         ViewCompat.offsetTopAndBottom(mCapturedView, clampedY - oldTop);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">final</span> <span class="keyword">int</span> clampedDx = clampedX - oldLeft;</div><div class="line">         <span class="keyword">final</span> <span class="keyword">int</span> clampedDy = clampedY - oldTop;</div><div class="line">         mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,</div><div class="line">                 clampedDx, clampedDy);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  可以看到,在这里完成了view的位置移动处理.通过 <em>mCallback</em> 中的各个方法来获取移动范围,并且有个 <em>mCallback.onViewPositionChanged</em> 位置移动的回调. 下面讲一下 <em>callback</em> 的用法.</p>
<p>(三) ViewDragHelper.Callback的用法<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Called when the drag state changes. See the &lt;code&gt;STATE_*&lt;/code&gt; constants</div><div class="line">       * for more information.</div><div class="line">       * 当view的拖拽状态改变时触发,对应下面写的三种情况中一种</div><div class="line">       * <span class="doctag">@param</span> state The new drag state</div><div class="line">       *</div><div class="line">       * <span class="doctag">@see</span> #STATE_IDLE 当前没有被拖拽</div><div class="line">       * <span class="doctag">@see</span> #STATE_DRAGGING 正在别拖拽</div><div class="line">       * <span class="doctag">@see</span> #STATE_SETTLING 被拖拽后需要安置到一个位置中的状态</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDragStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Called when the captured view's position changes as the result of a drag or settle.</div><div class="line">       * 当view在拖拽时位置发生变化时触发,对应上面的 dragTo 方法</div><div class="line">       * <span class="doctag">@param</span> changedView View whose position changed</div><div class="line">       * <span class="doctag">@param</span> left New X coordinate of the left edge of the view</div><div class="line">       * <span class="doctag">@param</span> top New Y coordinate of the top edge of the view</div><div class="line">       * <span class="doctag">@param</span> dx Change in X position from the last call</div><div class="line">       * <span class="doctag">@param</span> dy Change in Y position from the last call</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Called when a child view is captured for dragging or settling. The ID of the pointer</div><div class="line">       * currently dragging the captured view is supplied. If activePointerId is</div><div class="line">       * identified as &#123;<span class="doctag">@link</span> #INVALID_POINTER&#125; the capture is programmatic instead of</div><div class="line">       * pointer-initiated.</div><div class="line">       * 当一个view被捕获时触发</div><div class="line">       * <span class="doctag">@param</span> capturedChild Child view that was captured</div><div class="line">       * <span class="doctag">@param</span> activePointerId Pointer id tracking the child capture</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCaptured</span><span class="params">(View capturedChild, <span class="keyword">int</span> activePointerId)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Called when the child view is no longer being actively dragged.</div><div class="line">       * The fling velocity is also supplied, if relevant. The velocity values may</div><div class="line">       * be clamped to system minimums or maximums.</div><div class="line">       * 当拖拽动作释放时触发</div><div class="line">       * &lt;p&gt;Calling code may decide to fling or otherwise release the view to let it</div><div class="line">       * settle into place. It should do so using &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</div><div class="line">       * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;. If the Callback invokes</div><div class="line">       * one of these methods, the ViewDragHelper will enter &#123;<span class="doctag">@link</span> #STATE_SETTLING&#125;</div><div class="line">       * and the view capture will not fully end until it comes to a complete stop.</div><div class="line">       * If neither of these methods is invoked before &lt;code&gt;onViewReleased&lt;/code&gt; returns,</div><div class="line">       * the view will stop in place and the ViewDragHelper will return to</div><div class="line">       * &#123;<span class="doctag">@link</span> #STATE_IDLE&#125;.&lt;/p&gt;</div><div class="line">       *</div><div class="line">       * <span class="doctag">@param</span> releasedChild The captured child view now being released</div><div class="line">       * <span class="doctag">@param</span> xvel X velocity of the pointer as it left the screen in pixels per second.</div><div class="line">       * <span class="doctag">@param</span> yvel Y velocity of the pointer as it left the screen in pixels per second.</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Called when one of the subscribed edges in the parent view has been touched</div><div class="line">       * by the user while no child view is currently captured.</div><div class="line">       * 当触发了viewGroup的边缘时触发</div><div class="line">       * <span class="doctag">@param</span> edgeFlags A combination of edge flags describing the edge(s) currently touched</div><div class="line">       * <span class="doctag">@param</span> pointerId ID of the pointer touching the described edge(s)</div><div class="line">       * <span class="doctag">@see</span> #EDGE_LEFT</div><div class="line">       * <span class="doctag">@see</span> #EDGE_TOP</div><div class="line">       * <span class="doctag">@see</span> #EDGE_RIGHT</div><div class="line">       * <span class="doctag">@see</span> #EDGE_BOTTOM</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEdgeTouched</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Called when the given edge may become locked. This can happen if an edge drag</div><div class="line">       * was preliminarily rejected before beginning, but after &#123;<span class="doctag">@link</span> #onEdgeTouched(int, int)&#125;</div><div class="line">       * was called. This method should return true to lock this edge or false to leave it</div><div class="line">       * unlocked. The default behavior is to leave edges unlocked.</div><div class="line">       * 是否锁定边缘的触摸</div><div class="line">       * <span class="doctag">@param</span> edgeFlags A combination of edge flags describing the edge(s) locked</div><div class="line">       * <span class="doctag">@return</span> true to lock the edge, false to leave it unlocked</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onEdgeLock</span><span class="params">(<span class="keyword">int</span> edgeFlags)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Called when the user has started a deliberate drag away from one</div><div class="line">       * of the subscribed edges in the parent view while no child view is currently captured.</div><div class="line">       * 边缘触摸开始时触发</div><div class="line">       * <span class="doctag">@param</span> edgeFlags A combination of edge flags describing the edge(s) dragged</div><div class="line">       * <span class="doctag">@param</span> pointerId ID of the pointer touching the described edge(s)</div><div class="line">       * <span class="doctag">@see</span> #EDGE_LEFT</div><div class="line">       * <span class="doctag">@see</span> #EDGE_TOP</div><div class="line">       * <span class="doctag">@see</span> #EDGE_RIGHT</div><div class="line">       * <span class="doctag">@see</span> #EDGE_BOTTOM</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEdgeDragStarted</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Called to determine the Z-order of child views.</div><div class="line">       * 在寻找当前的触摸点下的view时会调用这个方法,比如两个子view叠加在一起之后,如果你想获得下面的那个时,可以改写这个方法.</div><div class="line">       * <span class="doctag">@param</span> index the ordered position to query for</div><div class="line">       * <span class="doctag">@return</span> index of the view that should be ordered at position &lt;code&gt;index&lt;/code&gt;</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> index;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Return the magnitude of a draggable child view's horizontal range of motion in pixels.</div><div class="line">       * This method should return 0 for views that cannot move horizontally.</div><div class="line">       * 获取被拖拽view的水平移动范围</div><div class="line">       * <span class="doctag">@param</span> child Child view to check</div><div class="line">       * <span class="doctag">@return</span> range of horizontal motion in pixels</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Return the magnitude of a draggable child view's vertical range of motion in pixels.</div><div class="line">       * This method should return 0 for views that cannot move vertically.</div><div class="line">       * 获取被拖拽view的垂直移动范围</div><div class="line">       * <span class="doctag">@param</span> child Child view to check</div><div class="line">       * <span class="doctag">@return</span> range of vertical motion in pixels</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewVerticalDragRange</span><span class="params">(View child)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Called when the user's input indicates that they want to capture the given child view</div><div class="line">       * with the pointer indicated by pointerId. The callback should return true if the user</div><div class="line">       * is permitted to drag the given view with the indicated pointer.</div><div class="line">       *</div><div class="line">       * &lt;p&gt;ViewDragHelper may call this method multiple times for the same view even if</div><div class="line">       * the view is already captured; this indicates that a new pointer is trying to take</div><div class="line">       * control of the view.&lt;/p&gt;</div><div class="line">       * 尝试捕获当前触摸的view</div><div class="line">       * &lt;p&gt;If this method returns true, a call to &#123;<span class="doctag">@link</span> #onViewCaptured(android.view.View, int)&#125;</div><div class="line">       * will follow if the capture is successful.&lt;/p&gt;</div><div class="line">       *</div><div class="line">       * <span class="doctag">@param</span> child Child the user is attempting to capture</div><div class="line">       * <span class="doctag">@param</span> pointerId ID of the pointer attempting the capture</div><div class="line">       * <span class="doctag">@return</span> true if capture should be allowed, false otherwise</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span></span>;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Restrict the motion of the dragged child view along the horizontal axis.</div><div class="line">       * The default implementation does not allow horizontal motion; the extending</div><div class="line">       * class must override this method and provide the desired clamping.</div><div class="line">       * 限制水平方向的移动范围</div><div class="line">       *</div><div class="line">       * <span class="doctag">@param</span> child Child view being dragged</div><div class="line">       * <span class="doctag">@param</span> left Attempted motion along the X axis</div><div class="line">       * <span class="doctag">@param</span> dx Proposed change in position for left</div><div class="line">       * <span class="doctag">@return</span> The new clamped position for left</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Restrict the motion of the dragged child view along the vertical axis.</div><div class="line">       * The default implementation does not allow vertical motion; the extending</div><div class="line">       * class must override this method and provide the desired clamping.</div><div class="line">       * 限制垂直方向的移动范围</div><div class="line">       *</div><div class="line">       * <span class="doctag">@param</span> child Child view being dragged</div><div class="line">       * <span class="doctag">@param</span> top Attempted motion along the Y axis</div><div class="line">       * <span class="doctag">@param</span> dy Proposed change in position for top</div><div class="line">       * <span class="doctag">@return</span> The new clamped position for top</div><div class="line">       */</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionVertical</span><span class="params">(View child, <span class="keyword">int</span> top, <span class="keyword">int</span> dy)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  ViewDragHelper的内部流程实现就讲完了,有些细节这里就不展开了,感兴趣的同学可以读一下源码.在额外补充ViewDragHelper的常用方法 <em>settleCapturedViewAt</em> :<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">settleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!mReleaseInProgress) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot settleCapturedViewAt outside of a call to "</span></div><div class="line">                   + <span class="string">"Callback#onViewReleased"</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> forceSettleCapturedViewAt(finalLeft, finalTop,</div><div class="line">               (<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</div><div class="line">               (<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>  这个方法,用来直接把拖动的view放在指定的位置上.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">forceSettleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> startLeft = mCapturedView.getLeft();</div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> startTop = mCapturedView.getTop();</div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> dx = finalLeft - startLeft;</div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> dy = finalTop - startTop;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>) &#123;</div><div class="line">         <span class="comment">// Nothing to do. Send callbacks, be done.</span></div><div class="line">         mScroller.abortAnimation();</div><div class="line">         setDragState(STATE_IDLE);</div><div class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);</div><div class="line">     mScroller.startScroll(startLeft, startTop, dx, dy, duration);</div><div class="line"></div><div class="line">     setDragState(STATE_SETTLING);</div><div class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  可以看到这里通过Scroller来完成view的平滑移动的.这个方法 <em>settleCapturedViewAt</em> 在拖动view释放之后让view进入指定位置的时候会非常有用.<br>  注意:一定要在viewGroup调用如下方法来完成view的平滑移动,在调用 <em>settleCapturedViewAt</em> 方法的时候.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.computeScroll();</div><div class="line">    <span class="keyword">if</span> (mDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</div><div class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/15/2017/android view滑动相关/" class="prev">PREV</a><a href="/2017/02/06/2017/读书笔记/&lt;刻意练习&gt;读书笔记/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://pheobusyy.github.io">yanyi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>