<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">android loader相关</h1><h2 class="subtitle">2017-02-15</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#android-loader相关"><span class="toc-number">1.</span> <span class="toc-text">android loader相关</span></a></li></ol></div></div><div class="post-text"><h3 id="android-loader相关"><a href="#android-loader相关" class="headerlink" title="android loader相关"></a>android loader相关</h3><p>今天第一次学习使用loader,由于不想要使用CursorLoader,所以自己实现了一个asyncTaskLoader,结果发现不起作用,根本没有调用callBack的 <em>onLoadFinished</em> 方法.这不科学啊,看这官方示例写的呀.<br><a id="more"></a><br>后来发现忽略了一个关键点,就是在自定义loader的 <em>onStartLoading</em> 方法中,有下面几句话:</p>
<pre><code class="java">@Override protected void onStartLoading() {
        if (mApps != null) {
            // If we currently have a result available, deliver it
            // immediately.
            deliverResult(mApps);
        }

        // Start watching for changes in the app data.
        if (mPackageObserver == null) {
            mPackageObserver = new PackageIntentReceiver(this);
        }

        // Has something interesting in the configuration changed since we
        // last built the app list?
        boolean configChange = mLastConfig.applyNewConfig(getContext().getResources());

        if (takeContentChanged() || mApps == null || configChange) {
            // If the data has changed since the last time it was loaded
            // or is not currently available, start a load.
            forceLoad();
        }
    }
</code></pre>
<p>逻辑也很简单,就是说如果有数据了,直接通过 <em>deliverResult</em> 返回数据,如果没有,强制调用 <em>forceLoad</em> .</p>
<pre><code class="java">public void deliverResult(D data) {
      if (mListener != null) {
          mListener.onLoadComplete(this, data);
      }
  }
</code></pre>
<p>在 <em>deliverResult</em> 中调用了callback的 <em>onLoadFinished</em> 方法.</p>
<pre><code class="java">public void forceLoad() {
      onForceLoad();
  }
  @Override
    protected void onForceLoad() {
        super.onForceLoad();
        cancelLoad();
        mTask = new LoadTask();
        if (DEBUG) Log.v(TAG, &quot;Preparing load: mTask=&quot; + mTask);
        executePendingTask();
    }
</code></pre>
<p>forceLoad方法会调用内部AsyncTask发起请求,内部调用 <em>loadInBackground</em> 完成耗时任务.</p>
<p>那为什么 <em>CursorLoader</em> 不需要复写这一堆东西了,是因为在其内部已经帮我们写好了.<br>下面是 <em>CursorLoader</em> 的 <em>onStartLoading</em> 方法:</p>
<pre><code class="java">@Override
   protected void onStartLoading() {
       if (mCursor != null) {
           deliverResult(mCursor);
       }
       if (takeContentChanged() || mCursor == null) {
           forceLoad();
       }
   }
</code></pre>
<p>对这个方法的处理使我们在第一次使用loader的时候要注意的哦,否者你会发现调用了initloader之后没有反应.</p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>