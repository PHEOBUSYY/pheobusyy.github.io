<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">android view滑动相关</h1><h2 class="subtitle">2017-02-15</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#android-view滑动相关"><span class="toc-number">1.</span> <span class="toc-text">android view滑动相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#view的坐标系"><span class="toc-number">1.1.</span> <span class="toc-text">view的坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scroller的用法"><span class="toc-number">1.2.</span> <span class="toc-text">scroller的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scrollTo-和-scrollBy"><span class="toc-number">1.3.</span> <span class="toc-text">scrollTo 和 scrollBy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#view移动的7个方式"><span class="toc-number">1.4.</span> <span class="toc-text">view移动的7个方式</span></a></li></ol></li></ol></div></div><div class="post-text"><h2 id="android-view滑动相关"><a href="#android-view滑动相关" class="headerlink" title="android view滑动相关"></a>android view滑动相关</h2><p>  在学习ViewDragHelper的过程中,用到了scroller来回弹到制定的位置,同时也很好奇scroller和computeScroll方法的关联,还有就是关于view坐标系一些api的学习等等,这些概念在这里说明一下.<br>  <a id="more"></a></p>
<h3 id="view的坐标系"><a href="#view的坐标系" class="headerlink" title="view的坐标系"></a>view的坐标系</h3><p><img src="images/2017/02/android view坐标系.png" alt="android view坐标"></p>
<p>通过上面的图片可以看的很明白了,getLeft,getRight,getTop,getBottom这四个方法是相对于父类边界的距离<br>在触摸事件中,getRawX,getRawY是当前触发点相对与屏幕的距离<br>而event中的getX,getY是当前触摸点相对于view本身的边界的距离.</p>
<p>这里还有个概念就是view本身的getX,getY不要和这个混淆了.<br>view本身的getX,getY是view的滑动距离加上getLeft</p>
<pre><code class="java">public float getX() {
      return mLeft + getTranslationX();
  }
</code></pre>
<pre><code class="java">public float getY() {
       return mTop + getTranslationY();
}
</code></pre>
<p><img src="images/2017/02/view移动后坐标.png" alt="view移动后坐标"></p>
<h3 id="scroller的用法"><a href="#scroller的用法" class="headerlink" title="scroller的用法"></a>scroller的用法</h3><p>首先要明白,让一个view从A点自己移动到B点并不是scroller做的,scroller本身只是用来负责计算的,也就是在你调用 <em>scroller.startScroll(int startX,int startY ,int distanceX,int distanceY)</em> 这个方法时候,本身只是在计算.</p>
<pre><code class="java">public void startScroll(int startX, int startY, int dx, int dy, int duration) {
       mMode = SCROLL_MODE;
       mFinished = false;
       mDuration = duration;
       mStartTime = AnimationUtils.currentAnimationTimeMillis();
       mStartX = startX;
       mStartY = startY;
       mFinalX = startX + dx;
       mFinalY = startY + dy;
       mDeltaX = dx;
       mDeltaY = dy;
       mDurationReciprocal = 1.0f / (float) mDuration;
   }
</code></pre>
<p>在这个方法里面是没有关于view移动或者刷新的任何相关代码的.那到底scroller是怎么让view发生位移的呢.<br>奥妙就在我们需要在自定义的view中复写 <em>computeScroll</em> 方法.在 <em>computeScroll</em> 方法中通过调用 <em>scroller.computeScrollOffset</em> 方法来获取当前scroller的计算状态,如果该方法返回false,说明scroller仍然在计算,也就是说view可以继续移动还没有移动完成.反之返回ture说明计算完了,也就是这个时候view已经到了制定位置了.这个时候通过对 <em>computeScrollOffset</em> 的返回值判断我们来调用api来对view做真正的移动.</p>
<pre><code class="java">@Override
   public void computeScroll() {
       if (scroller.computeScrollOffset()) {
           scrollTo(scroller.getCurrX(),scroller.getCurrY());
           invalidate();
       }
   }
</code></pre>
<p>可以看到,真正发生让view发生移动是这里的 <em>computeScrollOffset</em> 判断中的 <em>scrollTo</em> ,我们可以通过 scroller.getCurrX 和 getCurrY 来获取到当前计算到的坐标.</p>
<p>那另一个问题就是谁去调用的 <em>computeScroll</em> 方法呢?通过查看view的源码,在view的 <em>draw</em> 方法中可以看到调用了 <em>computeScroll</em> 方法,那这样就很容易明白了,为什么每次在调用 <em>scroller.startScroll</em> 方法之后,要紧接着调用 <em>invalid</em> 方法了.通过 <em>invalid</em> 方法来通知view重绘.然后就会调用 <em>computeScroll</em> 方法了.在这里完成改变view的位置的操作.</p>
<p>再说说什么情况下要用到 <em>scroller</em> ,个人理解就是在对view做滑动操作的时候,当你松开手指需要让view自己滚动到指定的位置的时候,可以交给scroller来完成自动滚动.so,一般要在touch事件的 <em>ACTION_UP</em> 中调用 <em>startScroll</em> 方法,紧接着调用 <em>invalid</em> 方法就可以了.</p>
<h3 id="scrollTo-和-scrollBy"><a href="#scrollTo-和-scrollBy" class="headerlink" title="scrollTo 和 scrollBy"></a>scrollTo 和 scrollBy</h3><p>通过 <em>scrollTo</em> 和 <em>scrollBy</em> 方法来是view发生位移是一种常规方式. 其中 <em>scrollTo</em> 是把view移动的绝对坐标的位置,而 <em>scrollBy</em> 是移动相对的位置.在源码中实际上 <em>scrollBy</em> 调用的就是 <em>scrollTo</em> 方法.</p>
<p>注意:这两个方法移动都是view的内容,如果viewGroup就是其内部的view.</p>
<p>getScrollX 和 getScrollY 方法返回对应的滚动距离,在复位的时候可以用到.</p>
<p>注意:在向右下方移动view的时候,应该传入的是负值的坐标</p>
<h3 id="view移动的7个方式"><a href="#view移动的7个方式" class="headerlink" title="view移动的7个方式"></a>view移动的7个方式</h3><ol>
<li>View.offsetLeftAndRight 和View.offsetTopAndBottom</li>
<li>scrollTo 和 ScrollBy</li>
<li>修改Layout</li>
<li>修改LayoutParams</li>
<li>属性动画</li>
<li>位移动画</li>
</ol>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>