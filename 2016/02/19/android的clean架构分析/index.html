<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">android的clean架构分析</h1><h2 class="subtitle">2016-02-19</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#结构分层"><span class="toc-number">1.</span> <span class="toc-text">结构分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#android程序分层"><span class="toc-number">2.</span> <span class="toc-text">android程序分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#android-clean-architecture-sample-app分析"><span class="toc-number">3.</span> <span class="toc-text">android clean-architecture-sample-app分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序结构"><span class="toc-number">3.1.</span> <span class="toc-text">程序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据流转演示"><span class="toc-number">3.2.</span> <span class="toc-text">数据流转演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-text"><h2 id="结构分层"><a href="#结构分层" class="headerlink" title="结构分层"></a>结构分层</h2><p><img src="/images/2016/02/clean_architecture1.png" alt="  clean-architecture1"></p>
<p>  首先是分层，分层的目的就是为了解耦合，把整个程序根据一定的方式来划分为不同的层次，每个层次相互独立。<br>  在clean-architecture(以下简称clean)中，把程序分为了四层，分别是：</p>
<ul>
<li><p>Frameworks and Drivers:简称UI层，这里是所有具体实现：包括UI,工具类,框架,等等</p>
</li>
<li><p>Interface Adapters:适配层，顾名思义就是用来为上层UI层和下层将要说到的用例层做通讯的，并且把上下两层中对象做相互转化，比如我们底层的数据库表结构和服务器传过来的数据结构不太一致的时候<br>就需要我们做相互的转化来达成数据流动</p>
</li>
<li><p>Use Cases:简称用例层，这一层主要是处理底层的业务对象的，比如数据库的CRUD等操作，网络请求等等</p>
</li>
<li><p>Entities:简称实例层，主要是业务逻辑对象（纯java逻辑对象）</p>
<p>实际上核心分层思想还是将UI和逻辑分离了，这里的UI层和接口适配层实际上就是干这事儿的，常用的实现是通过MVP来完成的，这里的UI层对应view层，Entities对应module层，中间的适配层和用例层对应Presenter层，核心的业务逻辑应该尽量交给纯java来实现，这样的好处是可以不依赖于环境，内部可以通过各种设计模式来重构和迭代等等。同时在分工上也可以根据不同人员的能力来完成不同的层次逻辑。</p>
<a id="more"></a>
<h2 id="android程序分层"><a href="#android程序分层" class="headerlink" title="android程序分层"></a>android程序分层</h2><p><img src="/images/2016/02/clean_architecture_android.png" alt="  clen-architecture-android"></p>
<p>其次是程序的分层，目标是尽量让内层队外层一无所知，也就是所说的狄米特法则（最少知道原则），这样测试的时候可以不依赖与具体的android环境，方便单元测试。<br>为了达成这一目标，在android中分层了3个层次，值得一提的是每个层次都有属于自己的数据模型以达到独立性的目的，在代码中通过一个mapping转化器来转化各层之间的数据对象。这点代价是为了避免各个层之间的数据交叉使用的。三个分层分别是：</p>
</li>
<li><p>Presentation Layer:表现层，在这一层中包含有UI，动画，当前仅仅使用mvp了，你也可以替换为mvvc或者mvc等，在这一层中，activity和fragment仅仅是view视图，<br>没有业务逻辑在里面，仅仅是用来渲染视图用的。</p>
</li>
</ul>
<p><img src="/images/2016/02/clean_architecture_mvp.png" alt="    "></p>
<ul>
<li>Domain Layer:业务层，业务逻辑发成在这个层次里面，在android中你会看到通过inteactors（User Cases）来实现的，在这一层中没有任何关于andorid的代码，都是java模块<br>，任何外部调用这一层都是通过接口来完成的。</li>
</ul>
<p><img src="/images/2016/02/clean_architecture_domain.png" alt="  "></p>
<ul>
<li>Data Layer:数据层，在app中所有需要的数据都在一层中，通过一个叫做UserRepository的工厂来提供数据，<br>内部根据不同的需要来从不同的途径中获取数据，这样外部不用关心内部的具体获取细节。一般的android程序不外乎网络，数据库，sdcard，sp，内层的读取等途径。</li>
</ul>
<p><img src="/images/2016/02/clean_architecture_data.png" alt="    "></p>
<h2 id="android-clean-architecture-sample-app分析"><a href="#android-clean-architecture-sample-app分析" class="headerlink" title="android clean-architecture-sample-app分析"></a>android clean-architecture-sample-app分析</h2><p>  最后，是一个clean架构demo的分析，结合上面的分层介绍来对照程序结构。</p>
<h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><p><img src="/images/2016/02/clean-architecture-demo.png" alt="  "></p>
<p>  首先是核心业务逻辑domain层，里面有用到java写的线程池做异步，封装的interactor对象来做各种业务操作<br>  其次是网络相关，里面通过retrofit+gson来处理网络请求<br>  然后是表现层presentation，里面是mvp的所有逻辑，包括ui，presenter等<br>  再后是数据存储层，storage，里面是所有的数据对象包括数据库的各种操作，里面用到了常用orm框架DBflow<br>  最后是一些辅助的工具类等等。</p>
<h3 id="数据流转演示"><a href="#数据流转演示" class="headerlink" title="数据流转演示"></a>数据流转演示</h3><p>  比如刚开始加载当天的cost数据，在MainActivity中初始化了MainPresenter对象</p>
<pre><code class="java">  mMainPresenter = new MainPresenterImpl(
                ThreadExecutor.getInstance(),
                MainThreadImpl.getInstance(),
                this,
                new CostRepositoryImpl(this)
        );
</code></pre>
<p>  注意看prsenter的构造方法，里面有4个参数，分别对应：<br>  . 线程池<br>  . 主线程对象里面包装了handler<br>  . 回调接口<br>  . 底层存储接口对象<br>  然后是在开始加载数据，通过</p>
<pre><code class="java">  @Override
    protected void onResume() {
        super.onResume();
        mMainPresenter.resume();
    }
</code></pre>
<p>  进入到了prsenter的内部getAllCosts方法</p>
<pre><code class="java">  @Override
  public void getAllCosts() {
      // get all costs
      GetAllCostsInteractor getCostsInteractor = new GetAllCostsInteractorImpl(
              mExecutor,
              mMainThread,
              mCostRepository,
              this
      );
      getCostsInteractor.execute();
  }
</code></pre>
<p>  交给ConstsInteractor来执行，我们来看AbstractInteractor的execute方法</p>
<pre><code class="java">  public void execute() {

      // mark this interactor as running
      this.mIsRunning = true;

      // start running this interactor in a background thread
      mThreadExecutor.execute(this);
  }
</code></pre>
<p>  在这里交给mThreadExecutor方法来执行</p>
<pre><code class="java">  @Override
    public void execute(final AbstractInteractor interactor) {
        mThreadPoolExecutor.submit(new Runnable() {
            @Override
            public void run() {
                // run the main logic
                interactor.run();

                // mark it as finished
                interactor.onFinished();
            }
        });
    }
</code></pre>
<p>  在这里调用了Interactor的run方法，这里的run方法对应每个interactor的具体实现，来看这里GetAllConstsInteractor的run方法实现</p>
<pre><code class="java">  @Override
   public void run() {
       // retrieve the costs from the database
       final List&lt;Cost&gt; costs = mCostRepository.getAllCosts();

       // sort them so the most recent cost items come first, and oldest comes last
       Collections.sort(costs, mCostComparator);

       // Show costs on the main thread
       mMainThread.post(new Runnable() {
           @Override
           public void run() {
               mCallback.onCostsRetrieved(costs);
           }
       });
   }
</code></pre>
<p>  里面完成了获取逻辑，并通过mainThread来回调接口，mainThread的具体实现如下：</p>
<pre><code class="java">  public class MainThreadImpl implements MainThread {

    private static MainThread sMainThread;

    private Handler mHandler;

    private MainThreadImpl() {
        mHandler = new Handler(Looper.getMainLooper());
    }

    @Override
    public void post(Runnable runnable) {
        mHandler.post(runnable);
    }

    public static MainThread getInstance() {
        if (sMainThread == null) {
            sMainThread = new MainThreadImpl();
        }

        return sMainThread;
    }
  }
</code></pre>
<p>  内部维护了主线程的Handler，来回调主线程。</p>
<p>  以上就是demo的具体调用过程，结构还是很简单的，上层mvp，底层交给线程池，通过handler完成回调。<br>  之后作者又改进了下，用到了dagger2，RxJava等框架，这个之后再详细介绍</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" title="Architecting Android…The clean way?" target="_blank" rel="external">Architecting Android…The clean way?</a></p>
<p><a href="http://blog.csdn.net/bboyfeiyu/article/details/44560155" title="一种更清晰的Android架构(译)" target="_blank" rel="external"> 一种更清晰的Android架构(译)</a></p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>