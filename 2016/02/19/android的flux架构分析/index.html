<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">android的flux架构分析</h1><h2 class="subtitle">2016-02-19</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本组成"><span class="toc-number">2.</span> <span class="toc-text">基本组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#android-flux"><span class="toc-number">3.</span> <span class="toc-text">android flux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#android-flux-sample"><span class="toc-number">4.</span> <span class="toc-text">android flux sample</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-text"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>flux是facebook在14年提出的前端框架，旨在从架构层面来解决MVC的在复杂场景下越来越复杂内部逻辑繁重等问题。<br>我们知道在MVC中，通过Controler来控制Modle,view,比如用户点击了view之后，view通知controler，controler来控制model做状态变换，最后再更新view。如图：</p>
<p><img src="/images/2016/02/flux_mvc.png" alt=""></p>
<p>当逻辑比较复杂或者层次比较复杂的时候就会出现下面这种情况</p>
<p><img src="/images/2016/02/flux_mvc_complex.png" alt=""></p>
<p>flux架构就是在这种情况下提出的。<br><a id="more"></a></p>
<h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p><img src="/images/2016/02/flux-arch.png" alt=""></p>
<p>flux主要由四部分组成，分别为:</p>
<blockquote>
<p>dispatcher 事件调度中心，flux的中心枢纽，通过它来通知store来接收不同的action<br>store 有点类是mvc中的model，封装了应用逻辑和数据的交互<br>view  界面UI，根据回调事件从store中获取数据<br>Action 和 ActionsCreator disptcher发送的都是Action，一个普通的pojo对象，在view中通过ActionsCreator调用dispatcher来发送不同的action</p>
</blockquote>
<p>在flux中，所有的数据都是单向流动的，这样的好处是结构清晰，方便调试，找到对应bug</p>
<p><img src="/images/2016/02/flux-simple-f8-diagram-1300w.png" alt=""></p>
<p><img src="/images/2016/02/flux-simple-f8-diagram-explained-1300w.png" alt=""></p>
<h2 id="android-flux"><a href="#android-flux" class="headerlink" title="android flux"></a>android flux</h2><p>在android中，flux的大体实现如下:</p>
<p>在Activity或者Fragment中，点击一个按钮，通过ActionsCreator发送action到对应的store，store中做数据的处理和转化，处理完成后通过回调通知ui来从store中获取数据状态，最后更新UI。整个过程数据流向都是单向的。</p>
<h2 id="android-flux-sample"><a href="#android-flux-sample" class="headerlink" title="android flux sample"></a>android flux sample</h2><p>在本例中，dispatcher内部维护一个store队列，当有ActionsCreator调用dispatcher的时候，挨个遍历队列，通知里面store来接受action，在每个store中接受到action之后，处理数据，之后通过otto回调通知ui更新。</p>
<p>在activity的onCreate中初始化所有的对象</p>
<pre><code class="java">private void initDependencies() {
        dispatcher = Dispatcher.get();
        actionsCreator = ActionsCreator.get(dispatcher);
        store = new MessageStore();
        dispatcher.register(store);
    }
</code></pre>
<p>来看Diapatcher内部实现,维护一个store队列，并且是单例的，一个典型的观察者模式</p>
<pre><code class="java">public class Dispatcher {
    private static Dispatcher instance;
    private final List&lt;Store&gt; stores = new ArrayList&lt;&gt;();

    public static Dispatcher get() {
        if (instance == null) {
            instance = new Dispatcher();
        }
        return instance;
    }

    Dispatcher() {}

    public void register(final Store store) {
        if (!stores.contains(store)) {
            stores.add(store);
        }
    }

    public void unregister(final Store store) {
        stores.remove(store);
    }

    public void dispatch(Action action) {
        post(action);
    }

    private void post(final Action action) {
        for (Store store : stores) {
            store.onAction(action);
        }
    }
}
</code></pre>
<p>再看ActionsCreator,很简单的调用关系，注意这里的sendMessage方法只是一个简单写法，可以根据需求来扩张不同的实现</p>
<pre><code class="java">public class ActionsCreator {

    private static ActionsCreator instance;
    final Dispatcher dispatcher;

    ActionsCreator(Dispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }

    public static ActionsCreator get(Dispatcher dispatcher) {
        if (instance == null) {
            instance = new ActionsCreator(dispatcher);
        }
        return instance;
    }

    public void sendMessage(String message) {
        dispatcher.dispatch(new MessageAction(MessageAction.ACTION_NEW_MESSAGE, message));
    }
}
</code></pre>
<p>然后是store,接收到aciton之后内部通知绑定的UI更新</p>
<pre><code class="java">public abstract class Store {
    private  static final Bus bus = new Bus();

    protected Store() {
    }

    public void register(final Object view) {
        this.bus.register(view);
    }

    public void unregister(final Object view) {
        this.bus.unregister(view);
    }

    void emitStoreChange() {
        this.bus.post(changeEvent());
    }

    public abstract StoreChangeEvent changeEvent();
    public abstract void onAction(Action action);

    public class StoreChangeEvent {}
</code></pre>
<p>这里通过otto来通知Activity中的UI更新</p>
<pre><code class="java">  @Subscribe
  public void onStoreChange(Store.StoreChangeEvent event) {
      render(store);
  }
  private void render(MessageStore store) {
       vMessageView.setText(store.getMessage());
   }
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="http://androidflux.github.io/docs/overview.html#content" title="AndroidFlux一览" target="_blank" rel="external">AndroidFlux</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" title="Flux架构入门教程" target="_blank" rel="external">Flux架构入门教程</a>  </p>
</blockquote>
<blockquote>
<p><a href="http://www.jianshu.com/p/918719151e72" title="Android App框架Flux" target="_blank" rel="external">Android App框架Flux</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://github.com/androidflux/flux" title="demo地址" target="_blank" rel="external">demo地址</a></p>
</blockquote>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>