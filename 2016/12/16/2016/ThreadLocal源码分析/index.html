<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">ThreadLocal源码分析</h1><h2 class="subtitle">2016-12-16</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal源码分析"><span class="toc-number">1.</span> <span class="toc-text">ThreadLocal源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-number">1.1.</span> <span class="toc-text">源码分析</span></a></li></ol></li></ol></div></div><div class="post-text"><h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h2><p>  根据命名可以理解为”线程独有的”变量,也就是说这些变量是与所属线程相对应的,每个线程都有该变量独有的一份拷贝,相互之间是透明的.ThreadLocal实例的典型运用应该是private static的成员变量,比如去获取userId或者Transaction ID.</p>
<p>  ThreadLocal是一种线程安全的区别于锁机制的实现方式,通过线程隔离来完成线程数据之间不互相干扰.</p>
<p>  ThreadLocal使用非常简单,只有4个常用方法,分别是:</p>
<p>  <em>get()</em> :用来获取当前线程中的变量值<br>  <em>set(T value)</em> :用来给当前线程中的变量赋值<br>  <em>remove</em> :用来移除当前线程中的变量值<br>  <em>initialValue()</em> :用来在第一次get没有值得时候做初始化操作,一般是通过复写该方法来完成初始化的</p>
<p>  下面是一个demo代码,用来给每个调用它的线程产生一个唯一ID:</p>
<pre><code class="java">  public class ThreadId {
     // Atomic integer containing the next thread ID to be assigned
     private static final AtomicInteger nextId = new AtomicInteger(0);

     // Thread local variable containing each thread&#39;s ID
     private static final ThreadLocal&lt;Integer&gt; threadId =
         new ThreadLocal&lt;Integer&gt;() {
             @Override protected Integer initialValue() {
                 return nextId.getAndIncrement();
         }
     };

     // Returns the current thread&#39;s unique ID, assigning it if necessary
     public static int get() {
         return threadId.get();
     }
 }
</code></pre>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>  既然不同的线程所包含的变量值不一样,那么内部肯定是有一种类似map的数据结构在做一一对应关系.<br>  构造函数就是一个普通构造函数,我们从 <em>set()</em> 方法开始:</p>
<pre><code class="java">  public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings(&quot;unchecked&quot;)
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
</code></pre>
<p>  首先是获取当前的线程对象,然后调用 <em>getMap</em> 方法返回一个 <em>ThreadLocalMap</em> 对象,再看 <em>getMap</em> 方法:</p>
<pre><code class="java">  ThreadLocalMap getMap(Thread t) {
       return t.threadLocals;
   }
</code></pre>
<p>  说明 <em>ThreadLocalMap</em> 来自于每个线程对象中.不过定义是在ThreadLocal中定义的,从明明商可以看到这个对象就是我们前面猜测的一种具有map性质的数据结构.<br>  其中key就是this也就是当前的ThreadLocal对象本身,value就是我们给ThreadLocal的赋值对象了.如果没有找到 <em>ThreadLocalMap</em> 对象,进入 <em>setInitialValue</em> 方法</p>
<pre><code class="java">  /**
    * Variant of set() to establish initialValue. Used instead
    * of set() in case user has overridden the set() method.
    *
    * @return the initial value
    */
   private T setInitialValue() {
       T value = initialValue();
       Thread t = Thread.currentThread();
       ThreadLocalMap map = getMap(t);
       if (map != null)
           map.set(this, value);
       else
           createMap(t, value);
       return value;
   }
</code></pre>
<p>  在这里就会调用前面说过的4个常用方法之一的 <em>initialValue</em> 方法,用来做初始化赋值.同样,如果map存在就直接赋值,否者进入 <em>createMap</em> 方法</p>
<pre><code class="java">
    /**
     * Create the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param t the current thread
     * @param firstValue value for the initial entry of the map
     */
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }
</code></pre>
<p>  非常简单,给Thread的对象的ThreadLocalMap对象赋值,同时把变量值也赋给ThreadLocalMap.<br>  再看 <em>set</em> 方法,也很简单清晰:</p>
<pre><code class="java">  /**
    * Sets the current thread&#39;s copy of this thread-local variable
    * to the specified value.  Most subclasses will have no need to
    * override this method, relying solely on the {@link #initialValue}
    * method to set the values of thread-locals.
    *
    * @param value the value to be stored in the current thread&#39;s copy of
    *        this thread-local.
    */
   public void set(T value) {
       Thread t = Thread.currentThread();
       ThreadLocalMap map = getMap(t);
       if (map != null)
           map.set(this, value);
       else
           createMap(t, value);
   }
</code></pre>
<p>  4个方法分分钟就讲完了,是不是非常简单,剩余核心其实就是 <em>ThreadLocalMap</em> 的实现方式了,在其内部实现了map类型的数据结构,先来看map中的Entry对象:</p>
<pre><code class="java">  /**
        * The entries in this hash map extend WeakReference, using
        * its main ref field as the key (which is always a
        * ThreadLocal object).  Note that null keys (i.e. entry.get()
        * == null) mean that the key is no longer referenced, so the
        * entry can be expunged from table.  Such entries are referred to
        * as &quot;stale entries&quot; in the code that follows.
        */
       static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
           /** The value associated with this ThreadLocal. */
           Object value;

           Entry(ThreadLocal&lt;?&gt; k, Object v) {
               super(k);
               value = v;
           }
       }
</code></pre>
<p>  可以看到key是 通过弱引用包含的ThreadLocal对象,value就是我们给ThreadLocal的赋值.<br>  下面来看map中的set实现:</p>
<pre><code class="java">  /**
         * Set the value associated with key.
         *
         * @param key the thread local object
         * @param value the value to be set
         */
        private void set(ThreadLocal&lt;?&gt; key, Object value) {

            // We don&#39;t use a fast path as with get() because it is at
            // least as common to use set() to create new entries as
            // it is to replace existing ones, in which case, a fast
            // path would fail more often than not.

            Entry[] tab = table;
            int len = tab.length;
            int i = key.threadLocalHashCode &amp; (len-1);

            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) {
                ThreadLocal&lt;?&gt; k = e.get();

                if (k == key) {
                    e.value = value;
                    return;
                }

                if (k == null) {
                    replaceStaleEntry(key, value, i);
                    return;
                }
            }

            tab[i] = new Entry(key, value);
            int sz = ++size;
            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
                rehash();
        }
</code></pre>
<p>  遍历所有的Entry数组,如果找到key值一样的直接覆盖,如果发现一个key为空的情况,把那个位置的对象更新一下,否者如果刚开始Entry数组对象为空的时候,直接赋值数组的指定位置.这个位置是通过上面的对应hash算法生成的.<br>  map内部的清空无用的值的算法太复杂了,就不介绍了,重点是明白ThreadLocal的原理就可以了.</p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>