<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> EventBus源码解析 · pheobusyy</title><meta name="description" content="EventBus源码解析 - yanyi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://pheobusyy.github.io/atom.xml" title="pheobusyy"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">EventBus源码解析</h1><div class="post-info">Dec 9, 2016</div><div class="post-content"><h2 id="EventBus3-0源码解析"><a href="#EventBus3-0源码解析" class="headerlink" title="EventBus3.0源码解析"></a>EventBus3.0源码解析</h2><p>  使用方法是在工程的任何一个地方都可以通过EventBus对象来post一个Event对象给EventBus，然后在需要处理Event对象的类中register该类来响应处理，那么程序的入口就从EventBus的register方法入手了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">                subscribe(subscriber, subscriberMethod);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到register方法中的核心方法在 <em>subscriberMethodFinder.findSubscriberMethods</em> 来返回所有注册的方法对象<br>那么下一步就进入 <em>subscriberMethodFinder</em> 来查看这个 <em>findSubscriberMethods</em> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</div><div class="line">       <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> subscriberMethods;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</div><div class="line">           subscriberMethods = findUsingReflection(subscriberClass);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           subscriberMethods = findUsingInfo(subscriberClass);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</div><div class="line">                   + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           METHOD_CACHE.put(subscriberClass, subscriberMethods);</div><div class="line">           <span class="keyword">return</span> subscriberMethods;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到 <em>findSubscriberMethods</em> 方法中,关键点就在 <em>findUsingReflection</em> 和 <em>findUsingInfo</em> 这两个方法中.由于 <em>findUsingReflection</em> 的代码比较少,所以先从这个方法开始.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">       FindState findState = prepareFindState();</div><div class="line">       findState.initForSubscriber(subscriberClass);</div><div class="line">       <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">           findUsingReflectionInSingleClass(findState);</div><div class="line">           findState.moveToSuperclass();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里用来存放匹配结果的中间对象叫做 <em>FindState</em> ,稍后具体来说 <em>FindState</em> 的内部实现,现在先看一个生成 <em>FindState</em> 对象的方法 <em>prepareFindState</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</div><div class="line">                FindState state = FIND_STATE_POOL[i];</div><div class="line">                <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">                    FIND_STATE_POOL[i] = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">return</span> state;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FindState();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(findState.subscriberMethods);</div><div class="line">        findState.recycle();</div><div class="line">        <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</div><div class="line">                    FIND_STATE_POOL[i] = findState;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> subscriberMethods;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里 <em>FIND_STATE_POOL</em> 是一个对象池,最大容量4个,可以想象,如果每次都生成一个 <em>findState</em> 的方法的话,会生成很多很多的中间对象,对性能造成影响,所以通过一个对象池来解决大量中间计算对象的问题,首先如果在对象池中找到有对象就直接使用,同时把对象池中的对象置空,最后回收的时候把用完了的对象放入对象池中,达到了循环引用的目的.感觉这个设计非常巧妙.</p>
<p>下一步我们来到 <em>findUsingReflection</em> 方法中的 <em>findUsingReflectionInSingleClass</em> 方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">        Method[] methods;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></div><div class="line">            methods = findState.clazz.getDeclaredMethods();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">            <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></div><div class="line">            methods = findState.clazz.getMethods();</div><div class="line">            findState.skipSuperClasses = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">            <span class="keyword">int</span> modifiers = method.getModifiers();</div><div class="line">            <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</div><div class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">                <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</div><div class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</div><div class="line">                    <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</div><div class="line">                        <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</div><div class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">                            findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</div><div class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                    String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</div><div class="line">                            <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</div><div class="line">                        <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>核心代码在for循环中的第一个if中,其他的是严格模式下返回异常信息.<br>首先取到注册类中的所有的声明方法,然后遍历找到其中是public的并且不是静态,抽象,中间编译器生成的方法,下面是这需要忽略类型的并集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;</div></pre></td></tr></table></figure>
<p>看代码,明确要求注册方法必须只能有一个参数,同时注解必须是Subscribe对象类型,然后获取第一个param的类型,交由 <em>findState.checkAdd(method,eventType)</em> 方法去判断是否需要添加到事件绑定中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">            <span class="comment">// 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span></div><div class="line">            <span class="comment">// Usually a subscriber doesn't have methods listening to the same event type.</span></div><div class="line">            Object existing = anyMethodByEventType.put(eventType, method);</div><div class="line">            <span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</div><div class="line">                    <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</div><div class="line">                        <span class="comment">// Paranoia check</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// Put any non-Method object to "consume" the existing Method</span></div><div class="line">                    anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>通过该方法的注释可以看到,有两层快速判断:第一层是通过eventType来判断,这种比较快,第二层是通过完成的签名来判断;通常情况下一个事件接受类不应该有多个方法对同一种类型的事件进行监听;<br>首先把eventType作为key,method对象作为value放入anyMethodByEventType这个map中,如果返回null说明之前是没有的放过的同样类型的eventType的,如果返回不为Null,说明anyMethodByEventType中已经有了同样的eventType事件监听,就需要更进一步的判断,交给下面的 <em>checkAddWithMethodSignature</em> 方法来处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">           methodKeyBuilder.setLength(<span class="number">0</span>);</div><div class="line">           methodKeyBuilder.append(method.getName());</div><div class="line">           methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</div><div class="line"></div><div class="line">           String methodKey = methodKeyBuilder.toString();</div><div class="line">           Class&lt;?&gt; methodClass = method.getDeclaringClass();</div><div class="line">           Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</div><div class="line">           <span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> || methodClassOld.isAssignableFrom(methodClass)) &#123;</div><div class="line">               <span class="comment">// Only add if not already found in a sub class</span></div><div class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// Revert the put, old class is further down the class hierarchy</span></div><div class="line">               subscriberClassByMethodKey.put(methodKey, methodClassOld);</div><div class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>首先是把方法名+接收参数类型名作为key存入map中,如果之前没有放入过,那么直接把返回true,交给上面的checkAdd返回true,说明事件绑定成功<br>如果已经放入过了,说明有两个同样名称的方法并且监听的居然是同一种eventType,获取方法的声明类class对象,和之前放入的声明class对象做isAssignableFrom判断,如果isAssignableFrom为true,说明已经放入的class是新放入的class本身类或者父类,返回true,可以添加,否则返回false,不可以添加,交给 <em>checkState</em> 方法throw一个异常.为什么会出现这种情况呢?个人思考了下应该是首先子类已经注册了一个subscribe方法对某一eventType做监听,同事父类里面有个同名方法对同样的eventType做监听,那么就会出现到底该绑定哪个方法的问题,这个时候优先绑定子类中同名方法,也就是离继承结构更远的方法,越靠近实现优先放入.</p>
<p>当当前类所有的绑定都完成之后, 通过 <em>findState.moveToSuperclass();</em> 让findState对象的class属性指向当前类的父类继续完成上面的操作,直到没有父类为止.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToSuperclass</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">if</span> (skipSuperClasses) &#123;</div><div class="line">               clazz = <span class="keyword">null</span>;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               clazz = clazz.getSuperclass();</div><div class="line">               String clazzName = clazz.getName();</div><div class="line">               <span class="comment">/** Skip system classes, this just degrades performance. */</span></div><div class="line">               <span class="keyword">if</span> (clazzName.startsWith(<span class="string">"java."</span>) || clazzName.startsWith(<span class="string">"javax."</span>) || clazzName.startsWith(<span class="string">"android."</span>)) &#123;</div><div class="line">                   clazz = <span class="keyword">null</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>这里忽略掉了java和android的公共类,节省性能,系统的类是没有必要继续遍历的.<br>当当前类包括其自定义父类全部都遍历完成后,调用 <em>getMethodsAndRelease(findState)</em> 生成绑定方法的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(findState.subscriberMethods);</div><div class="line">        findState.recycle();</div><div class="line">        <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</div><div class="line">                    FIND_STATE_POOL[i] = findState;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> subscriberMethods;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面的流程是 <em>findUsingReflection</em> 方法的主要实现流程,还记得有两个绑定事件的方法吗?还有一个是 <em>findUsingInfo</em> 通过一个变量开关来开启 <em>ignoreGeneratedIndex</em> ,刚开始么有看懂是啥意思,上网查了下资料发现这个功能是3.0新加的,个人理解有点像 <em>预编译</em> 在编译的时候通过 apt中新增一个AnnotationProcessor来把代码中声明了subscribe的方法提前生成一个index集合,这样可以快速的完成事件的绑定,加快运行速度.</p>
<p>java的annotation如果声明为source的target的时候,可以通过继承一个AbstractProcessor来处理自定义annotation.<br>具体的实现方式这里先不展开了,感兴趣的话可以上网去看下官方说明<a href="http://greenrobot.org/eventbus/documentation/subscriber-index/" title="subscriber-index" target="_blank" rel="external">subscriber-index</a></p>
<p>完成了事件绑定之后,就进入EventBus的核心方法 <em>subscribe</em> 了,通过它来完成一个观察者模式,在post的时候找到事件绑定的方法然后调用它,这样就完成了一个事件从绑定到响应的主流程.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</div><div class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</div><div class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">        if (subscriptions == null) &#123;</div><div class="line">            subscriptions = new CopyOnWriteArrayList&lt;&gt;();</div><div class="line">            subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (subscriptions.contains(newSubscription)) &#123;</div><div class="line">                throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "</div><div class="line">                        + eventType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int size = subscriptions.size();</div><div class="line">        for (int i = 0; i &lt;= size; i++) &#123;</div><div class="line">            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">                subscriptions.add(i, newSubscription);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">        if (subscribedEvents == null) &#123;</div><div class="line">            subscribedEvents = new ArrayList&lt;&gt;();</div><div class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">        &#125;</div><div class="line">        subscribedEvents.add(eventType);</div><div class="line"></div><div class="line">        if (subscriberMethod.sticky) &#123;</div><div class="line">            if (eventInheritance) &#123;</div><div class="line">                // Existing sticky events of all subclasses of eventType have to be considered.</div><div class="line">                // Note: Iterating over all events may be inefficient with lots of sticky events,</div><div class="line">                // thus data structure should be changed to allow a more efficient lookup</div><div class="line">                // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</div><div class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                        Object stickyEvent = entry.getValue();</div><div class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">```  </div><div class="line"></div><div class="line">### subscribe方法</div><div class="line">  当通过register方法获得了绑定事件的集合之后,就需要把注册类和绑定事件结合在一起,这样在post方法调用之后,可以快速的找到哪些类的哪些方法可以响应这次post事件,然后通过method对象的反射方法invoke(Object obj,Object... args)来调用绑定事件的方法.其中第二个参数就是post方法传入的eventType对象,第一个参数是register传入的绑定对象.一般是class对象.</div><div class="line"></div><div class="line">  ```java</div><div class="line">  // Must be called in synchronized block</div><div class="line">   private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</div><div class="line">       Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line">       Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</div><div class="line">       CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">       if (subscriptions == null) &#123;</div><div class="line">           subscriptions = new CopyOnWriteArrayList&lt;&gt;();</div><div class="line">           subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">       &#125; else &#123;</div><div class="line">           if (subscriptions.contains(newSubscription)) &#123;</div><div class="line">               throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "</div><div class="line">                       + eventType);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       int size = subscriptions.size();</div><div class="line">       for (int i = 0; i &lt;= size; i++) &#123;</div><div class="line">           if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">               subscriptions.add(i, newSubscription);</div><div class="line">               break;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">       if (subscribedEvents == null) &#123;</div><div class="line">           subscribedEvents = new ArrayList&lt;&gt;();</div><div class="line">           typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">       &#125;</div><div class="line">       subscribedEvents.add(eventType);</div><div class="line"></div><div class="line">       if (subscriberMethod.sticky) &#123;</div><div class="line">           if (eventInheritance) &#123;</div><div class="line">               // Existing sticky events of all subclasses of eventType have to be considered.</div><div class="line">               // Note: Iterating over all events may be inefficient with lots of sticky events,</div><div class="line">               // thus data structure should be changed to allow a more efficient lookup</div><div class="line">               // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</div><div class="line">               Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">               for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                   Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                   if (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                       Object stickyEvent = entry.getValue();</div><div class="line">                       checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125; else &#123;</div><div class="line">               Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">               checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">  ```  </div><div class="line"></div><div class="line">  抛开该方法最底下的sticky判断那块,代码其实很简单,主要是为两个map完成赋值操作.</div><div class="line">  两个map分别是:</div><div class="line"></div><div class="line">  ```java</div><div class="line">  private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</div></pre></td></tr></table></figure>
<p>  key是eventType,value是所有的绑定该事件的方法对象,可以理解就是触发post的时候,可以通过这个map快速的找到都有哪些方法绑定了该事件,然后通过遍历调用他们</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</div></pre></td></tr></table></figure>
<p>  这个map的key是register传入的对象,value是这个对象内部所有的绑定方法,这个map主要是用来unRegister的时候可以把该对象中所有的绑定方法全部移除,节省时间,提升效率</p>
<p>  当完成两个map的赋值工作之后,时间绑定对应关系就确定了,那么剩下逻辑就是看post方法的相关处理了.</p>
<h3 id="post方法"><a href="#post方法" class="headerlink" title="post方法"></a>post方法</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Posts the given event to the event bus. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">    eventQueue.add(event);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">        postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">            postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 <em>currentPostingThreadState</em>用到了ThreadLocal这种概念,ThreadLocal是指每个线程都有自己的独有变量,线程之间不互相干扰,是线程同步的另一种解决方法.ThreadLocal在第一次获取数据的时候如果没有的话就会调用它自己的initialValue方法,现在是返回一个 <em>PostingThreadState</em> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** For ThreadLocal, much faster to set (and get multiple values). */</span></div><div class="line">   <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div><div class="line">       <span class="keyword">boolean</span> isPosting;</div><div class="line">       <span class="keyword">boolean</span> isMainThread;</div><div class="line">       Subscription subscription;</div><div class="line">       Object event;</div><div class="line">       <span class="keyword">boolean</span> canceled;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其中的 <em>eventQueue</em> 相当于一个事件处理队列,isPosting用来做单条发送的间隔开关,就是每次消化一个事件,isMainThread用来表示是否在主线程发布,对应EventBus的ThreadMode4种模式的处理,后续会讲到.下面进入 <em>postSingleEvent</em> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</div><div class="line">    Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</div><div class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</div><div class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</div><div class="line">            Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</div><div class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面来解释一下 <em>eventInheritance</em> 这个开关,通过字面理解是 “事件继承” ,通过查阅文档说明,解释如下</p>
<blockquote>
<p>默认情况下,EventBus认为绑定事件Event Class是具有继承性的,也就是说绑定了Event Class的父类方法在post Event class的时候也会触发.<br>关闭这项功能,可以加快事件传递的速度.如果关闭的话,大概事件post速度大概会提高20%,如果是复杂的Event继承关系的话,速度会提升大于20%</p>
</blockquote>
<p>默认是开启 <em>事件继承</em> 功能的,所以我们进入 <em>lookupAllEventTypes</em> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</div><div class="line">       <span class="keyword">synchronized</span> (eventTypesCache) &#123;</div><div class="line">           List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</div><div class="line">           <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</div><div class="line">               eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">               Class&lt;?&gt; clazz = eventClass;</div><div class="line">               <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                   eventTypes.add(clazz);</div><div class="line">                   addInterfaces(eventTypes, clazz.getInterfaces());</div><div class="line">                   clazz = clazz.getSuperclass();</div><div class="line">               &#125;</div><div class="line">               eventTypesCache.put(eventClass, eventTypes);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> eventTypes;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Recurses through super interfaces. */</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</div><div class="line">            <span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</div><div class="line">                eventTypes.add(interfaceClass);</div><div class="line">                addInterfaces(eventTypes, interfaceClass.getInterfaces());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过代码很容易理解,获取当前post的Event class的所有父类和接口类,然后放入 <em>eventTypes</em> 集合中,分别发送一次,这样当你post一个事件的时候,相当于该事件对象的所有父类和接口类都post了一次.<br>直观一点举例,比如一个叫CommonEvent的类,父类是BaseEvent,接口是IEvent,那么当你post CommonEvent的时候,所有接受BaseEvent 和IEvent的绑定方法也会触发.</p>
<p>这里为了加快速度,把类的关系链存入了一个集合作为缓存使用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</div><div class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">            <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</div><div class="line">                postingState.event = event;</div><div class="line">                postingState.subscription = subscription;</div><div class="line">                <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">                    aborted = postingState.canceled;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    postingState.event = <span class="keyword">null</span>;</div><div class="line">                    postingState.subscription = <span class="keyword">null</span>;</div><div class="line">                    postingState.canceled = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (aborted) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div></pre></td></tr></table></figure>
<p>下面马上进入post之后的回调处理,首先通过Event找到所有绑定该事件的方法集合,这里返回的是一个 <em>CopyOnWriteArrayList<subscription></subscription></em> ,然后遍历之,逐条调用绑定方法.进入 <em>postToSubscription</em> ,根据ThreadMode来做不同的回调处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">            <span class="keyword">case</span> POSTING:</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MAIN:</div><div class="line">                <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    mainThreadPoster.enqueue(subscription, event);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> BACKGROUND:</div><div class="line">                <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                    backgroundPoster.enqueue(subscription, event);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> ASYNC:</div><div class="line">                asyncPoster.enqueue(subscription, event);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><em>postToSubscription</em> 这个方法就是回调的核心逻辑所在,通过threadMode的不同来对应不同的处理关系.<br>先翻译一下关于ThreadMode的文档说明:</p>
<ol>
<li><p>ThreadMode: POSTING<br>接收者会在与post方法的同一个线程中同步执行,这种方式的开销最小,主要是避免了线程切换,这种模式推荐使用在可以快速完成的简单任务并且不需要阻塞主线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Called in the same thread (default)</span></div><div class="line"><span class="comment">// ThreadMode is optional here</span></div><div class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.POSTING)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageEvent event)</span> </span>&#123;</div><div class="line">    log(event.message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ThreadMode: MAIN<br>接收者会在android的主线程中被调用,如果post的事件是在主线程中,那么这时调用方法会直接被调用和上面的Posting一样,这种模式推荐处理很快并且不会阻塞主线程的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Called in Android UI's main thread</span></div><div class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageEvent event)</span> </span>&#123;</div><div class="line">textField.setText(event.message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ThreadMode: BACKGROUND<br>接收者会在一个后台线程中别调用,如果post事件不是在主线程中,那么调用事件就会直接在post的线程中执行,如果是在主线程中post的话,EventBus会启用一个后台线程来处理所有这类event事件,事件回调应该迅速并且不会阻塞后台线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">// Called in the background thread</span></div><div class="line">  <span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageEvent event)</span></span>&#123;</div><div class="line">      saveToDisk(event.message);</div><div class="line">  &#125;</div><div class="line">  ```  </div><div class="line"><span class="number">4</span>. ThreadMode: ASYNC</div><div class="line">  事件回调会在一个单独的子线程中完成,这种情况下事件回调的线程是独立于主线程和post所在的线程的,是一个单独的线程,事件的post是不会等待回调方法的执行完成与否的,这种模式应该用于事件回调需要执行一段事件,比如网络请求等,要避免触发类似大量的长时间运行的异步线程.EventBus使用一个线程池来管理和回收这种线程.</div><div class="line">  ```java</div><div class="line">  <span class="comment">// Called in a separate thread</span></div><div class="line">  <span class="meta">@Subscribe</span>(threadMode = ThreadMode.ASYNC)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageEvent event)</span></span>&#123;</div><div class="line">      backend.send(event.message);</div><div class="line">  &#125;</div><div class="line">  ```  </div><div class="line">[官方ThreadMode说明][<span class="number">88</span>ce7be7]</div><div class="line"></div><div class="line">  [<span class="number">88</span>ce7be7]: http:<span class="comment">//greenrobot.org/eventbus/documentation/delivery-threads-threadmode/ "官方ThreadMode说明"</span></div><div class="line"></div><div class="line">  看完了官方说明之后,我们再来看代码具体实现,这个时候就已经很清晰了</div><div class="line"></div><div class="line">  ```<span class="function">java</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> &#123;</div><div class="line">       <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">           <span class="keyword">case</span> POSTING:</div><div class="line">               invokeSubscriber(subscription, event);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> MAIN:</div><div class="line">               <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                   invokeSubscriber(subscription, event);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   mainThreadPoster.enqueue(subscription, event);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> BACKGROUND:</div><div class="line">               <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                   backgroundPoster.enqueue(subscription, event);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   invokeSubscriber(subscription, event);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> ASYNC:</div><div class="line">               asyncPoster.enqueue(subscription, event);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>switch对应4中不同的ThreadMode,默认的模式使用的是POSTING,就是post在哪个线程那么回调就在哪个线程中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div><div class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">        handleSubscriberException(subscription, event, e.getCause());</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>invokeSubscriber</em> 方法就是通过反射来回调绑定方法,结果非常简单.</p>
<p>如果是 <em>MAIN</em> 模式下,判断是否在主线程,如果在主线程直接调用,如果在子线程中,通过 <em>mainThreadPoster</em> 来回到主线程中.</p>
<p>来看 <em>mainThreadPoster</em> 的内部实现,实际上就是一个在主线程中的Handler.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</div><div class="line"></div><div class="line">  HandlerPoster(EventBus eventBus, Looper looper, <span class="keyword">int</span> maxMillisInsideHandleMessage) &#123;</div><div class="line">      <span class="keyword">super</span>(looper);</div><div class="line">      <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">      <span class="keyword">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</div><div class="line">      queue = <span class="keyword">new</span> PendingPostQueue();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">      PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">          queue.enqueue(pendingPost);</div><div class="line">          <span class="keyword">if</span> (!handlerActive) &#123;</div><div class="line">              handlerActive = <span class="keyword">true</span>;</div><div class="line">              <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</div><div class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">long</span> started = SystemClock.uptimeMillis();</div><div class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">              PendingPost pendingPost = queue.poll();</div><div class="line">              <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                      <span class="comment">// Check again, this time in synchronized</span></div><div class="line">                      pendingPost = queue.poll();</div><div class="line">                      <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                          handlerActive = <span class="keyword">false</span>;</div><div class="line">                          <span class="keyword">return</span>;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              eventBus.invokeSubscriber(pendingPost);</div><div class="line">              <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</div><div class="line">              <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</div><div class="line">                  <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</div><div class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</div><div class="line">                  &#125;</div><div class="line">                  rescheduled = <span class="keyword">true</span>;</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          handlerActive = rescheduled;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handler内部的handleMessage是一个死循环,每次通过enqueue方法来吧回调事件放入队列中,第一次的情况下发现handlerActive为否,说明没有启动,通过放一个空的message给handleMessage方法来启动死循环,如果已经启动了,handleMessage内部在不断的poll队列中的事件,依次执行回调方法,直到里面没有事件为止.同时在最底下还有个时间差判断,如果执行了十秒还没有执行完成的话,断开循环抛出异常,算是一个复位操作(个人理解)</p>
<p>再看ThreadMode的backGround模式,如果在主线程中,那么就交给backgroundPoster处理,如果在子线程中就直接处理了.来看backgroundPoster的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</div><div class="line"></div><div class="line">  BackgroundPoster(EventBus eventBus) &#123;</div><div class="line">      <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">      queue = <span class="keyword">new</span> PendingPostQueue();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">      PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">          queue.enqueue(pendingPost);</div><div class="line">          <span class="keyword">if</span> (!executorRunning) &#123;</div><div class="line">              executorRunning = <span class="keyword">true</span>;</div><div class="line">              eventBus.getExecutorService().execute(<span class="keyword">this</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">              <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                  PendingPost pendingPost = queue.poll(<span class="number">1000</span>);</div><div class="line">                  <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                          <span class="comment">// Check again, this time in synchronized</span></div><div class="line">                          pendingPost = queue.poll();</div><div class="line">                          <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                              executorRunning = <span class="keyword">false</span>;</div><div class="line">                              <span class="keyword">return</span>;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">                  eventBus.invokeSubscriber(pendingPost);</div><div class="line">              &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">              Log.w(<span class="string">"Event"</span>, Thread.currentThread().getName() + <span class="string">" was interruppted"</span>, e);</div><div class="line">          &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          executorRunning = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>BackgroundPoster</em> 就是一个简单的线程,当触发之后把自己交给EventBus的线程词来调用,自己的run方法内部维护一个死循环,不断从队列里面poll事件,直到没有为止,和上面的mainThreadPoster的做法类似.</p>
<p>最后是ThreadMode的ASYNC模式,直接交给 <em>asyncPoster</em> 来处理了,可以猜想应该也是一个线程只不过是每次触发都是一个新的线程,放入线程池中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line"></div><div class="line">  AsyncPoster(EventBus eventBus) &#123;</div><div class="line">      <span class="keyword">this</span>.eventBus = eventBus;</div><div class="line">      queue = <span class="keyword">new</span> PendingPostQueue();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">      PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">      queue.enqueue(pendingPost);</div><div class="line">      eventBus.getExecutorService().execute(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      PendingPost pendingPost = queue.poll();</div><div class="line">      <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</div><div class="line">      &#125;</div><div class="line">      eventBus.invokeSubscriber(pendingPost);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码非常简单,每次 <em>enqueue</em> 把自己交给线程池去调用.</p>
<p>最后就是注销绑定事件的unregister方法,也很简单,通过map的对应关系,把所有相关的事件移除就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Unregisters the given subscriber from all event classes. */</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">     List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line">     <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">             unsubscribeByEventType(subscriber, eventType);</div><div class="line">         &#125;</div><div class="line">         typesBySubscriber.remove(subscriber);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>还剩余sticky事件的处理,下面重点讲一下<br>sticky事件讲的是当前事件在post的时候还没有相应的绑定事件,当register相应的event的时候就会触发,那么可以想象在register的时候肯定回去存放sticky时间短额地方去查找有没有对应的事件,然后post一下去回调响应.</p>
<p>首先看postSticky方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky</div><div class="line">   * event of an event's type is kept in memory for future access by subscribers using &#123;<span class="doctag">@link</span> Subscribe#sticky()&#125;.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">      <span class="keyword">synchronized</span> (stickyEvents) &#123;</div><div class="line">          stickyEvents.put(event.getClass(), event);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></div><div class="line">      post(event);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>先放入 <em>stickEvents</em> 容器,尝试post一下<br>然后在register的subscribe方法中,遍历stickEvents容器,如果找到了对应的event就post一下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Must be called in synchronized block</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">         <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">             <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></div><div class="line">             <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></div><div class="line">             <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></div><div class="line">             <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></div><div class="line">             Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">             <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                 Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                 <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                     Object stickyEvent = entry.getValue();</div><div class="line">                     checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">             checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>然后看checkPostStickyEventToSubscription方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></div><div class="line">        <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span></div><div class="line">        postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果找到了对应的sticky事件就post到回调方法,非常清晰.</p>
<h3 id="内部集合PendingPostQueue分析"><a href="#内部集合PendingPostQueue分析" class="headerlink" title="内部集合PendingPostQueue分析"></a>内部集合PendingPostQueue分析</h3><p>这里 <em>PendingPostQueue</em> 是一个双端链表的简单实现,链表的好处在于插入和删除的效率要比数组更高,遍历是慢于数组的,这里运用场景就是不断的从里面取最后一个event事件,那么用链表是非常合适的.</p>
<p>##总结<br>EventBus这个库,通过读源码学到了很多东西,其内部构成就是一个简单观察者模式的实现,但是需要明白java的反射原理,多线程处理,以及各种线程同步的知识,受益匪浅.<br>内部代码量也不是很多,核心代码仅仅不到千行却实现了这么小巧方便的代码库,非常高端.</p>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2016/12/09/2016/java基础知识/" class="prev">上一篇</a><a href="/2016/11/28/2016/android instant run原理/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://pheobusyy.github.io">yanyi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>