<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">java design pattern - decorator pattern</h1><h2 class="subtitle">2016-05-28</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#场景"><span class="toc-number">1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰模式"><span class="toc-number">2.</span> <span class="toc-text">装饰模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-text"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#装饰模式">装饰模式</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>   在编程中，经常会遇到要对原来的某个对象进行功能上的扩展，这个时候如果直接在原来的类基础上直接修改的话违反了开闭原则<br>   同时可能会影响到原来的功能。这个时候我们可以通过装饰模式来达到功能上的扩展，而不影响原来的功能。</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>  装饰模式顾名思义就是对一个对象进行装饰（wrap）来达到功能扩展的目的。一般由4个角色来组成，分别为：  </p>
<ul>
<li>Component 要扩展对象的实现接口  </li>
<li>ConcreteComponent 要扩展的具体对象  </li>
<li>Decorator 继承于Component 用来装饰的基础类  </li>
<li><p>ConcreteDecorator 具体的装饰类，根据功能对Decorator中的方法进行扩展  </p>
<p>实现的步骤如下：</p>
</li>
<li>新建Decorator继承或实现于Component</li>
<li>在Decorator中添加一个Component类型的变量</li>
<li>在Decorator的构造函数中传入一个Component对象，来完成上面变量的初始化</li>
<li>在Decorator中实现所有Component中定义的方法，里面调用Component变量中对应的方法</li>
<li>ConcreteDecorator继承Decorator，在里面对需要调整的方法进行复写修改</li>
</ul>
<p><img src="/images/2016/05/decorator_pattern_uml.png" alt="decorator pattern"><br><a id="more"></a><br>  下面是一个简单的demo实现：</p>
<p>  基础接口</p>
<pre><code class="java">  public interface Component {
    void operator();
  }
</code></pre>
<p>  要调整的对象</p>
<pre><code class="java">  public class ConcreteComponent implements Component {
    @Override
    public void operator() {
        System.out.println(&quot;ConcreteComponent operator&quot;);
    }
  }
</code></pre>
<p>  装饰基类</p>
<pre><code class="java">  public class Decorator implements Component {
    private Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operator() {
        this.component.operator();
    }
}
</code></pre>
<p>  具体装饰类A</p>
<pre><code class="java">  public class ConcreteDecoratorA extends Decorator{
    public ConcreteDecoratorA(Component component) {
        super(component);
    }

    @Override
    public void operator() {
        super.operator();
        System.out.println(&quot;ConcreteDecoratorA  operator&quot;);
    }
  }
</code></pre>
<p>  具体装饰类B</p>
<pre><code class="java">  public class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }

    @Override
    public void operator() {
        super.operator();
        System.out.println(&quot;ConcreteDecoratorB operator &quot;);
    }
  }
</code></pre>
<p>  测试类</p>
<pre><code class="java">  public class Test {
    public static void main(String[] args) {
        ConcreteComponent concreteComponent = new ConcreteComponent();
        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);
        ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);
        concreteDecoratorB.operator();
    }
  }
</code></pre>
<p>  输出：</p>
<pre><code class="java">  ConcreteComponent operator
  ConcreteDecoratorA  operator
  ConcreteDecoratorB operator
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  可以看到装饰模式在没有影响以前逻辑的基础上，完成了功能扩展，在java中IO相关的api大量的用到了装饰模式。<br>  同时我们可以发现如果没有Component或者只有一个要调整的ConcreteDecorator的时候装饰模式会退化为一个简单<br>  的继承方式，也就是继承一下要要调整类，在里面复写要扩展的方法。另外，装饰模式我觉得是AOP编程概念的一种具体实现。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.tutorialspoint.com/design_pattern/decorator_pattern.htm" title="Design Patterns - Decorator Pattern" target="_blank" rel="external">Design Patterns - Decorator Pattern</a></p>
<p><a href="https://en.wikipedia.org/wiki/Decorator_pattern" title="Decorator pattern" target="_blank" rel="external">Decorator pattern</a></p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>