<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">java design pattern-memento pattern</h1><h2 class="subtitle">2016-05-26</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#场景"><span class="toc-number">1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#备忘录模式"><span class="toc-number">2.</span> <span class="toc-text">备忘录模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-text"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#备忘录模式">备忘录模式</a></li>
<li><a href="#实现过程">实现过程</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中经常遇到要回退某一个对象状态的场景，比如游戏中在打架前存盘，如果失败了可以回退到之前的状态，又比如执行了错误<br>  操作之后要回退到之前的某一个操作等等，总之就是在之前保存了对象状态，用户后悔了之后可以回滚，一种“后悔药”的感觉<br>  如果不用设计模式直接实现的话，是这个样子的：</p>
<pre><code class="java">  public class NoMementoUse {
   private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public static void main(String[] args) {
        //用来保存状态
        String preState = &quot;&quot;;
        NoMementoUse noMementoUse = new NoMementoUse();
        noMementoUse.setState(&quot;state first&quot;);
        preState = noMementoUse.getState();
        noMementoUse.setState(&quot;state second&quot;);
        //后悔了
        noMementoUse.setState(preState);
        System.out.println(&quot;state=&quot;+noMementoUse.getState());
    }
  }
</code></pre>
<p>  在上面的实现中，通过一个preState来保存状态，后悔了之后把preState回写到对象中，这里有两个问题：一个是暴露了对象中state属性，另一个是如果要实现更复杂的回退<br>  逻辑的话，不好扩展。在这种场景下，可以使用备忘录模式。<br>  <a id="more"></a></p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>  备忘录模式是一种行为模式，是一种具备保存对象之前状态能力的模式。<br>  备忘录模式由三个对象组成：一个是原始对象（originator），一个是备忘对象（memento），一个备忘管理对象（careTaker）。<br>  其中，原始对象就是要需要保存状态的对象，备忘对象是对要保存状态的抽象，备忘管理对象用来管理备忘对象供原始对象使用。</p>
<p><img src="/images/2016/05/memento_pattern_uml_diagram.jpg" alt="memento pattern"></p>
<p>##实现过程<br>  首先是原始对象：</p>
<pre><code class="java">  public class Originator {
    private String state;

    public Memento saveToMemento() {
        return new Memento(state);
    }

    public void restoreFromMemento(Memento memento) {
        this.state = memento.getState();
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
  }
</code></pre>
<p>  通过restoreFromMemento和saveToMemento方法来存放状态和恢复状态。状态对应下面的Memento对象，memento对象内部<br>  可以扩展更复杂的属性和逻辑。</p>
<pre><code class="java">  public class Memento {
    public Memento(String state) {
        this.state = state;
    }

    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
  }
</code></pre>
<p>  然后是状态管理对象；</p>
<pre><code class="java">  public class CareTaker {
    private List&lt;Memento&gt; mementoList = new ArrayList&lt;&gt;();

    public void add(Memento memento) {
        mementoList.add(memento);
    }

    public Memento get(int index) {
        return mementoList.get(index);
    }
  }
</code></pre>
<p>  通过状态管理对象来管理memento，可以实现更复杂的逻辑。</p>
<p>  最后，调用实现：</p>
<pre><code class="java">  public class Test {
    public static void main(String[] args) {
        Originator originator = new Originator();
        CareTaker careTaker = new CareTaker();

        originator.setState(&quot;first state&quot;);
        originator.setState(&quot;second state&quot;);
        careTaker.add(originator.saveToMemento());
        originator.setState(&quot;three state&quot;);
        careTaker.add(originator.saveToMemento());

        originator.restoreFromMemento(careTaker.get(0));
        System.out.println(&quot;state=&quot;+originator.getState());
        originator.restoreFromMemento(careTaker.get(1));
        System.out.println(&quot;state=&quot;+originator.getState());
    }
  }
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   通过上面的实现来看，备忘录模式非常简单，说白了就是一种状态回退机制的实现，把状态的保存和调用交给一个新的<br>   类去处理，达到了解耦的目的。比如在创建页面，如果用户做了一些无效操作之后想回滚的话就可以使用备忘录模式。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.tutorialspoint.com/design_pattern/memento_pattern.htm" title="Design Patterns - Memento Pattern" target="_blank" rel="external">Design Patterns - Memento Pattern</a></p>
<p><a href="https://en.wikipedia.org/wiki/Memento_pattern" title="Memento pattern" target="_blank" rel="external">Memento pattern</a></p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>