<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">java design pattern - Builder pattern</h1><h2 class="subtitle">2016-05-27</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#场景"><span class="toc-number">1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建造者模式"><span class="toc-number">2.</span> <span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象内部builder实现"><span class="toc-number">3.</span> <span class="toc-text">对象内部builder实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-text"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#建造者模式">建造者模式</a></li>
<li><a href="#对象内部builder实现">对象内部builder实现</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在平时我们会遇到复杂对象的构造过程，对象内部的组成部分属于多个或者一个复杂对象的情况，同时又很在意内部组成的组装顺序<br>  这个时候，我们可以使用构造者模式来把对象内部组成的创建和组装来划分开，达到解耦合。同时对外部隐藏了对象内部的具体实现。</p>
<pre><code class="java">  public class GaiFan {
    private String cai;
    private String rice;

    public String getCai() {
        return cai;
    }

    public void setCai(String cai) {
        this.cai = cai;
    }

    public String getRice() {
        return rice;
    }

    public void setRice(String rice) {
        this.rice = rice;
    }

    @Override
    public String toString() {
        return &quot;GaiFan{&quot; +
                &quot;cai=&#39;&quot; + cai + &#39;\&#39;&#39; +
                &quot;, rice=&#39;&quot; + rice + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
</code></pre>
<pre><code class="java">  public class NoUserBuilder {
    public static void main(String[] args) {
        GaiFan gaifan = new GaiFan();
        gaifan.setCai(&quot;宫保鸡丁&quot;);
        gaifan.setRice(&quot;宫保鸡丁米饭&quot;);
        System.out.println(&quot;gaifan=&quot;+gaifan);
        gaifan = new GaiFan();
        gaifan.setCai(&quot;鱼香肉丝&quot;);
        gaifan.setRice(&quot;鱼香肉丝米饭&quot;);
        System.out.println(&quot;gaifan=&quot;+gaifan);
    }
  }
</code></pre>
<p>  在这里我们使用盖饭来表示要构造的对象。盖饭由两个重要部分组成，菜和米饭，在没有使用建造者模式的时候直接创建盖饭对象<br>  同时设置对应的属性，在这里首先是暴露了盖饭内部的做法实现，同时如果菜和米饭的创建十分复杂的时候这里的逻辑会很混乱<br>  再如果要调整盖饭制作顺序的话，这个单独的创建对象显然无法胜任。这个时候我们可以使用建造者模式来帮组我们解决问题。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>  建造者模式是一种对象创建模式，不同于工厂和抽象工厂模式，建造者模式主要着眼于对象的内部组成创建和构造顺序。建造者模式由4个主要角色构成：<br>  要创建的对象（Product），抽象的构造对象（Builder），具体的构造对象（concrete builder），导演类（Derector）。其中Builder抽象定义了对象<br>  的构造顺序，具体的构造对象内部实现具体要构造对象的各个组成的创建，导演类负责根据不同创建者来生成不同的对象。</p>
<p><img src="/images/2016/05/design_pattern_builder.png" alt="builder pattern"><br><a id="more"></a><br>  下面是一个盖饭创建的demo实现：</p>
<p>  抽象的盖饭建造者，定义了盖饭创建过程</p>
<pre><code class="java">  public abstract class GaiFanBuilder {

    public GaiFan gaiFan;

    public abstract void createCai();

    public abstract void createRice();

    public GaiFan getGaiFan(){
        return gaiFan;
    }
  }
</code></pre>
<p>  具体的盖饭创建者继承抽象创建者</p>
<pre><code class="java">  public class GongbaoJidingBuilder extends GaiFanBuilder {
    public GongbaoJidingBuilder() {
        gaiFan = new GaiFan();
    }

    @Override
    public void createCai() {
        gaiFan.setCai(&quot;炒菜 ---- 宫保鸡丁&quot;);
    }

    @Override
    public void createRice() {
        gaiFan.setRice(&quot;米饭  ------ 宫保鸡丁米饭&quot;);
    }
  }
</code></pre>
<pre><code class="java">  public class YuXiangRouSiBuilder extends GaiFanBuilder {
    public YuXiangRouSiBuilder() {
        gaiFan = new GaiFan();
    }

    @Override
    public void createCai() {
        gaiFan.setCai(&quot;炒菜 ---- 鱼香肉丝&quot;);
    }

    @Override
    public void createRice() {
        gaiFan.setRice(&quot;米饭  ------ 普通米饭&quot;);
    }
  }
</code></pre>
<p>  导演类负责构造盖饭的顺序并提供盖饭对象</p>
<pre><code class="java">  public class Director {
    public GaiFan order(GaiFanBuilder gaiFanBuilder) {
        //这里可以调整顺序
        gaiFanBuilder.createCai();
        gaiFanBuilder.createRice();
        return gaiFanBuilder.getGaiFan();
    }
  }
</code></pre>
<p>  测试类</p>
<pre><code class="java">  public class Test {
    public static void main(String[] args) {
        Director director = new Director();
        System.out.println(&quot;gaifan=&quot; + director.order(new YuXiangRouSiBuilder()));
        System.out.println(&quot;gaifan=&quot; + director.order(new GongbaoJidingBuilder()));

    }
  }
</code></pre>
<p>  输出：</p>
<pre><code class="java">  gaifan=GaiFan{cai=&#39;炒菜 ---- 鱼香肉丝&#39;, rice=&#39;米饭  ------ 普通米饭&#39;}
  gaifan=GaiFan{cai=&#39;炒菜 ---- 宫保鸡丁&#39;, rice=&#39;米饭  ------ 宫保鸡丁米饭&#39;}
</code></pre>
<h2 id="对象内部builder实现"><a href="#对象内部builder实现" class="headerlink" title="对象内部builder实现"></a>对象内部builder实现</h2><p>  在平时我们会经常用到的内部builder实现，如果对象内部属性有很多，但是有一部分是可以通过外部赋值，有一部分可以默认定义的话，我们可以把要外部赋值的属性交给内部builder来实现，同时在builder内部完成链式设置属性。这样在一定程度可以精简代码，参看《effect in java》。</p>
<pre><code class="java">  public static class InnerBuilder{
        private String cai;
        private String rice;

        public InnerBuilder setCai(String cai) {
            this.cai = cai;
            return this;
        }


        public InnerBuilder setRice(String rice) {
            this.rice = rice;
            return this;
        }
        public GaiFan build(){
            GaiFan gaiFan = new GaiFan();
            gaiFan.setCai(cai);
            gaiFan.setRice(rice);
            return gaiFan;
        }
    }
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  可以看到，通过builder类来分离了对象组成，通过Director来完成对象组装。这个就是建者模式的核心所在。在要考虑对象各个组成部分的顺序的时候<br>  可以尝试使用创建者模式。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html" title="《JAVA与模式》之建造模式" target="_blank" rel="external">《JAVA与模式》之建造模式</a></p>
<p><a href="http://www.tutorialspoint.com/design_pattern/builder_pattern.htm" title="Design Patterns - Builder Pattern" target="_blank" rel="external">Design Patterns - Builder Pattern</a></p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>