<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">java design pattern - proxy pattern</h1><h2 class="subtitle">2016-06-01</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#场景"><span class="toc-number">1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理模式"><span class="toc-number">2.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代理"><span class="toc-number">3.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-text"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#代理模式">代理模式</a></li>
<li><a href="#动态代理">动态代理</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中，如果要实现AOP编程或者用到要对对象方法的权限控制的时候，可以使用代理模式</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>  代理模式是一种结构化模式，可以通过调用代理类来间接的调用真实对象的方法，同时可以在调用的同时增加一些扩张。<br>  代理模式由3个角色构成：</p>
<ul>
<li>subject 抽象接口</li>
<li>realSubject 真实对象</li>
<li>proxy 代理类</li>
</ul>
<p><img src="/images/2016/06/proxy_pattern_uml.png" alt="proxy pattern"><br><a id="more"></a></p>
<p>  通过uml可以看到，首先是真实对象和代理类都实现subject接口，其次在代理类中有真实对象的引用，当调用proxy的对应方法的时候实际上是调用了<br>  真实对象的方法，同时我们也可以在调用代理的时候新增一些逻辑。<br>  下面是一个示例demo：</p>
<pre><code class="java">public interface Subject {
    void doAction();
}
</code></pre>
<pre><code class="java">public class RealSubject implements Subject {

    @Override
    public void doAction() {
        System.out.println(&quot;RealSubject doAction&quot;);
    }

}
</code></pre>
<pre><code class="java">public class Proxy implements Subject {
    private RealSubject realSubject;

    @Override
    public void doAction() {
        if (realSubject == null) {
            realSubject = new RealSubject();
        }
        //AOP概念的体现
        preAction();
        realSubject.doAction();
        afterAction();
    }

    public void preAction() {
        System.out.println(&quot;preAction!!! &quot;);
    }

    public void afterAction() {
        System.out.println(&quot;afterAction!!!&quot;);
    }
}
</code></pre>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        Proxy proxy = new Proxy();
        proxy.doAction();
    }
}
</code></pre>
<pre><code class="java">preAction!!!
RealSubject doAction
afterAction!!!
</code></pre>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>  上面的代码实现属于静态代理，如果我们要对所有实现类做代理的话每次都新建一个代理类会很费事，所以在java中提出了动态代理的相关api，通过反射来实现动态代理</p>
<p><img src="/images/2016/06/dynamic_proxy_pattern_uml.jpg" alt="dynamic proxy "></p>
<p><img src="/images/2016/06/dynamic_proxy_pattern_uml_2.jpg" alt="dynamic proxy 2"></p>
<p>  首先新的代理类要实现InvocationHandler接口，然后在里面的invoke方法中执行想要的逻辑，最后通过Proxy.newProxyInstance获取想要的接口对象，然后调用接口对象方法</p>
<pre><code class="java">public class DynamicProxy implements InvocationHandler {
    //被代理对象
    private Object object;

    public DynamicProxy(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result;
        System.out.println(&quot;preInvoke !!!&quot;);
        result = method.invoke(object, args);
        System.out.println(&quot;afterInvoke!!!&quot;);
        return result;
    }
}
</code></pre>
<pre><code class="java">RealSubject realSubject = new RealSubject();
DynamicProxy dynamicProxy = new DynamicProxy(realSubject);

Subject subject = (Subject) java.lang.reflect.Proxy.newProxyInstance(realSubject.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), dynamicProxy);
subject.doAction();
</code></pre>
<pre><code class="java">preInvoke !!!
RealSubject doAction
afterInvoke!!!
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/liangbinny/article/details/18656791" title="java设计模式之代理模式(Proxy)" target="_blank" rel="external">java设计模式之代理模式(Proxy)</a></p>
<p><a href="http://haolloyin.blog.51cto.com/1177454/333257/" title="（Dynamic Proxy）动态代理模式的Java实现" target="_blank" rel="external">（Dynamic Proxy）动态代理模式的Java实现</a></p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>