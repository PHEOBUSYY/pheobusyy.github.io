<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">java design pattern - flyweight pattern</h1><h2 class="subtitle">2016-06-01</h2></div></div><div class="hero-foot"></div></section><div id="content-outer"><div id="content-inner"><article id="post"><div id="toc"><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#场景"><span class="toc-number">1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#享元模式"><span class="toc-number">2.</span> <span class="toc-text">享元模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-text"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#享元模式">享元模式</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中如果某些对象数目过多会对系统性能造成很大的影响，比如在java中如果只是一味的创建新的对象话，对内存会有很大的压力<br>  这个时候我们可以考虑通过共享数据对象的方法来缓解这一问题，在这里就用到了享元模式。</p>
<p>  下面是正常的没有使用享元模式的demo：</p>
<pre><code class="java">  public class NoUserFlyWeight {
    private String state;

    public NoUserFlyWeight(String state) {
        this.state = state;
    }

    public void operator() {
        System.out.println(&quot;NoUserFlyWeight state =&quot; + state);
    }

    public static void main(String[] args) {
        NoUserFlyWeight noUserFlyWeight = new NoUserFlyWeight(&quot;state1&quot;);
        noUserFlyWeight.operator();
        noUserFlyWeight = new NoUserFlyWeight(&quot;state2&quot;);
        noUserFlyWeight.operator();

        noUserFlyWeight = new NoUserFlyWeight(&quot;state3&quot;);
        noUserFlyWeight.operator();

        noUserFlyWeight = new NoUserFlyWeight(&quot;state1&quot;);
        noUserFlyWeight.operator();

        noUserFlyWeight = new NoUserFlyWeight(&quot;state3&quot;);
        noUserFlyWeight.operator();
    }
  }
</code></pre>
<p>  在这里每次使用noUserFlyWeight的时候都创建了新的对象，对系统性能会有很大的影响，同时不太满足单例的情景，因为需要使用不同状态“state”。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>  享元模式是一样结构化模式，旨在通过共享技术来重复利用相同或相似的对象。比如在java中String字符串是final的，就是通过享元模式来利用相同字符的字符串，在常量池中<br>  共享相同的字符串来达到减少内存的目的。<br>  享元模式里面有两个概念，外部状态和内部状态。<br>  对象要共享的话就涉及到如何归纳那些对象属性可以共享，就是创建出来打大家都一样，这样就可以共享。那些属性不能共享，需要把它转换成外部状态，通过方法调用来实现，也就是从细粒度上来划分对象的属性。可以共享的就内部状态，对外开放通过方法调用就是外部状态。</p>
<p><img src="/images/2016/06/flyweight_pattern_uml.png" alt="flyweight pattern"><br><a id="more"></a><br>  享元模式主要由4类角色构成。</p>
<ul>
<li>Flyweight接口 用来开放外部状态的接口</li>
<li>ConcreteFlyweight 实现类 实现对外状态的具体类</li>
<li>UnSharedFlyweight 实现类 实现非对外状态的具体类</li>
<li><p>FlyweightFactory 工厂类 创建并管理共享对象的工厂类</p>
<p>下面是一个享元模式的简单实现：</p>
<pre><code class="java">public interface FlyWeight {
    /**
     * 外部状态调用方法
     * @param state 外部状态
     */
    void operator(String state);
}
</code></pre>
<pre><code class="java">public class ConcreteFlyWeight implements FlyWeight{
  @Override
  public void operator(String state) {
      System.out.println(&quot;FlyWeight state =&quot;+state);
  }
}
</code></pre>
<p>在享元模式中，最重要的就是用来维护和创建对象的工厂类，它负责对象的共享管理，一般内部维护一个集合，通过条件来查找有没有想要的对象，如果有就返回已经有的<br>没有就创建新的，供下次使用。</p>
<pre><code class="java">public class FlyWeightFactory {
  private HashMap&lt;String, FlyWeight&gt; map = new HashMap&lt;&gt;();

  public FlyWeight get(String key) {
      if (map.containsKey(key)) {
          return map.get(key);
      }
      ConcreteFlyWeight concreteFlyWeight = new ConcreteFlyWeight();
      map.put(key, concreteFlyWeight);
      return concreteFlyWeight;
  }
}
</code></pre>
<pre><code class="java">public class Test {
  private static final String KEY_1 = &quot;1&quot;;
  private static final String KEY_2 = &quot;2&quot;;
  private static final String KEY_3 = &quot;3&quot;;

  public static void main(String[] args) {
      FlyWeightFactory flyWeightFactory = new FlyWeightFactory();
      FlyWeight flyWeight = flyWeightFactory.get(KEY_1);
      flyWeight.operator(&quot;state1&quot;);

      flyWeight = flyWeightFactory.get(KEY_2);
      flyWeight.operator(&quot;state2&quot;);

      flyWeight = flyWeightFactory.get(KEY_3);
      flyWeight.operator(&quot;state3&quot;);

      flyWeight = flyWeightFactory.get(KEY_2);
      flyWeight.operator(&quot;state2&quot;);

      flyWeight = flyWeightFactory.get(KEY_1);
      flyWeight.operator(&quot;state1&quot;);
  }
}
</code></pre>
<p>输出：</p>
<pre><code class="java">FlyWeight state =state1
FlyWeight state =state3
FlyWeight state =state2
FlyWeight state =state1
</code></pre>
<p>通过test的调用，我们实际上使用了3个对象，其中state1和state2共享了两次。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>享元模式是一种共享对象的设计模式，在遇到需要大量重复创建对象的时候可以考虑使用，只要对对象内部状态和外部状态做良好的划分就可以了，我的理解是<br>不影响对象内部属性的可以设计为外部状态通过flyweight接口声明，从来达到我们想要的目的。享元模式有点像缓存。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://en.wikipedia.org/wiki/Flyweight_pattern" title="Flyweight pattern" target="_blank" rel="external">Flyweight pattern</a></p>
<p><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" title="《JAVA与模式》之享元模式" target="_blank" rel="external">《JAVA与模式》之享元模式</a></p>
</div></article><div></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>