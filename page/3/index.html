<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="欢迎来到JustinYan的个人blog" type="application/atom+xml" />






<meta name="description" content="JustinYan的个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="欢迎来到JustinYan的个人blog">
<meta property="og:url" content="http://pheobusyy.github.io/page/3/index.html">
<meta property="og:site_name" content="欢迎来到JustinYan的个人blog">
<meta property="og:description" content="JustinYan的个人blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欢迎来到JustinYan的个人blog">
<meta name="twitter:description" content="JustinYan的个人blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pheobusyy.github.io/page/3/"/>





  <title>欢迎来到JustinYan的个人blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">欢迎来到JustinYan的个人blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">永远不要因为你觉得某个目标无法实现就否决它-《原则》</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/02/21/2017/android binder与aidl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/21/2017/android binder与aidl/" itemprop="url">android binder与AIDL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-21T15:59:00+08:00">
                2017-02-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="android-binder与AIDL"><a href="#android-binder与AIDL" class="headerlink" title="android binder与AIDL"></a>android binder与AIDL</h2><p>  最近重新研究了一下Activity启动流程,里面主要提到了ActivityManagerService这个类来管理Activity的生命周期,而如何和这个类通讯成为了理解Activity启动流程的关键,而实现与ActivityManagerService通讯的基础就是今天要讲到的Binder知识.</p>
<p>  我们知道你通过Luncher点击app图标来启动响应的app的时候,实际上就是相当于在Luncher这个app中取启动另一个app,也就是两个app的通讯,并且这两个app分属于不同的 <em>线程</em> ,在android两个不同线程的通讯有个统一的说法叫做 <em>IPC(inter-process connection)</em> .我们可以想象一下如果你要让两个陌生人之间互相认识,是不是需要一个中间人,那么在这里的进程就好比两个陌生人,而中间人就是我们这里的IPC,binder机制是IPC的一种实现方式.</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/21/2017/android binder与aidl/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/02/17/2017/Android LruMemoryCache源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/17/2017/Android LruMemoryCache源码分析/" itemprop="url">Android LruMemoryCache源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-17T14:45:00+08:00">
                2017-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="Android-LruMemoryCache源码分析"><a href="#Android-LruMemoryCache源码分析" class="headerlink" title="Android LruMemoryCache源码分析"></a>Android LruMemoryCache源码分析</h2><p>  在分析Univeral Image Loader的时候看到里面的缓存实现很不错.其中的内存缓存使用的是它自己写的 <em>LruMemoryCache</em> ,文件缓存使用的是 <em>DiskLruCache</em> ,其中的 <em>DiskLruCache</em> 的源码已经分析完了,下面简单讲下 <em>LruMemoryCache</em> 的实现.<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/17/2017/Android LruMemoryCache源码分析/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/02/17/2017/android DiskLruCache源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/17/2017/android DiskLruCache源码分析/" itemprop="url">android DiskLruCache源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-17T10:02:00+08:00">
                2017-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="adroid-DiskLruCache源码分析"><a href="#adroid-DiskLruCache源码分析" class="headerlink" title="adroid DiskLruCache源码分析"></a>adroid DiskLruCache源码分析</h2><p>  在学习Universal image loader源码的时候,看到了它在用到本地文件缓存的时候使用的是 <em>DiskLruCache</em> ,所有抽时间来分析下 <em>DiskLruCache</em> 的源码,来看下为什么它支持类似于 <em>LruCache</em> 功能,内部是怎么实现的.顺便再查看源码过程中了解下它的大概用法.</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/17/2017/android DiskLruCache源码分析/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/02/15/2017/android loader相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/15/2017/android loader相关/" itemprop="url">android loader相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-15T14:16:00+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="android-loader相关"><a href="#android-loader相关" class="headerlink" title="android loader相关"></a>android loader相关</h3><p>今天第一次学习使用loader,由于不想要使用CursorLoader,所以自己实现了一个asyncTaskLoader,结果发现不起作用,根本没有调用callBack的 <em>onLoadFinished</em> 方法.这不科学啊,看这官方示例写的呀.<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/15/2017/android loader相关/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/02/15/2017/android view滑动相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/15/2017/android view滑动相关/" itemprop="url">android view滑动相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-15T13:50:00+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="android-view滑动相关"><a href="#android-view滑动相关" class="headerlink" title="android view滑动相关"></a>android view滑动相关</h2><p>  在学习ViewDragHelper的过程中,用到了scroller来回弹到制定的位置,同时也很好奇scroller和computeScroll方法的关联,还有就是关于view坐标系一些api的学习等等,这些概念在这里说明一下.<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/15/2017/android view滑动相关/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/02/09/2017/ViewDragHelper源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/09/2017/ViewDragHelper源码分析/" itemprop="url">ViewDragHelper源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-09T16:25:00+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ViewDragHelper源码分析"><a href="#ViewDragHelper源码分析" class="headerlink" title="ViewDragHelper源码分析"></a>ViewDragHelper源码分析</h2><p>在学习第三方的一个开源库的时候,发现了系统居然已为viewGroup控制的子view的手势移动提供了相关的组件,就是今天要介绍的 <em>ViewDragHelper</em> ,看了一下发现功能非常的强大,基本满足了我们平时的使用要求,首先我们先讲解一下它的用法,然后再从源码层面来分析一下它的实现思路.</p>
<h3 id="ViewDragHelper的用法"><a href="#ViewDragHelper的用法" class="headerlink" title="ViewDragHelper的用法"></a>ViewDragHelper的用法</h3><p>先通过一个简单的demo来看一下ViewDragHelper的用法:</p>
<pre><code class="java">public class TestDragLayout extends LinearLayout {

    private ViewDragHelper mViewDragHelper;

    private View mDragView;

    public TestDragLayout(Context context) {
        this(context, null);
    }

    public TestDragLayout(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public TestDragLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private void init() {
        mViewDragHelper = ViewDragHelper.create(this, 1f, new ViewDragCallBack());
    }

    private class ViewDragCallBack extends ViewDragHelper.Callback {

        @Override
        public boolean tryCaptureView(View child, int pointerId) {
            return mDragView.getId() == child.getId();
        }

        /**
         * 处理水平方向上的拖动
         *
         * @param child 拖动的View
         * @param left  移动到x轴的距离
         * @param dx    建议的移动的x距离
         */
        @Override
        public int clampViewPositionHorizontal(View child, int left, int dx) {
            //两个if主要是让view在ViewGroup中
            if (left &lt; getPaddingLeft()) {
                return getPaddingLeft();
            }

            if (left &gt; getWidth() - child.getMeasuredWidth()) {
                return getWidth() - child.getMeasuredWidth();
            }
            return left;
        }

        @Override
        public int clampViewPositionVertical(View child, int top, int dy) {
            if (top &lt; getPaddingTop()) {
                return getPaddingTop();
            }

            if (top &gt; getHeight() - child.getMeasuredHeight()) {
                return getHeight() - child.getMeasuredHeight();
            }

            return top;
        }

    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        return mViewDragHelper.shouldInterceptTouchEvent(ev);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        mViewDragHelper.processTouchEvent(event);
        return true;
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mDragView = findViewById(R.id.dragview);
    }
}
</code></pre>
<p>我们先继承一个LinearLayout,然后在构造函数中调用 <em>init</em> 方法,在里面创建 <em>ViewDragHelper</em> 实例.然后在LinearLayout里面放入一个view,这个view就是我们要拖动的mDragView.运行程序,可以看到在布局中的view是可以在里面随便拖动的,同时也不会被拖出边界外面.是不是很简单呢?下面来分析一下使用方法:</p>
<p>使用ViewDragHelper需要三个步骤:</p>
<ol>
<li>创建ViewDragHelper实例</li>
<li>触摸相关的方法调用,主要包括 <em>shouldInterceptTouchEvent(MotionEvent ev)</em> <em>processTouchEvent(MotionEvent ev)</em> 这两个方法</li>
<li>ViewDragHelper.Callback实例的编写,用来完成各种事件的回调</li>
</ol>
<p>(一) 创建ViewDragHelper实例<br>  ViewDragHelper提供了两个创建方法,分别对应:</p>
<pre><code class="java">  public static ViewDragHelper create(ViewGroup forParent, Callback cb) {
       return new ViewDragHelper(forParent.getContext(), forParent, cb);
   }
</code></pre>
<pre><code class="java">  public static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {
      final ViewDragHelper helper = create(forParent, cb);
      helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity));
      return helper;
  }
</code></pre>
<p>  两个方法的区别在于第二个方法提供了一个 <em>sensitivity</em> 参数,这个参数用来表示拖动触发的灵敏度,越大便是越灵敏.因为这里 <em>helper.mTouchSlop</em> 是通过 <em>ViewConfiguration</em> 来获得当前设备的最小的触发距离的,距离越小表示越灵敏.</p>
<pre><code class="java">  private ViewDragHelper(Context context, ViewGroup forParent, Callback cb) {
       if (forParent == null) {
           throw new IllegalArgumentException(&quot;Parent view may not be null&quot;);
       }
       if (cb == null) {
           throw new IllegalArgumentException(&quot;Callback may not be null&quot;);
       }

       mParentView = forParent;
       mCallback = cb;

       final ViewConfiguration vc = ViewConfiguration.get(context);
       final float density = context.getResources().getDisplayMetrics().density;
       mEdgeSize = (int) (EDGE_SIZE * density + 0.5f);

       mTouchSlop = vc.getScaledTouchSlop();
       mMaxVelocity = vc.getScaledMaximumFlingVelocity();
       mMinVelocity = vc.getScaledMinimumFlingVelocity();
       mScroller = ScrollerCompat.create(context, sInterpolator);
   }
</code></pre>
<p>(二) 触摸相关方法调用<br>  可以看到在继承的LinearLayout中,我们复写了两个触摸事件相关的方法:</p>
<pre><code class="java">    @Override
     public boolean onInterceptTouchEvent(MotionEvent ev) {
         return mViewDragHelper.shouldInterceptTouchEvent(ev);
     }
</code></pre>
<pre><code class="java">     @Override
     public boolean onTouchEvent(MotionEvent event) {
         mViewDragHelper.processTouchEvent(event);
         return true;
     }
</code></pre>
<p>  首先触摸事件会触发 <em>onInterceptTouchEvent</em> 如果该方法返回true,则表明当前的viewGroup要拦截该触摸事件,那么触摸事件就不会传递给下层的子类view.而是交由自己的 <em>onTouchEvent</em> 方法来处理. 而如果 <em>onInterceptTouchEvent</em> 方法返回false,则事件会传递给子类的 <em>onTouchEvent</em> 方法,如果子类view的 <em>onTouchEvent</em> 什么都没做返回false的话,事件会再次回到viewGroup的 <em>onTouchEvent</em> 方法来处理,反之事件被成功消化,不会回到上层的viewGroup了.这是android触摸事件的传递流程.还有一个 <em>dispatchTouchEvent</em> 方法来决定是否要分发触摸事件,事件的传递会先进入这个方法,然后在这个方法中通过判断 <em>onInterceptTouchEvent</em> 来决定是否要分发事件.</p>
<p>  回头来看这里的用到的触摸回调方法,先是在 <em>onInterceptTouchEvent</em> 方法,通过 <em>mViewDragHelper.shouldInterceptTouchEvent(ev)</em> 来决定是否分发事件给子view,如果这里返回true,就会进入 <em>onTouchEvent</em> 在里面调用 <em>mViewDragHelper.processTouchEvent(event)</em> 这个方法就是用来移动view的核心方法了.</p>
<p>  我们先来看 <em>shouldInterceptTouchEvent</em> 方法:</p>
<pre><code class="java">  public boolean shouldInterceptTouchEvent(MotionEvent ev) {
        final int action = MotionEventCompat.getActionMasked(ev);
        final int actionIndex = MotionEventCompat.getActionIndex(ev);

        if (action == MotionEvent.ACTION_DOWN) {
            // Reset things for a new event stream, just in case we didn&#39;t get
            // the whole previous stream.
            cancel();
        }

        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        mVelocityTracker.addMovement(ev);

        switch (action) {
            case MotionEvent.ACTION_DOWN: {
                final float x = ev.getX();
                final float y = ev.getY();
                final int pointerId = ev.getPointerId(0);
                saveInitialMotion(x, y, pointerId);

                final View toCapture = findTopChildUnder((int) x, (int) y);

                // Catch a settling view if possible.
                if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) {
                    tryCaptureViewForDrag(toCapture, pointerId);
                }

                final int edgesTouched = mInitialEdgesTouched[pointerId];
                if ((edgesTouched &amp; mTrackingEdges) != 0) {
                    mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);
                }
                break;
            }

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int pointerId = ev.getPointerId(actionIndex);
                final float x = ev.getX(actionIndex);
                final float y = ev.getY(actionIndex);

                saveInitialMotion(x, y, pointerId);

                // A ViewDragHelper can only manipulate one view at a time.
                if (mDragState == STATE_IDLE) {
                    final int edgesTouched = mInitialEdgesTouched[pointerId];
                    if ((edgesTouched &amp; mTrackingEdges) != 0) {
                        mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);
                    }
                } else if (mDragState == STATE_SETTLING) {
                    // Catch a settling view if possible.
                    final View toCapture = findTopChildUnder((int) x, (int) y);
                    if (toCapture == mCapturedView) {
                        tryCaptureViewForDrag(toCapture, pointerId);
                    }
                }
                break;
            }

            case MotionEvent.ACTION_MOVE: {
                if (mInitialMotionX == null || mInitialMotionY == null) break;

                // First to cross a touch slop over a draggable view wins. Also report edge drags.
                final int pointerCount = ev.getPointerCount();
                for (int i = 0; i &lt; pointerCount; i++) {
                    final int pointerId = ev.getPointerId(i);

                    // If pointer is invalid then skip the ACTION_MOVE.
                    if (!isValidPointerForActionMove(pointerId)) continue;

                    final float x = ev.getX(i);
                    final float y = ev.getY(i);
                    final float dx = x - mInitialMotionX[pointerId];
                    final float dy = y - mInitialMotionY[pointerId];

                    final View toCapture = findTopChildUnder((int) x, (int) y);
                    final boolean pastSlop = toCapture != null &amp;&amp; checkTouchSlop(toCapture, dx, dy);
                    if (pastSlop) {
                        // check the callback&#39;s
                        // getView[Horizontal|Vertical]DragRange methods to know
                        // if you can move at all along an axis, then see if it
                        // would clamp to the same value. If you can&#39;t move at
                        // all in every dimension with a nonzero range, bail.
                        final int oldLeft = toCapture.getLeft();
                        final int targetLeft = oldLeft + (int) dx;
                        final int newLeft = mCallback.clampViewPositionHorizontal(toCapture,
                                targetLeft, (int) dx);
                        final int oldTop = toCapture.getTop();
                        final int targetTop = oldTop + (int) dy;
                        final int newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,
                                (int) dy);
                        final int horizontalDragRange = mCallback.getViewHorizontalDragRange(
                                toCapture);
                        final int verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);
                        if ((horizontalDragRange == 0 || horizontalDragRange &gt; 0
                                &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == 0
                                || verticalDragRange &gt; 0 &amp;&amp; newTop == oldTop)) {
                            break;
                        }
                    }
                    reportNewEdgeDrags(dx, dy, pointerId);
                    if (mDragState == STATE_DRAGGING) {
                        // Callback might have started an edge drag
                        break;
                    }

                    if (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) {
                        break;
                    }
                }
                saveLastMotion(ev);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP: {
                final int pointerId = ev.getPointerId(actionIndex);
                clearMotionHistory(pointerId);
                break;
            }

            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL: {
                cancel();
                break;
            }
        }

        return mDragState == STATE_DRAGGING;
  }
</code></pre>
<p>  可以看到里面还是对触摸事件的那几种基本的类型分别做处理,我们知道事件的触发类型对应: ACTION_DOWN –&gt; ACTION_MOVE –&gt; ACTION_MOVE –&gt; ACTION_UP .同时这里加入了对多点触摸的处理.在上面的 ACTION_DOWN 的判断中,如果当前通过 <em>findTopChildUnder</em> 捕获的view就是之前的移动的view,并且处于释放状态,就重新捕获该view并调整状态.这种情况对应快速拖动之后松开后view会自己滑动一些距离的情况.第一次拖动的时候不会触发.</p>
<p>  下面进入 ACTION_MOVE ,在这里看到顺序获取多个触摸点,如果有没有越界,如果没有问题的话就会 调用 <em>tryCaptureViewForDrag</em> 来捕获要滑动的view,并求改其状态.</p>
<pre><code class="java">  boolean tryCaptureViewForDrag(View toCapture, int pointerId) {
         if (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) {
             // Already done!
             return true;
         }
         if (toCapture != null &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) {
             mActivePointerId = pointerId;
             captureChildView(toCapture, pointerId);
             return true;
         }
         return false;
     }
</code></pre>
<p>  该方法又会调用 <em>captureChildView</em> 方法:</p>
<pre><code class="java">  public void captureChildView(View childView, int activePointerId) {
       if (childView.getParent() != mParentView) {
           throw new IllegalArgumentException(&quot;captureChildView: parameter must be a descendant &quot;
                   + &quot;of the ViewDragHelper&#39;s tracked parent view (&quot; + mParentView + &quot;)&quot;);
       }

       mCapturedView = childView;
       mActivePointerId = activePointerId;
       mCallback.onViewCaptured(childView, activePointerId);
       setDragState(STATE_DRAGGING);
   }
</code></pre>
<p>  在这个方法中最后修改view的状态为 <em>STATE_DRAGGING</em> .回到上面的 <em>shouldInterceptTouchEvent</em> 看最后一行的返回条件判断 <em>return mDragState == STATE_DRAGGING;</em> 正好对应这里的修改状态.也就是说当我们手势移动的时候,这里就会认为我们在移动触摸点下面的view,并返回true,方法调用就会进入下面要将的 <em>processTouchEvent</em> 方法了.</p>
<pre><code class="java">  public void processTouchEvent(MotionEvent ev) {
        final int action = MotionEventCompat.getActionMasked(ev);
        final int actionIndex = MotionEventCompat.getActionIndex(ev);

        if (action == MotionEvent.ACTION_DOWN) {
            // Reset things for a new event stream, just in case we didn&#39;t get
            // the whole previous stream.
            cancel();
        }

        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        mVelocityTracker.addMovement(ev);

        switch (action) {
            case MotionEvent.ACTION_DOWN: {
                final float x = ev.getX();
                final float y = ev.getY();
                final int pointerId = ev.getPointerId(0);
                final View toCapture = findTopChildUnder((int) x, (int) y);

                saveInitialMotion(x, y, pointerId);

                // Since the parent is already directly processing this touch event,
                // there is no reason to delay for a slop before dragging.
                // Start immediately if possible.
                tryCaptureViewForDrag(toCapture, pointerId);

                final int edgesTouched = mInitialEdgesTouched[pointerId];
                if ((edgesTouched &amp; mTrackingEdges) != 0) {
                    mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);
                }
                break;
            }

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int pointerId = ev.getPointerId(actionIndex);
                final float x = ev.getX(actionIndex);
                final float y = ev.getY(actionIndex);

                saveInitialMotion(x, y, pointerId);

                // A ViewDragHelper can only manipulate one view at a time.
                if (mDragState == STATE_IDLE) {
                    // If we&#39;re idle we can do anything! Treat it like a normal down event.

                    final View toCapture = findTopChildUnder((int) x, (int) y);
                    tryCaptureViewForDrag(toCapture, pointerId);

                    final int edgesTouched = mInitialEdgesTouched[pointerId];
                    if ((edgesTouched &amp; mTrackingEdges) != 0) {
                        mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);
                    }
                } else if (isCapturedViewUnder((int) x, (int) y)) {
                    // We&#39;re still tracking a captured view. If the same view is under this
                    // point, we&#39;ll swap to controlling it with this pointer instead.
                    // (This will still work if we&#39;re &quot;catching&quot; a settling view.)

                    tryCaptureViewForDrag(mCapturedView, pointerId);
                }
                break;
            }

            case MotionEvent.ACTION_MOVE: {
                if (mDragState == STATE_DRAGGING) {
                    // If pointer is invalid then skip the ACTION_MOVE.
                    if (!isValidPointerForActionMove(mActivePointerId)) break;

                    final int index = ev.findPointerIndex(mActivePointerId);
                    final float x = ev.getX(index);
                    final float y = ev.getY(index);
                    final int idx = (int) (x - mLastMotionX[mActivePointerId]);
                    final int idy = (int) (y - mLastMotionY[mActivePointerId]);

                    dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);

                    saveLastMotion(ev);
                } else {
                    // Check to see if any pointer is now over a draggable view.
                    final int pointerCount = ev.getPointerCount();
                    for (int i = 0; i &lt; pointerCount; i++) {
                        final int pointerId = ev.getPointerId(i);

                        // If pointer is invalid then skip the ACTION_MOVE.
                        if (!isValidPointerForActionMove(pointerId)) continue;

                        final float x = ev.getX(i);
                        final float y = ev.getY(i);
                        final float dx = x - mInitialMotionX[pointerId];
                        final float dy = y - mInitialMotionY[pointerId];

                        reportNewEdgeDrags(dx, dy, pointerId);
                        if (mDragState == STATE_DRAGGING) {
                            // Callback might have started an edge drag.
                            break;
                        }

                        final View toCapture = findTopChildUnder((int) x, (int) y);
                        if (checkTouchSlop(toCapture, dx, dy)
                                &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) {
                            break;
                        }
                    }
                    saveLastMotion(ev);
                }
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP: {
                final int pointerId = ev.getPointerId(actionIndex);
                if (mDragState == STATE_DRAGGING &amp;&amp; pointerId == mActivePointerId) {
                    // Try to find another pointer that&#39;s still holding on to the captured view.
                    int newActivePointer = INVALID_POINTER;
                    final int pointerCount = ev.getPointerCount();
                    for (int i = 0; i &lt; pointerCount; i++) {
                        final int id = ev.getPointerId(i);
                        if (id == mActivePointerId) {
                            // This one&#39;s going away, skip.
                            continue;
                        }

                        final float x = ev.getX(i);
                        final float y = ev.getY(i);
                        if (findTopChildUnder((int) x, (int) y) == mCapturedView
                                &amp;&amp; tryCaptureViewForDrag(mCapturedView, id)) {
                            newActivePointer = mActivePointerId;
                            break;
                        }
                    }

                    if (newActivePointer == INVALID_POINTER) {
                        // We didn&#39;t find another pointer still touching the view, release it.
                        releaseViewForPointerUp();
                    }
                }
                clearMotionHistory(pointerId);
                break;
            }

            case MotionEvent.ACTION_UP: {
                if (mDragState == STATE_DRAGGING) {
                    releaseViewForPointerUp();
                }
                cancel();
                break;
            }

            case MotionEvent.ACTION_CANCEL: {
                if (mDragState == STATE_DRAGGING) {
                    dispatchViewReleased(0, 0);
                }
                cancel();
                break;
            }
        }
    }
</code></pre>
<p>  这个方法中也是对触摸事件情况的处理,其中的down和up和上面的 <em>shouldInterceptTouchEvent</em> 类似,重点就在 ACTION_MOVE 中,可以发现重点就在 <em>dragTo</em> 方法中:</p>
<pre><code class="java">  private void dragTo(int left, int top, int dx, int dy) {
       int clampedX = left;
       int clampedY = top;
       final int oldLeft = mCapturedView.getLeft();
       final int oldTop = mCapturedView.getTop();
       if (dx != 0) {
           clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);
           ViewCompat.offsetLeftAndRight(mCapturedView, clampedX - oldLeft);
       }
       if (dy != 0) {
           clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);
           ViewCompat.offsetTopAndBottom(mCapturedView, clampedY - oldTop);
       }

       if (dx != 0 || dy != 0) {
           final int clampedDx = clampedX - oldLeft;
           final int clampedDy = clampedY - oldTop;
           mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,
                   clampedDx, clampedDy);
       }
   }
</code></pre>
<p>  可以看到,在这里完成了view的位置移动处理.通过 <em>mCallback</em> 中的各个方法来获取移动范围,并且有个 <em>mCallback.onViewPositionChanged</em> 位置移动的回调. 下面讲一下 <em>callback</em> 的用法.</p>
<p>(三) ViewDragHelper.Callback的用法</p>
<pre><code class="java">  public abstract static class Callback {
        /**
         * Called when the drag state changes. See the &lt;code&gt;STATE_*&lt;/code&gt; constants
         * for more information.
         * 当view的拖拽状态改变时触发,对应下面写的三种情况中一种
         * @param state The new drag state
         *
         * @see #STATE_IDLE 当前没有被拖拽
         * @see #STATE_DRAGGING 正在别拖拽
         * @see #STATE_SETTLING 被拖拽后需要安置到一个位置中的状态
         */
        public void onViewDragStateChanged(int state) {}

        /**
         * Called when the captured view&#39;s position changes as the result of a drag or settle.
         * 当view在拖拽时位置发生变化时触发,对应上面的 dragTo 方法
         * @param changedView View whose position changed
         * @param left New X coordinate of the left edge of the view
         * @param top New Y coordinate of the top edge of the view
         * @param dx Change in X position from the last call
         * @param dy Change in Y position from the last call
         */
        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {}

        /**
         * Called when a child view is captured for dragging or settling. The ID of the pointer
         * currently dragging the captured view is supplied. If activePointerId is
         * identified as {@link #INVALID_POINTER} the capture is programmatic instead of
         * pointer-initiated.
         * 当一个view被捕获时触发
         * @param capturedChild Child view that was captured
         * @param activePointerId Pointer id tracking the child capture
         */
        public void onViewCaptured(View capturedChild, int activePointerId) {}

        /**
         * Called when the child view is no longer being actively dragged.
         * The fling velocity is also supplied, if relevant. The velocity values may
         * be clamped to system minimums or maximums.
         * 当拖拽动作释放时触发
         * &lt;p&gt;Calling code may decide to fling or otherwise release the view to let it
         * settle into place. It should do so using {@link #settleCapturedViewAt(int, int)}
         * or {@link #flingCapturedView(int, int, int, int)}. If the Callback invokes
         * one of these methods, the ViewDragHelper will enter {@link #STATE_SETTLING}
         * and the view capture will not fully end until it comes to a complete stop.
         * If neither of these methods is invoked before &lt;code&gt;onViewReleased&lt;/code&gt; returns,
         * the view will stop in place and the ViewDragHelper will return to
         * {@link #STATE_IDLE}.&lt;/p&gt;
         *
         * @param releasedChild The captured child view now being released
         * @param xvel X velocity of the pointer as it left the screen in pixels per second.
         * @param yvel Y velocity of the pointer as it left the screen in pixels per second.
         */
        public void onViewReleased(View releasedChild, float xvel, float yvel) {}

        /**
         * Called when one of the subscribed edges in the parent view has been touched
         * by the user while no child view is currently captured.
         * 当触发了viewGroup的边缘时触发
         * @param edgeFlags A combination of edge flags describing the edge(s) currently touched
         * @param pointerId ID of the pointer touching the described edge(s)
         * @see #EDGE_LEFT
         * @see #EDGE_TOP
         * @see #EDGE_RIGHT
         * @see #EDGE_BOTTOM
         */
        public void onEdgeTouched(int edgeFlags, int pointerId) {}

        /**
         * Called when the given edge may become locked. This can happen if an edge drag
         * was preliminarily rejected before beginning, but after {@link #onEdgeTouched(int, int)}
         * was called. This method should return true to lock this edge or false to leave it
         * unlocked. The default behavior is to leave edges unlocked.
         * 是否锁定边缘的触摸
         * @param edgeFlags A combination of edge flags describing the edge(s) locked
         * @return true to lock the edge, false to leave it unlocked
         */
        public boolean onEdgeLock(int edgeFlags) {
            return false;
        }

        /**
         * Called when the user has started a deliberate drag away from one
         * of the subscribed edges in the parent view while no child view is currently captured.
         * 边缘触摸开始时触发
         * @param edgeFlags A combination of edge flags describing the edge(s) dragged
         * @param pointerId ID of the pointer touching the described edge(s)
         * @see #EDGE_LEFT
         * @see #EDGE_TOP
         * @see #EDGE_RIGHT
         * @see #EDGE_BOTTOM
         */
        public void onEdgeDragStarted(int edgeFlags, int pointerId) {}

        /**
         * Called to determine the Z-order of child views.
         * 在寻找当前的触摸点下的view时会调用这个方法,比如两个子view叠加在一起之后,如果你想获得下面的那个时,可以改写这个方法.
         * @param index the ordered position to query for
         * @return index of the view that should be ordered at position &lt;code&gt;index&lt;/code&gt;
         */
        public int getOrderedChildIndex(int index) {
            return index;
        }

        /**
         * Return the magnitude of a draggable child view&#39;s horizontal range of motion in pixels.
         * This method should return 0 for views that cannot move horizontally.
         * 获取被拖拽view的水平移动范围
         * @param child Child view to check
         * @return range of horizontal motion in pixels
         */
        public int getViewHorizontalDragRange(View child) {
            return 0;
        }

        /**
         * Return the magnitude of a draggable child view&#39;s vertical range of motion in pixels.
         * This method should return 0 for views that cannot move vertically.
         * 获取被拖拽view的垂直移动范围
         * @param child Child view to check
         * @return range of vertical motion in pixels
         */
        public int getViewVerticalDragRange(View child) {
            return 0;
        }

        /**
         * Called when the user&#39;s input indicates that they want to capture the given child view
         * with the pointer indicated by pointerId. The callback should return true if the user
         * is permitted to drag the given view with the indicated pointer.
         *
         * &lt;p&gt;ViewDragHelper may call this method multiple times for the same view even if
         * the view is already captured; this indicates that a new pointer is trying to take
         * control of the view.&lt;/p&gt;
         * 尝试捕获当前触摸的view
         * &lt;p&gt;If this method returns true, a call to {@link #onViewCaptured(android.view.View, int)}
         * will follow if the capture is successful.&lt;/p&gt;
         *
         * @param child Child the user is attempting to capture
         * @param pointerId ID of the pointer attempting the capture
         * @return true if capture should be allowed, false otherwise
         */
        public abstract boolean tryCaptureView(View child, int pointerId);

        /**
         * Restrict the motion of the dragged child view along the horizontal axis.
         * The default implementation does not allow horizontal motion; the extending
         * class must override this method and provide the desired clamping.
         * 限制水平方向的移动范围
         *
         * @param child Child view being dragged
         * @param left Attempted motion along the X axis
         * @param dx Proposed change in position for left
         * @return The new clamped position for left
         */
        public int clampViewPositionHorizontal(View child, int left, int dx) {
            return 0;
        }

        /**
         * Restrict the motion of the dragged child view along the vertical axis.
         * The default implementation does not allow vertical motion; the extending
         * class must override this method and provide the desired clamping.
         * 限制垂直方向的移动范围
         *
         * @param child Child view being dragged
         * @param top Attempted motion along the Y axis
         * @param dy Proposed change in position for top
         * @return The new clamped position for top
         */
        public int clampViewPositionVertical(View child, int top, int dy) {
            return 0;
        }
    }
</code></pre>
<p>  ViewDragHelper的内部流程实现就讲完了,有些细节这里就不展开了,感兴趣的同学可以读一下源码.在额外补充ViewDragHelper的常用方法 <em>settleCapturedViewAt</em> :</p>
<pre><code class="java">  public boolean settleCapturedViewAt(int finalLeft, int finalTop) {
         if (!mReleaseInProgress) {
             throw new IllegalStateException(&quot;Cannot settleCapturedViewAt outside of a call to &quot;
                     + &quot;Callback#onViewReleased&quot;);
         }

         return forceSettleCapturedViewAt(finalLeft, finalTop,
                 (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),
                 (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));
     }
</code></pre>
<p>  这个方法,用来直接把拖动的view放在指定的位置上.</p>
<pre><code class="java">  private boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {
       final int startLeft = mCapturedView.getLeft();
       final int startTop = mCapturedView.getTop();
       final int dx = finalLeft - startLeft;
       final int dy = finalTop - startTop;

       if (dx == 0 &amp;&amp; dy == 0) {
           // Nothing to do. Send callbacks, be done.
           mScroller.abortAnimation();
           setDragState(STATE_IDLE);
           return false;
       }

       final int duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);
       mScroller.startScroll(startLeft, startTop, dx, dy, duration);

       setDragState(STATE_SETTLING);
       return true;
   }
</code></pre>
<p>  可以看到这里通过Scroller来完成view的平滑移动的.这个方法 <em>settleCapturedViewAt</em> 在拖动view释放之后让view进入指定位置的时候会非常有用.<br>  注意:一定要在viewGroup调用如下方法来完成view的平滑移动,在调用 <em>settleCapturedViewAt</em> 方法的时候.</p>
<pre><code class="java">  @Override
  public void computeScroll() {
      super.computeScroll();
      if (mDragHelper.continueSettling(true)) {
          ViewCompat.postInvalidateOnAnimation(this);
      }
  }
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/24/2017/读书笔记/启示录-打造用户喜爱的产品/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/24/2017/读书笔记/启示录-打造用户喜爱的产品/" itemprop="url">启示录-打造用户喜爱的产品</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-24T14:03:00+08:00">
                2017-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="启示录-打造用户喜爱的产品-读书笔记"><a href="#启示录-打造用户喜爱的产品-读书笔记" class="headerlink" title="启示录-打造用户喜爱的产品 读书笔记"></a>启示录-打造用户喜爱的产品 读书笔记</h2><p>我的日常工作明确分为三个部分: 人员,流程,产品</p>
<ul>
<li>人员是指负责定义和开发产品的团队成员的角色和职责</li>
<li>流程是指探索,开发富有创意的产品时,反复应用的步骤和成功的实践经验</li>
<li>产品是指富有创意的产品具有的鲜明特性</li>
</ul>
<h3 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h3><p>产品经理的主要职责分为两项: 评估产品机会;定义要开发的产品</p>
<p>现代软件的产品团队组成:</p>
<ul>
<li>产品经理</li>
<li>用户体验设计师</li>
<li>项目管理人员</li>
<li>开发团队</li>
<li>运维团队</li>
<li>产品营销人员</li>
</ul>
<p>必须清晰的界定产品经理和产品营销人员的职责.产品经理负责详细定义待开发的产品,让真实的用户测试产品.产品营销人员负责向外界宣传和推广产品,负责产品发布,为拓展市场销售渠道,组织重点营销活动(如在线营销),促进产品销售提供支持.</p>
<p>产品管理通常使用了 <em>并行开发</em> 和 <em>火车模型发布模式</em></p>
<p>优秀产品经理身上的7个特点:</p>
<ol>
<li>工作紧迫感</li>
<li>善于捕捉问题</li>
<li>思路清晰</li>
<li>用数据说话</li>
<li>果断</li>
<li>判断力</li>
<li>态度</li>
</ol>
<p>用户体验设计包含的方面:</p>
<ul>
<li>用户研究</li>
<li>交互设计</li>
<li>视觉设计</li>
<li>原型制作</li>
</ul>
<p>如果产品没有市场价值,那么无论开发团队多么优秀也无济于事.很多优秀的产品是程序员抓住用户需求,自己创业研发出来的.放宽眼界不仅仅有利于开发人员自己的职业发展,也有利于产品,顾客和公司.</p>
<p>关于留出时间调整代码的参考建议:</p>
<ol>
<li>针对开发团队确定的产品修改目标制定切实可行的计划和时间表</li>
<li>只要有可能,最好把重写目标分成几大块,实现递增修改,让用户感受到产品的改进,哪怕会因此把九个月的工作时间延长到两年,也一定要采用这种方式.</li>
<li>由于开发用户可见功能的资源有限,必须谨慎悬着正确的产品特性,确保产品定义的正确性</li>
</ol>
<p>产品经理应该有的特质:</p>
<ol>
<li>对产品的热情</li>
<li>用户立场</li>
<li>智力</li>
<li>职业操守</li>
<li>正直</li>
<li>信心</li>
<li>态度</li>
<li>技能</li>
<li>运用技术的能力</li>
<li>注意力</li>
<li>时间管理</li>
<li>沟通技能</li>
<li>商业技能</li>
</ol>
<p>产品总监的关键职责有两个方面.第一,组建优秀的产品经理团队.第二,规划公司的全局产品战略.</p>
<p><em>永远不要告诉别人怎么做,告诉他们做什么,他们自然会发挥天赋,给你惊喜. -巴顿</em></p>
<p>一定问明白客户”要做什么?” 而不是 “怎么做?”</p>
<p>管理上司的十条经验</p>
<ol>
<li>为项目波动做好准备</li>
<li>注意沟通的方式和频率</li>
<li>会前沟通</li>
<li>多用建议,少提问题</li>
<li>向上司借力</li>
<li>充分准备</li>
<li>缩短邮件篇幅</li>
<li>多用数据和事实说话</li>
<li>内部宣传</li>
<li>做让领导省心的员工</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>  为了评估产品机会,我要求产品经理回答如下是个问题:</p>
<ol>
<li>产品要解决什么问题? (产品价值)</li>
<li>为谁解决这个问题? (目标市场)</li>
<li>成功的机会有多大? (市场规模)</li>
<li>怎样判断产品成功与否? (度量指标)</li>
<li>有哪些同类产品? (竞品格局)</li>
<li>为什么我们最适合做这个产品? (竞争优势)</li>
<li>时机合适吗? (市场时机)</li>
<li>如何把产品推向市场? (营销组合策略)</li>
<li>成功的必要条件是什么? (解决方案要满足的条件)</li>
<li><p>根据以上问题,给出评估结论. (继续或放弃)</p>
<p>产品探索:采用流水线方式并行开发产品.也就是说,一点1.0产品进入项目执行阶段,就开始定义2.0版本的产品.</p>
</li>
</ol>
<h4 id="产品原则-确定什么最重要"><a href="#产品原则-确定什么最重要" class="headerlink" title="产品原则:确定什么最重要"></a>产品原则:确定什么最重要</h4><p>  每次加入新团队,我要做的第一件事就是制定产品原则.制定产品原则意味着决定什么重要,什么不重要,哪些原则是根本的,战略性的,哪些是临时的,战术性的.</p>
<p>  制定产品原则时容易出现两类错误.第一类是原则过于空泛,失去了指导作用.第二类是把设计原则误当成产品原则,比如,为用户提供清晰的导航路径(方便用户完成下一步操作)属于常见的设计原则,不是产品原则.</p>
<p>  在作产品决策之前,应该先确定决策要解决什么问题,让大家在一下几个要点上达成共识:</p>
<ol>
<li>究竟要解决什么问题</li>
<li>要为哪类人物角色解决这个问题</li>
<li>产品要达到什么目标</li>
<li>每项目标的优先级是什么</li>
</ol>
<h4 id="市场调研的工具和方法"><a href="#市场调研的工具和方法" class="headerlink" title="市场调研的工具和方法"></a>市场调研的工具和方法</h4><ul>
<li>用户调查</li>
<li>产品使用分析</li>
<li>数据挖掘</li>
<li>拜访用户</li>
<li>人物角色</li>
<li>可用性测试</li>
<li>同类产品分析</li>
</ul>
<p>合理的利用市场调研工具和方法可以回答一下几个关键问题:</p>
<ol>
<li>谁是目标用户?</li>
<li>用户会怎样使用产品?</li>
<li>用户能想明白怎样使用产品吗?障碍在哪里?</li>
<li>用户为什么选用你的产品?</li>
<li>用户喜欢产品的哪些特点?</li>
<li>用户希望如何改进产品,增加哪些功能?</li>
</ol>
<p>成功的产品基于以下两点认识:深入理解用户需求,以及明白什么样的解决方案在现阶段是可行的.</p>
<p>基本产品:定义最满足基本要求(价值,可用性,可行性)的产品.</p>
<p>设计产品时一定要考虑哪些功能是最重要的,争取设计出只满足基本要求的,不可删减的产品.</p>
<h4 id="改进现有产品"><a href="#改进现有产品" class="headerlink" title="改进现有产品"></a>改进现有产品</h4><p>能提高指标的功能才是你关注的重点.你应该找准方向,分析关键指标,有正对性的改进产品.</p>
<h4 id="快速响应阶段"><a href="#快速响应阶段" class="headerlink" title="快速响应阶段"></a>快速响应阶段</h4><p>关键不在于是否会出现问题,而在于能 <em>多快</em> 解决问题.</p>
<h4 id="在大公司施展拳脚"><a href="#在大公司施展拳脚" class="headerlink" title="在大公司施展拳脚"></a>在大公司施展拳脚</h4><ol>
<li>了解公司制定决策的方式</li>
<li>建立人脉网络</li>
<li>臭鼬工程</li>
<li>自己顶上</li>
<li>有选择的据理力争</li>
<li>会前沟通,形成默契</li>
<li>合理分配时间</li>
<li>分享信息</li>
<li>向上司借力</li>
<li>传播你的产品理念</li>
</ol>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><h4 id="新技术层出不穷"><a href="#新技术层出不穷" class="headerlink" title="新技术层出不穷"></a>新技术层出不穷</h4><p>成功的产品往往不是新鲜事物,只是新瓶装老酒,之所以成功,是因为这个”新瓶”做的更好,更方便,更便宜,改变了消费者对”老酒”的印象.</p>
<p>现在成熟的市场上抢占一席之地,精明的公司至少要手握2两件”法宝”:</p>
<ol>
<li>对目标市场的了如指掌,对现有产品的缺陷洞若观火.</li>
<li>跟踪最新的技术趋势</li>
</ol>
<h4 id="情感接纳曲线"><a href="#情感接纳曲线" class="headerlink" title="情感接纳曲线"></a>情感接纳曲线</h4><p>根据消费者的情感特征,把他们分为技术爱好者,非理性消费者,理性消费者,超理性消费者和观望者.</p>
<p>非理性消费者最值得产品经理注意.</p>
<p>如果你带着新生的感觉去发掘每天折磨着大众的感情-孤独,恐惧,挫折,不满,你离发现新产品的日子就不远了.</p>
<h4 id="最佳实践经验"><a href="#最佳实践经验" class="headerlink" title="最佳实践经验"></a>最佳实践经验</h4><p>大大要点:</p>
<ol>
<li>产品管理的职责</li>
<li>用户体验</li>
<li>机会评估</li>
<li>特约用户</li>
<li>产品原则</li>
<li>任务角色</li>
<li>探索(定义)产品</li>
<li>使用原型</li>
<li>用户参与原型测试</li>
<li>根据数据改进产品</li>
</ol>
<h4 id="产品经理的反省清单"><a href="#产品经理的反省清单" class="headerlink" title="产品经理的反省清单"></a>产品经理的反省清单</h4><p>十大问题:</p>
<ol>
<li>产品能吸引目标消费者的关注吗?</li>
<li>产品的设计是否人性化,是否易于操作?</li>
<li>产品能在竞争中取胜吗?即使是面对未来风云变化的市场,依旧有取胜的把握吗?</li>
<li>我了解目标用户吗?产品(不是理性的产品,而是开发出来的产品)是否能得到他们的认可?</li>
<li>产品是否有别于市场上的其他产品?我能在两分钟内向公司高管清楚的阐明这些差别吗?能在一分钟内向客户解释清楚吗?能在半分钟内向经验丰富的行业分析师解释清楚吗?</li>
<li>产品能正产运行吗?</li>
<li>产品是否完整?用户对产品的印象如何?销售业绩如何?销售任务能否顺利完成?</li>
<li>产品的特设首付与目标用户的需求一致?产品特色是否鲜明?</li>
<li>产品值钱吗?值多少钱?为什么值这么多钱?用户会选择更便宜的产品吗?</li>
<li>我了解其他团队成员对产品的看法吗?他们觉得产品好在哪里?他们的看法是否与我的观点一致?</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/23/2017/androidSwipeLayout源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/23/2017/androidSwipeLayout源码分析/" itemprop="url">androidSwipeLayout源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-23T15:19:00+08:00">
                2017-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="android-SwipeLayout源码分析"><a href="#android-SwipeLayout源码分析" class="headerlink" title="android SwipeLayout源码分析"></a>android SwipeLayout源码分析</h2><p>swipeLayout是代码家写的一个支持手势滑动的开源库,初看的时候感觉特别惊艳,用户体验也非常的棒,特别好奇是怎么实现的,故抽时间研究了下.<br>通过分析代码结构得出swipeLayout主要分为三大部分:</p>
<ol>
<li>内部view初始设置</li>
<li>内部ViewDragHelper的callback实现</li>
<li>冲突解决与注意事项</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/23/2017/androidSwipeLayout源码分析/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/23/2017/android自定义gradle插件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/23/2017/android自定义gradle插件/" itemprop="url">android自定义gradle插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-23T13:31:00+08:00">
                2017-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="android自定义gradle插件"><a href="#android自定义gradle插件" class="headerlink" title="android自定义gradle插件"></a>android自定义gradle插件</h2><p>  在android学习过程中,理解gradle的编译过程是非常重要的,我们可以通过自定义gradle插件来达到在编译打包的过程中人工参与其中的一部分工作,这样可以满足我们的各种需求,比如在编译之前要对所有的class做统一处理,比如打包完成之后要输出到指定的目录,这些都可以通过自定义的gradle插件来完成.</p>
<p>  下面讲解下如何在android studio中实现自定义的gradle插件</p>
<h2 id="在当前工程的gradle文件中实现插件"><a href="#在当前工程的gradle文件中实现插件" class="headerlink" title="在当前工程的gradle文件中实现插件"></a>在当前工程的gradle文件中实现插件</h2><p>  gradle插件理论上就是通过groovy语法实现的类,内部可以制定一些流程task来完成相应的工作.最简单的肯定是在当前工程的 <em>build.gradle</em> 文件中直接实现插件内容.因为实际上 <em>build.gralde</em> 就是一个groovy文件.</p>
<p>  在我们的android主工程目录中输入一下代码:</p>
<pre><code class="groovy">  class GreetingPlugin implements Plugin&lt;Project&gt; {

    @Override
    void apply(Project project) {
        project.extensions.create(&quot;greeting&quot;, GreetingPluginExtension)
        project.task(&#39;hello&#39;) {
            doLast {
                println &quot;${project.greeting.message} from ${project.greeting.greeter}&quot;
            }
        }
    }
 }

 class GreetingPluginExtension {
    String message = &#39;Hello from GreetingPlugin&#39;
    String greeter
 }
</code></pre>
<p> 这里首先是实现一个plugin接口,这个接口是所有的自定义插件的必须实现的.完成里面的 <em>apply</em> 方法,这里用到了一个 <em>extensions</em> 的概念,这个 <em>extensions</em> 是用来给工程project设置一些额外属性的对象.比如我们在android的 <em>build.gradle</em> 文件中经常看到的</p>
<pre><code> android{
   ....
 }
</code></pre><p> 这个 <em>android{}</em> 内部就是给工程中设置的一些参数.在咱们这里的设置的是 <em>extensions</em> 叫 <em>GreetingPluginExtension</em> ,内部定义了两个参数 <em>message</em> 和 <em>greeter</em> 这里前一个参数有默认值,后一个没有,其实groovy和java的语法基本上一样的,只不过groovy是动态的java.</p>
<p>接着看plugin中的 <em>apply</em> 方法,非常的简单就是定义一个名叫 <em>hello</em> 的 <em>task</em> ,然后在里面打印一下  <em>GreetingPluginExtension</em> 中的两个参数.那在 <em>build.gradle</em> 中如何设置对应的参数呢?看下面的代码:</p>
<pre><code>greeting {
    message  &#39;Hi from gradle&#39;
    greeter  &#39;Gradle&#39;
}
</code></pre><p>就是这么简单直白.定义完成之后,我们直接在主目录下终端运行一下命令:</p>
<pre><code>./gradlew -q hello
</code></pre><p>可以看到在终端中输出:</p>
<pre><code>Hi from gradle from Gradle
</code></pre><p>是不是非常的简单呢.在当前工程中定义的插件只能自己用,如果要给别人用的话就需要通过一个单独的工程来生成插件了.</p>
<h3 id="在单独工程中创建自定义gradle插件"><a href="#在单独工程中创建自定义gradle插件" class="headerlink" title="在单独工程中创建自定义gradle插件"></a>在单独工程中创建自定义gradle插件</h3><p>首先在当前的工程中随便创建一个android module ,然后src/main目录下所有文件夹全部删除掉.然后先创建一个groovy文件夹,里面用来存放我们的插件groovy代码,一个是 <em>GreetingPluginExtension</em> ,一个是 <em>MyGradlePlugin</em> 内部代码分别对应上面的两个class.</p>
<p>然后再创建一个 <em>resources</em> 文件夹,里面放入一个 <em>META-INFO</em> 文件夹,然后继续在 <em>META-INFO</em> 文件夹下创建 <em>gradle-pulgins</em> ,在 <em>gradle-pulgins</em> 下创建文件<br><em>com.justyan.gradle.properties</em> 文件,文件内容为:</p>
<pre><code>implementation-class = com.justyan.gradleplugin.MyGradlePlugin
</code></pre><p>这里的 <em>com.justyan.gradle.properties</em> 文件的 <em>com.justyan.gradle</em> 就是你以后要给其他工程引用的的 gradle ID.比如这样:</p>
<pre><code>apply plugin: &#39;com.justyan.gradle&#39;
</code></pre><p>这个名称你可以随便起,只要在引用的时候引用对了就ok.文件中内容的目的是指定了插件的类路径,这里就是groovy文件下的那两个groovy文件.</p>
<p>最后的文件目录应该是这样的:<br><img src="images/2017/01/android自定义gradle插件的目录结构.png" alt="插件工程的目录结构"></p>
<p>这里的 <em>META-INFO</em> 和 <em>gradle-pulgins</em> 是android studio给合并显示了,实际上是一个层级关系.</p>
<p>这样插件代码就完成了,剩下的就是如果打包发布的问题了.</p>
<p>在创建的插件的module工程中的 <em>build.gradle</em> 文件中输入一下内容:</p>
<pre><code>apply plugin: &#39;groovy&#39;
apply plugin: &#39;maven&#39;

version = &#39;1.0.0&#39;
group = &#39;com.justyan&#39;
archivesBaseName = &#39;mygradleplugin&#39;
repositories {
    mavenCentral()
}


dependencies {
    compile gradleApi()
    compile localGroovy()
}
// 一定要记得使用交叉编译选项，因为我们可能用很高的JDK版本编译，为了让安装了低版本的同学能用上我们写的插件，必须设定source和target
compileGroovy {
    sourceCompatibility = 1.7
    targetCompatibility = 1.7
    options.encoding = &quot;UTF-8&quot;
}
uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: &quot;file:////Users/justyan/Downloads/repo&quot;)
        }
    }
}
</code></pre><p>version用来表示maven生成的jar包版本号,group表示属于哪个组织, <em>archivesBaseName</em> 表示生成的java的名称.最后在 <em>uploadArchives</em> 中指定了生成的maven目录在哪里.这个目录你可以随意指定,只要后续引用的时候前后一致就可以.</p>
<p>完成这个之后,我们调用这个工程的 <em>uploadArchives</em> task:</p>
<pre><code>./gradlew -q uploadArchives
</code></pre><p>然后就会在上面的指定目录下生成对应的maven文件了.</p>
<p>最后,来看下如何在其他工程中引用.</p>
<p>在要引用的工程的顶层目录的 <em>build.gralde</em> 文件中输入:</p>
<pre><code>buildscript {
    repositories {
        jcenter()
        maven {
            url uri(&#39;file:////Users/justyan/Downloads/repo&#39;)
        }
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.2.2&#39;
        classpath group: &#39;com.justyan&#39;, name: &#39;mygradleplugin&#39;,
                version: &#39;1.0.0&#39;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}
</code></pre><p>首先指定maven文件目录,和上面的对应,然后在 <em>dependencies</em> 中输入组名,插件名,版本号.这样对插件的引用就完成了.最后在要使用的工程中的 <em>build.gralde</em> 文件中顶部输入:</p>
<pre><code>apply plugin: &#39;com.justyan.gradle&#39;
</code></pre><p>然后用android studio同步一下gradle就可以了.这个时候在旁边的gradle project中是可以看到 <em>hello</em> 这个task的,表明插件加载成功.<br><img src="images/2017/01/gradle project中的新增的task.png" alt="task列表"></p>
<p>最后如果我们要使用这个task和上面的方法一样,在终端中输入:</p>
<pre><code>./gradlew -q hello
</code></pre><p>可以看到在终端中输出:</p>
<pre><code>Hi from gradle from Gradle
</code></pre><p>这样自定义插件就全部搞定了,后续可以根据需求来自己实现插件中的内容了.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html" title="cutom_plugin" target="_blank" rel="external">cutom_plugin</a></p>
<p><a href="https://gold.xitu.io/entry/577bc26e165abd005530ead8" title="在 Android Studio 中自定义 Gradle 插件" target="_blank" rel="external">在 Android Studio 中自定义 Gradle 插件</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/23/2017/读书笔记/富爸爸 穷爸爸读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/23/2017/读书笔记/富爸爸 穷爸爸读书笔记/" itemprop="url">富爸爸 穷爸爸 读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-23T08:47:00+08:00">
                2017-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="富爸爸-穷爸爸-读书笔记"><a href="#富爸爸-穷爸爸-读书笔记" class="headerlink" title="富爸爸 穷爸爸 读书笔记"></a>富爸爸 穷爸爸 读书笔记</h2><p> 我一个爸爸总是习惯对说”我可付不起”,而另一个爸爸则禁止我们说这样的话,他坚持让我们说:”我怎样才能付得起?” 这两句话,一句是陈述句,一句是疑问句.一句让你放弃,而另一句则促使你去想办法.我那个在不久之后就富起来的爸爸解释,当你下意识的说出”我付不起”的时候,你的大脑就会停止思考,而如果你自问”我怎么才能付得起”,则会让你的大脑动起来.</p>
<p> 富爸爸说:”我的大脑越用越活,大脑越活,我挣点钱就越多”.他认为,下意识的说”我可付不起”意味着精神上的懒惰.</p>
<p> 在遇到钱的问题时,一个爸爸习惯于逃避,另一个爸爸则总是想办法解决问题.长此以往,其结果就是,一个爸爸的理财能力越来越弱,而另一个爸爸的理财能力越来越强.这种结果类似于一个经常去健身房锻炼的人与一个总坐在沙发上看电视的人在体质上的不同变化.适当的体育锻炼可以增加获得健康的机会,同时,适当的脑力训练可以增加获得财富的机会.懒惰必定会让你的体质变弱,财富减少.</p>
<p> 我得说生活才是最好的老师.大多数的时候,生活不会和你说什么,只会推着你转,每一次推,它都像是在说: “喂,醒一醒,我要让你学点东西.”<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/23/2017/读书笔记/富爸爸 穷爸爸读书笔记/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/19/2017/java反射相关知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/19/2017/java反射相关知识/" itemprop="url">java反射相关知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-19T15:16:00+08:00">
                2017-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java反射相关知识"><a href="#java反射相关知识" class="headerlink" title="java反射相关知识"></a>java反射相关知识</h2><h3 id="Class-getDeclaringClass-和-Class-getEnclosingClass的区别"><a href="#Class-getDeclaringClass-和-Class-getEnclosingClass的区别" class="headerlink" title="Class.getDeclaringClass 和 Class.getEnclosingClass的区别"></a>Class.getDeclaringClass 和 Class.getEnclosingClass的区别</h3><p>getDeclaringClass表示这个内的声明类是那个,常用于获取在当前中声明的内部类<br>getEnclosingClass表示获取当前类的外部调用类,也可以用于在内部类中获取外部类.<br>二者的区别在于匿名内部类,如果这个类不是在当前类中声明,那么getDeclaringClass返回null,而getEnclosingClass返回外层类</p>
<pre><code class="java">class TestClassReflection{

  public static void main(String[] args) throws NoSuchFieldException {
         new Thread(new Runnable() {
             @Override
             public void run() {
                 Class&lt;? extends Runnable&gt; aClass = this.getClass();
                 Class&lt;?&gt; declaringClass2 = aClass.getDeclaringClass();
                 Class&lt;?&gt; enclosingClass1 = aClass.getEnclosingClass();
                 System.out.println(&quot;declaringClass2 = &quot;+declaringClass2);
                 System.out.println(&quot;enclosingClass1 = &quot;+enclosingClass1);
             }
         }).start();
     }
}
</code></pre>
<pre><code>declaringClass2 = null
enclosingClass1 = class com.justyan.reflection.TestClassReflection
</code></pre><h3 id="打印出继承关系"><a href="#打印出继承关系" class="headerlink" title="打印出继承关系"></a>打印出继承关系</h3><pre><code class="java">public static void printAncestor(Class aclass, ArrayList&lt;Class&gt; list) {
       if (aclass != null) {
           Class superclass = aclass.getSuperclass();
           if (superclass != null) {
               list.add(superclass);
               printAncestor(superclass, list);
           }
       }
   }
</code></pre>
<p>最后把所有的父类都在list中.</p>
<h3 id="Class-getGenericInterfaces方法和Class-getInterfaces方法的区别"><a href="#Class-getGenericInterfaces方法和Class-getInterfaces方法的区别" class="headerlink" title="Class.getGenericInterfaces方法和Class.getInterfaces方法的区别"></a>Class.getGenericInterfaces方法和Class.getInterfaces方法的区别</h3><p>getGenericInterfaces返回所有的实现接口,包含接口的泛型<br>getInterfaces返回所有的接口class对象,不包含泛型信息</p>
<h3 id="Class-getTypeParameters-方法"><a href="#Class-getTypeParameters-方法" class="headerlink" title="Class.getTypeParameters 方法"></a>Class.getTypeParameters 方法</h3><p>getTypeParameters返回类的泛型信息</p>
<h3 id="Class-getDeclaredMethods-和-Class-getMethods-区别"><a href="#Class-getDeclaredMethods-和-Class-getMethods-区别" class="headerlink" title="Class.getDeclaredMethods 和 Class.getMethods 区别"></a>Class.getDeclaredMethods 和 Class.getMethods 区别</h3><p>这类前面加了 <em>Declared</em> 的方法,只是获取当前类的成员,不包含父类的相关成员<br>而getMethods会获取所有的方法</p>
<h3 id="Class-getFields和Class-getDeclaredFields"><a href="#Class-getFields和Class-getDeclaredFields" class="headerlink" title="Class.getFields和Class.getDeclaredFields"></a>Class.getFields和Class.getDeclaredFields</h3><p>getFields获取当前类所有的 <em>public</em> 属性<br>getDeclaredFields返回当前类所有的属性<br>下面的话摘自官方教程</p>
<blockquote>
<p>Tip: The Class.getField() and Class.getFields() methods return the public member field(s) of the class, enum, or interface represented by &gt;the Class object. To retrieve all fields declared (but not inherited) in the Class, use the Class.getDeclaredFields() method.</p>
</blockquote>
<h3 id="反射中获取method参数的相关属性"><a href="#反射中获取method参数的相关属性" class="headerlink" title="反射中获取method参数的相关属性"></a>反射中获取method参数的相关属性</h3><p>method.getParameters用来获取该方法的所有参数.返回一个 <em>Parameter[]</em> 数组.</p>
<pre><code class="java">
    private static void printParam(Method declaredMethod) {
        Parameter[] parameters = declaredMethod.getParameters();
        for (Parameter parameter : parameters) {
            System.out.println(parameter.getType());
            System.out.println(parameter.getName());
            System.out.println(parameter.getModifiers());
            System.out.println(parameter.isImplicit());
            System.out.println(parameter.isNamePresent());
            System.out.println(parameter.isSynthetic());
        }
        System.out.println(&quot;-------------------------&quot;);
    }
</code></pre>
<p>分别来解释下这几个方法的用法:</p>
<ol>
<li><em>getType</em> 获取参数类型,比如int,java.lang.String等</li>
<li><em>getName</em> 获取参数名称,这里有个问题要注意,默认情况下获取到的参数都是 <em>arg0</em> ,<em>arg1</em> 等这样的系统生成的参数名称,是获取不到原始的命名的,这样做的目的是为了节约class文件的空间.如果想要获取到原始参数名称,需要在编译的 <em>javac</em> 后面加上 <em>-parameters</em> 参数.</li>
<li><p><em>getModifiers</em> 是一个int值,是把下面要3种情况相加得出的.<br><img src="/images/2017/01/method的modifiers属性说明.png" alt="modifiers属性说明"></p>
</li>
<li><p><em>isImplicit</em> 和 <em>isSynthetic</em> 下面重点来讲一下</p>
</li>
<li><em>isNamePresent</em> 对应上面的 <em>getName</em> 的情况,如果是从显示的原始的class中参数命名就是true,如果是编译器生成的 <em>arg0</em> 这种方式就是 false.</li>
</ol>
<h4 id="isImplicit-和-isSynthetic"><a href="#isImplicit-和-isSynthetic" class="headerlink" title="isImplicit 和 isSynthetic"></a><em>isImplicit</em> 和 <em>isSynthetic</em></h4><p>先来看 <em>isImplicit</em> 通过字面理解就是 <em>含蓄的,隐式的</em> ,也就是说这个方法并没有在代码中直接声明,确实是存在的.对应的正常情景就是内部类对外部类的引用.我们都知道 <em>非静态</em> 内部类是对外部类有一个引用的.那么编译器在编译的时候生成的内部类的构造方法中是会有一个外部类的对象引用的.就想下面这样:</p>
<pre><code class="java">public class MethodParameterExamples {
    public class InnerClass { }
}
</code></pre>
<pre><code class="java">public class MethodParameterExamples {
    public class InnerClass {
        final MethodParameterExamples parent;
        InnerClass(final MethodParameterExamples this$0) {
            parent = this$0;
        }
    }
}
</code></pre>
<p>innerClass的默认构造函数其实是对外部的MethodParameterExamples有一个引用的,那么innerClass这个默认的构造方法的 <em>isImplicit</em> 属性就是true.</p>
<p>再来看,如果一个方法既不是显式的也不是隐式的而是通过编译器生成的,那么这个 <em>isSynthetic</em> 属性就为true.经典的用在枚举类型中</p>
<pre><code class="java">public class MethodParameterExamples {
    enum Colors {
        RED, WHITE;
    }
}
</code></pre>
<p>如果答应这里Colors类对象的话,会发现其内部是这样的:</p>
<pre><code class="java">final class Colors extends java.lang.Enum&lt;Colors&gt; {
    public final static Colors RED = new Colors(&quot;RED&quot;, 0);
    public final static Colors BLUE = new Colors(&quot;WHITE&quot;, 1);

    private final static values = new Colors[]{ RED, BLUE };

    private Colors(String name, int ordinal) {
        super(name, ordinal);
    }

    public static Colors[] values(){
        return values;
    }

    public static Colors valueOf(String name){
        return (Colors)java.lang.Enum.valueOf(Colors.class, name);
    }
}
</code></pre>
<p>这里面的构造函数 <em>Colors(String name , ind ordinal)</em> 是隐式声明的,其中的参数是编译器给生成的,那么参数的 <em>isSynthetic</em> 属性就是true.其中的 <em>valueOf</em> 方法中的参数是 <em>isImplicit</em> 的.<br><a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html" target="_blank" rel="external">implicit and synthetic</a></p>
<h3 id="Method-isVarArgs"><a href="#Method-isVarArgs" class="headerlink" title="Method.isVarArgs()"></a>Method.isVarArgs()</h3><p> Method.isVarArgs() 表明方法的参数是不是隐式数组这种格式,比如main方法中的 <em>String… args</em></p>
<h3 id="Method的isSynthetic和isBridge"><a href="#Method的isSynthetic和isBridge" class="headerlink" title="Method的isSynthetic和isBridge"></a>Method的isSynthetic和isBridge</h3><pre><code class="java">public class TestMethodModifiers {
    public static void main(String[] args) {
        Method[] methods = Integer.class.getMethods();
        for (Method method : methods) {
            if (method.getName().equals(&quot;compareTo&quot;)) {
                System.out.println(method.toGenericString());
                System.out.println(method.isSynthetic());
                System.out.println(method.isBridge());
            }
        }
    }
}
</code></pre>
<pre><code>public int java.lang.Integer.compareTo(java.lang.Integer)
false
false
public int java.lang.Integer.compareTo(java.lang.Object)
true
true
</code></pre><p>编译器会帮助生成一个 <em>compareTo(Object object)</em> 的中间方法,这个方法就是一个中间方法,用来解决 <em>泛型擦除?</em> 这里我也不是很明白.</p>
<h3 id="method反射调用注意事项"><a href="#method反射调用注意事项" class="headerlink" title="method反射调用注意事项"></a>method反射调用注意事项</h3><ol>
<li>如果要反射的方法需要传入的参数是一个数组,就像这样的:<pre><code class="java">void test(String... arr) {
      System.out.println(&quot;Iam test!!!!------&quot; +arr);
  }
</code></pre>
如果你直接这样调用是不行的:<pre><code class="java">String[] mainArgs = new String[]{&quot;a&quot;, &quot;b&quot;};
method.invoke(TestMethodBean2.class.newInstance(), mainArgs);
</code></pre>
虽然你传入的确实是一个数组,但是invoke方法会认为你要调用的方法是参数个数为数组容量的方法,也就是说这里认为你想调用的是包含两个参数的test方法:<pre><code class="java">void test(String a,String b) {
      System.out.println(&quot;Iam test!!!!------&quot; +arr);
  }
</code></pre>
如果要正确调用,应该把数组对象转换为Object对象,这样就可以了:<pre><code class="java">String[] mainArgs = new String[]{&quot;a&quot;, &quot;b&quot;};
method.invoke(TestMethodBean2.class.newInstance(), (Object) mainArgs);
</code></pre>
</li>
<li>如果要反射一个带有泛型的方法,就像这样:<pre><code class="java">class TestMethodBean2&lt;T&gt;{
void test(T t) {
   System.out.println(&quot;it is generic&quot;);
}
}
</code></pre>
通过代码:<pre><code class="java">new TestMethodBean2&lt;Integer&gt;().getClass().getDeclaredMethod(&quot;test&quot;,Integer.class);
</code></pre>
是不行的,会找不到这个方法,因为泛型在编译之后是会被擦除的,这个时候应该找的是最顶上的对象object才可以<pre><code class="java">new TestMethodBean2&lt;Integer&gt;().getClass().getDeclaredMethod(&quot;test&quot;,Object.class);
</code></pre>
</li>
<li><p>对private方法的反射调用<br>要在获取到方法对象之后设置 <em>method.setAccessible(true);</em> 就可以了</p>
</li>
<li><p>如果要反射的方法没有参数,那么调用invoke方法的时候一定要注意<br>```java<br>public class MethodTrouble {<br> public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {</p>
<pre><code> MethodTroubleBean bean = new MethodTroubleBean();
 Method test = bean.getClass().getDeclaredMethod(&quot;test&quot;);
 test.invoke(bean);  //success
 test.invoke(bean, null); //success ,但是有警告
 test.invoke(bean, new Object[0]); //success
 Object o = new Object[0];
 test.invoke(bean, o);  //wrong IllegalArgumentException
 Object n = null;
 test.invoke(bean, n);  //wrong IllegalArgumentException
</code></pre><p> }<br>}</p>
</li>
</ol>
<p>class MethodTroubleBean {<br>    void test() {<br>        System.out.println(“test”);<br>    }<br>  }</p>
<pre><code>一定要注意对参数的传入.

### Class.newInstance 和Construction.newInstance的区别
Class.newInstance只能调用默认的构造函数(没有参数的那个),而且必须是可见的
Construction.newInstance可以调用所有的构造函数,不管是否是可见的,也不管有多少个参数
推荐使用后面这个

### 反射创建数组
```java
Object o = Array.newInstance(int.class, 3);
        Array.set(o,0,1);
        Array.set(o,1,2);
        Array.set(o,2,3);
</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.oracle.com/javase/tutorial/reflect/TOC.html" title="java reflect tutorial" target="_blank" rel="external">java reflect tutorial</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/19/2017/android asyncTask源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/19/2017/android asyncTask源码分析/" itemprop="url">android asyncTask源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-19T09:25:00+08:00">
                2017-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="android-AsyncTask源码分析-android7-0"><a href="#android-AsyncTask源码分析-android7-0" class="headerlink" title="android AsyncTask源码分析(android7.0)"></a>android AsyncTask源码分析(android7.0)</h2><p>  说道AsyncTask相信大家并不陌生,每当涉及到异步线程的的任务处理的时候,我们第一时间就会想到AsyncTask或者Handler.这里AsyncTask主要是android给我们封装了一层异步任务处理流程,方便使用,所以平时大家在UI中执行异步线程的时候会优先使用AsyncTask,今天就通过源码讲解一下AsyncTask的实现原理和注意事项.</p>
<h3 id="AsyncTask的用法"><a href="#AsyncTask的用法" class="headerlink" title="AsyncTask的用法"></a>AsyncTask的用法</h3><p><code>```java</code><br><code>class MainAsyncTask extends AsyncTask&lt;Object,Object,Object&gt;{</code></p>
<pre><code>       @Override
       protected void onPreExecute() {
           super.onPreExecute();
       }

       @Override
       protected void onPostExecute(Object o) {
           super.onPostExecute(o);
       }

       @Override
       protected Object doInBackground(Object... params) {
           return null;
       }
   }
</code></pre><p><code>````
</code>上面这个自定义AsyncTask就是我们平时的用法,可以看到主要用到3个方法,其中 <em>onPreExecute</em> 和 <em>onPostExecute</em> 分别表示任务开始前后的准备和收尾工作,注意这里这两个方法是在UI主线程中执行的.后面的 <em>doInBackground</em> 是任务的执行的代码,耗时的任务执行代码放在这里.注意这个方法是在异步线程中执行的.</p>
<p>当我们要使用AsyncTask的时候,通常是直接创建AsyncTask对象,然后调用execute方法,这样AsyncTask会先调用 <em>onPreExecute</em> 方法,然后开始执行 <em>doInBackground</em> 方法啊,最后任务完成之后回调 <em>onPostExecute</em> 方法.</p>
<pre><code class="java">new MainAsyncTask().execute();
</code></pre>
<h3 id="AsyncTask源码"><a href="#AsyncTask源码" class="headerlink" title="AsyncTask源码"></a>AsyncTask源码</h3><p>先说结论,AsyncTask的内部实际上维护了一个线程池来调配异步任务(FutureTask)的执行,当异步任务执行完成之后就把结果交给内部的 <em>Handler</em> 来回调到UI主线程中.<br>就这么简单,我们要注意的细节有这么几点:</p>
<ol>
<li>内部线程池的结构类型</li>
<li>3个常用回调方法的调用时机</li>
<li>任务完成之后为什么不能再次调用这个AsyncTask对象重复执行.</li>
</ol>
<p>我们先从常用的 <em>execute</em> 方法入手:</p>
<pre><code class="java">@MainThread
   public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {
       return executeOnExecutor(sDefaultExecutor, params);
   }
</code></pre>
<p>这里execute内部又会调用 <em>executeOnExecutor</em> 方法,这里的 <em>sDefaultExecutor</em> 后面再做解释,只要明白其就是一个线程池就可以:</p>
<pre><code class="java">@MainThread
   public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
           Params... params) {
       if (mStatus != Status.PENDING) {
           switch (mStatus) {
               case RUNNING:
                   throw new IllegalStateException(&quot;Cannot execute task:&quot;
                           + &quot; the task is already running.&quot;);
               case FINISHED:
                   throw new IllegalStateException(&quot;Cannot execute task:&quot;
                           + &quot; the task has already been executed &quot;
                           + &quot;(a task can be executed only once)&quot;);
           }
       }

       mStatus = Status.RUNNING;

       onPreExecute();

       mWorker.mParams = params;
       exec.execute(mFuture);

       return this;
   }
</code></pre>
<p>可以看到,这个代码非常非常的简单,就是判断一下 AsyncTask 对象的状态,如果不是 <em>PENDING</em> 状态就抛出异常.如果是 <em>PENDING</em> 状态就设置为 <em>RUNNING</em> 状态,同时调用 <em>onPreExecute</em> 方法,最后交给线程池的 <em>execute</em> 方法.是不是很清晰.同时在这里发现了我们的第一个回调方法 <em>onPreExecute</em> ,注意这里通过方法上面的注解我们发现是运行在主线程中的.</p>
<p>这里传入线程池的是一个 <em>FutureTask</em> 对象 <em>mFuture</em> ,里面包含了一个 <em>mWorker</em> 对象.下面来看传给线程池的 <em>mWorker</em> 对象的实现. <em>mWorker</em> 对象是一个 <em>WorkerRunable</em> 对象</p>
<pre><code class="java">private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; {
      Params[] mParams;
  }
</code></pre>
<p>可以看到 <em>WorkerRunnable</em> 对象就是一个 <em>Callable</em> 对象, <em>Callable</em> 和 <em>Runnable</em> 的区别就是有没有返回值的区别.这里AsyncTask线程池中使用的 <em>Callable</em> .</p>
<pre><code class="java">public AsyncTask() {
       mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
           public Result call() throws Exception {
               mTaskInvoked.set(true);
               Result result = null;
               try {
                   Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                   //noinspection unchecked
                   result = doInBackground(mParams);
                   Binder.flushPendingCommands();
               } catch (Throwable tr) {
                   mCancelled.set(true);
                   throw tr;
               } finally {
                   postResult(result);
               }
               return result;
           }
       };

       mFuture = new FutureTask&lt;Result&gt;(mWorker) {
           @Override
           protected void done() {
               try {
                   postResultIfNotInvoked(get());
               } catch (InterruptedException e) {
                   android.util.Log.w(LOG_TAG, e);
               } catch (ExecutionException e) {
                   throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,
                           e.getCause());
               } catch (CancellationException e) {
                   postResultIfNotInvoked(null);
               }
           }
       };
   }
</code></pre>
<p>在AsyncTask的构造函数中,完成了 <em>mWorker</em> 对象的初始化.然后把 <em>mWorker</em> 对象传给了 <em>mFuture</em> 对象. 如果对 <em>FutureTask</em> 不是很理解的同学可以去搜索一下相关的资料,非常简单. <em>FutureTask</em> 只是把要运行的对象和其返回值做了一个封装,方便线程池的回调使用.</p>
<p>在 <em>mWorker</em> 的call方法中,我们发现了第二个回调方法 <em>doInBackground</em> ,这个方法用来执行异步任务的,这里是在异步线程中执行的.<br>当任务执行完成之后,会调用 <em>postResult(result);</em></p>
<pre><code class="java">private Result postResult(Result result) {
       @SuppressWarnings(&quot;unchecked&quot;)
       Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
               new AsyncTaskResult&lt;Result&gt;(this, result));
       message.sendToTarget();
       return result;
   }
</code></pre>
<p>这里可看到Handler的常规使用.来看Handler的实现:</p>
<pre><code class="java">private static class InternalHandler extends Handler {
       public InternalHandler() {
           super(Looper.getMainLooper());
       }

       @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})
       @Override
       public void handleMessage(Message msg) {
           AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
           switch (msg.what) {
               case MESSAGE_POST_RESULT:
                   // There is only one result
                   result.mTask.finish(result.mData[0]);
                   break;
               case MESSAGE_POST_PROGRESS:
                   result.mTask.onProgressUpdate(result.mData);
                   break;
           }
       }
   }
</code></pre>
<p>这里Handler里面有两个回调,先说 <em>MESSAGE_POST_RESULT</em> ,这里回到了asyncTask的 <em>finish</em> 方法:</p>
<pre><code class="java">private void finish(Result result) {
        if (isCancelled()) {
            onCancelled(result);
        } else {
            onPostExecute(result);
        }
        mStatus = Status.FINISHED;
    }
</code></pre>
<p><em>finish</em> 方法,有两个点要说明:首先你在外面调用 <em>cancel</em> 停止AsyncTask的时候,AsyncTask内部并没有停止,而是会继续执行,直到最后在finish中才做的的状态判断,只是忽略掉了返回结果而已.so,如果cancel了AsyncTask,那么是不会回调 <em>onPostExecute</em> 的,同时任务也不是立刻就停止的.如果想要任务马上停止,只能是在 <em>doInBackground</em> 方法中来对AsyncTask的状态做判断,如果状态变化了,里面return,这样可以保证任务立刻停止.<br>还有一个点要注意的是,前面有个问题:为什么AsyncTask执行完成之后不能继续调用execute方法呢.是因为在 <em>finish</em> 方法中,把这个AsyncTask对象的状态设置为 <em>FINISHED</em> ,在execute方法中第一步中就判断如果状态不是 <em>PENDING</em> 就会抛出异常.关键点在这里,所有我们如果还要二次执行任务的话,只能是重新创建一个新的AsyncTask对象了.</p>
<p>回到刚才Handler中,可以看到还有另一个异步回调情况 <em>MESSAGE_POST_PROGRESS</em> 这个是用来干什么的呢?通过字面理解我么可以发现是用来更新进度说明的.在代码中,找到了这个方法 <em>publishProgress</em> .</p>
<pre><code class="java">/**
    * This method can be invoked from {@link #doInBackground} to
    * publish updates on the UI thread while the background computation is
    * still running. Each call to this method will trigger the execution of
    * {@link #onProgressUpdate} on the UI thread.
    *
    * {@link #onProgressUpdate} will not be called if the task has been
    * canceled.
    *
    * @param values The progress values to update the UI with.
    *
    * @see #onProgressUpdate
    * @see #doInBackground
    */
@WorkerThread
   protected final void publishProgress(Progress... values) {
       if (!isCancelled()) {
           getHandler().obtainMessage(MESSAGE_POST_PROGRESS,
                   new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();
       }
   }
</code></pre>
<p>仔细看方法上面的注释,这个方法可以在 <em>doInBackground</em> 中调用,来更新进度说明.最后这个方法会在主线程中回调 <em>onProgressUpdate</em> .<br>也就是说如果我们复写 <em>onProgressUpdate</em> 方法,我们可以在UI主线程中获取到进度更新提示.</p>
<p>上面提出的3个问题中后两个问题我们已经解释了,3个方法的回调时机非常清晰,同时AsyncTask由于最后finish状态原因是无法再次执行的.<br>最后说说AsyncTask中线程池的实现,这个点由于在不同的android版本的变化会有很多的差异,这里的源码使用是最新的7.0源码:</p>
<pre><code class="java">
    /**
     * An {@link Executor} that executes tasks one at a time in serial
     * order.  This serialization is global to a particular process.
     */
  public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
  private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;
</code></pre>
<pre><code class="java">private static class SerialExecutor implements Executor {
       final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();
       Runnable mActive;

       public synchronized void execute(final Runnable r) {
           mTasks.offer(new Runnable() {
               public void run() {
                   try {
                       r.run();
                   } finally {
                       scheduleNext();
                   }
               }
           });
           if (mActive == null) {
               scheduleNext();
           }
       }

       protected synchronized void scheduleNext() {
           if ((mActive = mTasks.poll()) != null) {
               THREAD_POOL_EXECUTOR.execute(mActive);
           }
       }
   }
</code></pre>
<p>这里创建了一种叫做 <em>SerialExecutor</em> 的线程池,通过字面理解可以知道是一种串行的线程池,也就是说线程是挨个来交给 <em>THREAD_POOL_EXECUTOR</em> .这里的的 <em>SerialExecutor</em> 用到了 <em>ArrayDeque</em> 这种双向队列数据结构.只允许在结尾插入,在头部取出.可以看下其中的 <em>offer</em> 和 <em>poll</em> 方法.</p>
<pre><code class="java">public boolean offer(E e) {
      return offerLast(e);
  }
</code></pre>
<pre><code class="java">public E poll() {
       return pollFirst();
   }
</code></pre>
<p>首先offer新的任务到 <em>SerialExecutor</em> 中时,判断 <em>mActive</em> 是否存在,如果不存在就去从 <em>ArrayDeque</em> 中取一个出来执行,每当其中一个任务执行完成后,最终会调用 <em>scheduleNext</em> 方法,这样就保证队列中的任务顺序执行了.</p>
<p>最后 <em>SerialExecutor</em> 是把代码交给 <em>THREAD_POOL_EXECUTOR</em> 线程池了,再来看它的实现方法:</p>
<pre><code class="java">private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
   private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
   private static final int KEEP_ALIVE_SECONDS = 30;

   private static final ThreadFactory sThreadFactory = new ThreadFactory() {
       private final AtomicInteger mCount = new AtomicInteger(1);

       public Thread newThread(Runnable r) {
           return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());
       }
   };

   private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =
           new LinkedBlockingQueue&lt;Runnable&gt;(128);

   /**
    * An {@link Executor} that can be used to execute tasks in parallel.
    */
   public static final Executor THREAD_POOL_EXECUTOR;

   static {
       ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
               CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
               sPoolWorkQueue, sThreadFactory);
       threadPoolExecutor.allowCoreThreadTimeOut(true);
       THREAD_POOL_EXECUTOR = threadPoolExecutor;
   }
</code></pre>
<p>这里的 <em>THREAD_POOL_EXECUTOR</em> 就是一个线程池的常用实现,这里就不展开了.<br>这里需要说明的是这个 <em>THREAD_POOL_EXECUTOR</em> 存在的意义,通过上面代码我们可以看到asyncTask的任务是顺序执行的,也就是说你有再多的任务也是一个一个的执行的.<br>那这样可能对需求会有影响,所以在 <em>executeOnExecutor</em> 方法中可以看到,我们是可以传入其他的线程池的,这样就可以同时执行很多任务了,而 <em>THREAD_POOL_EXECUTOR</em> 就相当于一个预置的多任务线程池,如果有这种需求,你可以直接把 <em>THREAD_POOL_EXECUTOR</em> 传给 <em>executeOnExecutor</em> 方法,这样就可以让任务同步执行了.</p>
<p>在android2.3之前,AsyncTask使用就是 <em>THREAD_POOL_EXECUTOR</em> 这种线程池模式,不过由于它最对支持128个任务容量,如果超过容量之后就会报错,同时在创建任务的过程中可能会导致ANR,所以从3.0之后就改成现在这种的串行执行的线程池方式了.这个点是要注意的.</p>
<p>如果有大量的异步任务需要执行的,不推荐使用的AsyncTask,毕竟它本身不适合重要大任务量的处理,这个时候应该自己是实现线程池来完成相关的需求.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/38614699" title="Android AsyncTask 源码解析" target="_blank" rel="external"> Android AsyncTask 源码解析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/16/2017/android ButterKnife源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/16/2017/android ButterKnife源码解析/" itemprop="url">android ButterKnife源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-16T08:56:00+08:00">
                2017-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="android-ButterKnife源码解析"><a href="#android-ButterKnife源码解析" class="headerlink" title="android ButterKnife源码解析"></a>android ButterKnife源码解析</h2><h3 id="ButterKnife基本原理"><a href="#ButterKnife基本原理" class="headerlink" title="ButterKnife基本原理"></a>ButterKnife基本原理</h3><p>通过初次查看代码结构,发现原理大致和EventBus相同,通过定义不同的注解,然后通过注解分析器来生成新的源文件代码,在里面完成view的初始化和事件绑定,最后通过 <em>ButterKnife.bind</em> 方法来反射调用生成的新的源文件的中的初始化方法,来完成view的初始化和时间绑定.</p>
<p>可以这样理解,实际上以前是把findViewById等语句放在一个方法里面了,而这个方法在onCreate里面调用.现在是onCreate里面调用了 <em>ButterKnif.bind</em> 方法,里面还是findViewById那一套,只不过是通过注解分析器提前生成了源代码,里面是findViewById那些相关的声明语句.</p>
<p>注意,通过注解预编译这种方式可以达到在编译阶段来完成view的初始化和事件绑定,相对于反射是基本上没有性能消耗,所以是值得提倡的一种的技术方式.包括之前研究的Router也是通过这种方式来达到模块之间的相互调用的功能的.</p>
<h3 id="ButterKnife源代码分析"><a href="#ButterKnife源代码分析" class="headerlink" title="ButterKnife源代码分析"></a>ButterKnife源代码分析</h3><h4 id="ButterKnife的Bind方法调用"><a href="#ButterKnife的Bind方法调用" class="headerlink" title="ButterKnife的Bind方法调用"></a>ButterKnife的Bind方法调用</h4><p>先从ButterKnife的入口来分析,比如在Activity中我们调用 <em>ButterKnife.bind(this)</em> 方法,来看其内部实现:</p>
<pre><code class="java">@NonNull @UiThread
 public static Unbinder bind(@NonNull Activity target) {
   View sourceView = target.getWindow().getDecorView();
   return createBinding(target, sourceView);
 }
</code></pre>
<p>这里获取到的是顶层DecorView,target是activity对象本身,然后交给 <em>createBinding</em> 方法.</p>
<pre><code class="java">private static Unbinder createBinding(@NonNull Object target, @NonNull View source) {
   Class&lt;?&gt; targetClass = target.getClass();
   if (debug) Log.d(TAG, &quot;Looking up binding for &quot; + targetClass.getName());
   Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);

   if (constructor == null) {
     return Unbinder.EMPTY;
   }

   //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.
   try {
     return constructor.newInstance(target, source);
   } catch (IllegalAccessException e) {
     throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);
   } catch (InstantiationException e) {
     throw new RuntimeException(&quot;Unable to invoke &quot; + constructor, e);
   } catch (InvocationTargetException e) {
     Throwable cause = e.getCause();
     if (cause instanceof RuntimeException) {
       throw (RuntimeException) cause;
     }
     if (cause instanceof Error) {
       throw (Error) cause;
     }
     throw new RuntimeException(&quot;Unable to create binding instance.&quot;, cause);
   }
 }
</code></pre>
<p>这里可以看到 根据类名称来通过 <em>findBindingConstructorForClass</em> 查找该类具有两个参数的构造函数.</p>
<pre><code class="java">@Nullable @CheckResult @UiThread
  private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) {
    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);
    if (bindingCtor != null) {
      if (debug) Log.d(TAG, &quot;HIT: Cached in binding map.&quot;);
      return bindingCtor;
    }
    String clsName = cls.getName();
    if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)) {
      if (debug) Log.d(TAG, &quot;MISS: Reached framework class. Abandoning search.&quot;);
      return null;
    }
    try {
      Class&lt;?&gt; bindingClass = Class.forName(clsName + &quot;_ViewBinding&quot;);
      //noinspection unchecked
      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);
      if (debug) Log.d(TAG, &quot;HIT: Loaded binding class and constructor.&quot;);
    } catch (ClassNotFoundException e) {
      if (debug) Log.d(TAG, &quot;Not found. Trying superclass &quot; + cls.getSuperclass().getName());
      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());
    } catch (NoSuchMethodException e) {
      throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e);
    }
    BINDINGS.put(cls, bindingCtor);
    return bindingCtor;
  }
</code></pre>
<pre><code class="java">@VisibleForTesting
 static final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();
</code></pre>
<p>这里 BINDINGS 是一个LinkedHashMap,存放的是类对象和它的构造函数对应关系.相当于一个缓存的作用,注意这里找的class对象是获取activity的类名称再加上 <em>_ViewBinding</em> 后缀.当使用ButterKnife编译完成之后,我们可以在我们工程中的build目录中找到 这些中间类.比如 你的activity名称叫做 “MainActivity”,那么生成的<br>中间类就叫做 “MainActivity_ViewBinding”.可以查看下里面的代码.就像这样:</p>
<pre><code class="java">public class SimpleActivity_ViewBinding&lt;T extends SimpleActivity&gt; implements Unbinder {
  protected T target;

  private View view2130968578;

  private View view2130968579;

  @UiThread
  public SimpleActivity_ViewBinding(final T target, View source) {
    this.target = target;

    View view;
    target.title = Utils.findRequiredViewAsType(source, R.id.title, &quot;field &#39;title&#39;&quot;, TextView.class);
    target.subtitle = Utils.findRequiredViewAsType(source, R.id.subtitle, &quot;field &#39;subtitle&#39;&quot;, TextView.class);
    view = Utils.findRequiredView(source, R.id.hello, &quot;field &#39;hello&#39;, method &#39;sayHello&#39;, and method &#39;sayGetOffMe&#39;&quot;);
    target.hello = Utils.castView(view, R.id.hello, &quot;field &#39;hello&#39;&quot;, Button.class);
    view2130968578 = view;
    view.setOnClickListener(new DebouncingOnClickListener() {
      @Override
      public void doClick(View p0) {
        target.sayHello();
      }
    });
    view.setOnLongClickListener(new View.OnLongClickListener() {
      @Override
      public boolean onLongClick(View p0) {
        return target.sayGetOffMe();
      }
    });
    view = Utils.findRequiredView(source, R.id.list_of_things, &quot;field &#39;listOfThings&#39; and method &#39;onItemClick&#39;&quot;);
    target.listOfThings = Utils.castView(view, R.id.list_of_things, &quot;field &#39;listOfThings&#39;&quot;, ListView.class);
    view2130968579 = view;
    ((AdapterView&lt;?&gt;) view).setOnItemClickListener(new AdapterView.OnItemClickListener() {
      @Override
      public void onItemClick(AdapterView&lt;?&gt; p0, View p1, int p2, long p3) {
        target.onItemClick(p2);
      }
    });
    target.footer = Utils.findRequiredViewAsType(source, R.id.footer, &quot;field &#39;footer&#39;&quot;, TextView.class);
    target.headerViews = Utils.listOf(
        Utils.findRequiredView(source, R.id.title, &quot;field &#39;headerViews&#39;&quot;),
        Utils.findRequiredView(source, R.id.subtitle, &quot;field &#39;headerViews&#39;&quot;),
        Utils.findRequiredView(source, R.id.hello, &quot;field &#39;headerViews&#39;&quot;));
  }

  @Override
  @CallSuper
  public void unbind() {
    T target = this.target;
    if (target == null) throw new IllegalStateException(&quot;Bindings already cleared.&quot;);

    target.title = null;
    target.subtitle = null;
    target.hello = null;
    target.listOfThings = null;
    target.footer = null;
    target.headerViews = null;

    view2130968578.setOnClickListener(null);
    view2130968578.setOnLongClickListener(null);
    view2130968578 = null;
    ((AdapterView&lt;?&gt;) view2130968579).setOnItemClickListener(null);
    view2130968579 = null;

    this.target = null;
  }
}
</code></pre>
<p>这个java类是通过注解解析器完成通过代码来生成的.可以看到里面就是一些view的初始化和事件绑定.唯一要注意的一点是,这里的中间类都是实现了unBinder接口,实现了unBind方法,里面是对view和各种事件的回收.主要是用在 <em>fragment</em> 中的使用的,看下ButterKnife的说明会看到,在 fragment使用完成之后必须调用 <em>ViewBinder.unBinder</em> 方法来完成view的回收.<br>下面的代码来着ButterKnife的说明:</p>
<pre><code class="java">BINDING RESET

Fragments have a different view lifecycle than activities. When binding a fragment in onCreateView, set the views to null in onDestroyView. Butter Knife returns an Unbinder instance when you call bind to do this for you. Call its unbind method in the appropriate lifecycle callback.

public class FancyFragment extends Fragment {
  @BindView(R.id.button1) Button button1;
  @BindView(R.id.button2) Button button2;
  private Unbinder unbinder;

  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fancy_fragment, container, false);
    unbinder = ButterKnife.bind(this, view);
    // TODO Use fields...
    return view;
  }

  @Override public void onDestroyView() {
    super.onDestroyView();
    unbinder.unbind();
  }
}
</code></pre>
<h4 id="注解分析器AnnotationProcessor的逻辑分析"><a href="#注解分析器AnnotationProcessor的逻辑分析" class="headerlink" title="注解分析器AnnotationProcessor的逻辑分析"></a>注解分析器AnnotationProcessor的逻辑分析</h4><p>核心点就在 <em>ButterKnifeProcessor</em> 里面.</p>
<pre><code class="java">@Override public Set&lt;String&gt; getSupportedAnnotationTypes() {
    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();
    for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) {
      types.add(annotation.getCanonicalName());
    }
    return types;
  }

  private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() {
    Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;();

    annotations.add(BindArray.class);
    annotations.add(BindBitmap.class);
    annotations.add(BindBool.class);
    annotations.add(BindColor.class);
    annotations.add(BindDimen.class);
    annotations.add(BindDrawable.class);
    annotations.add(BindFloat.class);
    annotations.add(BindInt.class);
    annotations.add(BindString.class);
    annotations.add(BindView.class);
    annotations.add(BindViews.class);
    annotations.addAll(LISTENERS);

    return annotations;
  }
  private static final List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList(//
       OnCheckedChanged.class, //
       OnClick.class, //
       OnEditorAction.class, //
       OnFocusChange.class, //
       OnItemClick.class, //
       OnItemLongClick.class, //
       OnItemSelected.class, //
       OnLongClick.class, //
       OnPageChange.class, //
       OnTextChanged.class, //
       OnTouch.class //
   );
</code></pre>
<p>可以通过 <em>getSupportedAnnotationTypes</em> 方法看到都支持哪些注解的处理.<br>重点的处理方法就在 <em>process</em> 方法中:</p>
<pre><code class="java">@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {
   Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);

   for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) {
     TypeElement typeElement = entry.getKey();
     BindingSet binding = entry.getValue();

     JavaFile javaFile = binding.brewJava(sdk);
     try {
       javaFile.writeTo(filer);
     } catch (IOException e) {
       error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage());
     }
   }

   return false;
 }
</code></pre>
<p>可以看到第一行就是通过遍历扫描来找到对应类的所有 <em>ButterKnife</em> 注解,然后一次性来生成每个类的新的源文件类.</p>
<p>下面来看 <em>findAndParseTargets</em> 方法.</p>
<pre><code class="java">private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) {
    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;();
    Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;();

    scanForRClasses(env);

    // Process each @BindArray element.
    for (Element element : env.getElementsAnnotatedWith(BindArray.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceArray(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindArray.class, e);
      }
    }

    // Process each @BindBitmap element.
    for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceBitmap(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindBitmap.class, e);
      }
    }

    // Process each @BindBool element.
    for (Element element : env.getElementsAnnotatedWith(BindBool.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceBool(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindBool.class, e);
      }
    }

    // Process each @BindColor element.
    for (Element element : env.getElementsAnnotatedWith(BindColor.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceColor(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindColor.class, e);
      }
    }

    // Process each @BindDimen element.
    for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceDimen(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindDimen.class, e);
      }
    }

    // Process each @BindDrawable element.
    for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceDrawable(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindDrawable.class, e);
      }
    }

    // Process each @BindFloat element.
    for (Element element : env.getElementsAnnotatedWith(BindFloat.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceFloat(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindFloat.class, e);
      }
    }

    // Process each @BindInt element.
    for (Element element : env.getElementsAnnotatedWith(BindInt.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceInt(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindInt.class, e);
      }
    }

    // Process each @BindString element.
    for (Element element : env.getElementsAnnotatedWith(BindString.class)) {
      if (!SuperficialValidation.validateElement(element)) continue;
      try {
        parseResourceString(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindString.class, e);
      }
    }

    // Process each @BindView element.
    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
      // we don&#39;t SuperficialValidation.validateElement(element)
      // so that an unresolved View type can be generated by later processing rounds
      try {
        parseBindView(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindView.class, e);
      }
    }

    // Process each @BindViews element.
    for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
      // we don&#39;t SuperficialValidation.validateElement(element)
      // so that an unresolved View type can be generated by later processing rounds
      try {
        parseBindViews(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindViews.class, e);
      }
    }

    // Process each annotation that corresponds to a listener.
    for (Class&lt;? extends Annotation&gt; listener : LISTENERS) {
      findAndParseListener(env, listener, builderMap, erasedTargetNames);
    }

    // Associate superclass binders with their subclass binders. This is a queue-based tree walk
    // which starts at the roots (superclasses) and walks to the leafs (subclasses).
    Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =
        new ArrayDeque&lt;&gt;(builderMap.entrySet());
    Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;();
    while (!entries.isEmpty()) {
      Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();

      TypeElement type = entry.getKey();
      BindingSet.Builder builder = entry.getValue();

      TypeElement parentType = findParentType(type, erasedTargetNames);
      if (parentType == null) {
        bindingMap.put(type, builder.build());
      } else {
        BindingSet parentBinding = bindingMap.get(parentType);
        if (parentBinding != null) {
          builder.setParent(parentBinding);
          bindingMap.put(type, builder.build());
        } else {
          // Has a superclass binding but we haven&#39;t built it yet. Re-enqueue for later.
          entries.addLast(entry);
        }
      }
    }

    return bindingMap;
  }
</code></pre>
<p>这个 <em>findAndParseTargets</em> 方法看着很长,实际上分成了3部分,顶部是用来生成id和view的对应关系,中间是各种注解的处理后放入builderMap中,第三部分是遍历builderMap来生成BindingMap的.<br>先看如何生成ID的对应关系:</p>
<pre><code class="java">  scanForRClasses(env);
</code></pre>
<pre><code class="java">private void scanForRClasses(RoundEnvironment env) {
   if (trees == null) return;

   RClassScanner scanner = new RClassScanner();

   for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) {
     for (Element element : env.getElementsAnnotatedWith(annotation)) {
       JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation));
       if (tree != null) { // tree can be null if the references are compiled types and not source
         tree.accept(scanner);
       }
     }
   }

   for (String rClass : scanner.getRClasses()) {
     parseRClass(rClass);
   }
 }

 private void parseRClass(String rClass) {
   Element element;

   try {
     element = elementUtils.getTypeElement(rClass);
   } catch (MirroredTypeException mte) {
     element = typeUtils.asElement(mte.getTypeMirror());
   }

   JCTree tree = (JCTree) trees.getTree(element);
   if (tree != null) { // tree can be null if the references are compiled types and not source
     IdScanner idScanner =
         new IdScanner(symbols, elementUtils.getPackageOf(element).getQualifiedName().toString());
     tree.accept(idScanner);
   } else {
     parseCompiledR((TypeElement) element);
   }
 }

 private void parseCompiledR(TypeElement rClass) {
   for (Element element : rClass.getEnclosedElements()) {
     String innerClassName = element.getSimpleName().toString();
     if (SUPPORTED_TYPES.contains(innerClassName)) {
       for (Element enclosedElement : element.getEnclosedElements()) {
         if (enclosedElement instanceof VariableElement) {
           VariableElement variableElement = (VariableElement) enclosedElement;
           Object value = variableElement.getConstantValue();

           if (value instanceof Integer) {
             int id = (Integer) value;
             ClassName rClassName =
                 ClassName.get(elementUtils.getPackageOf(variableElement).toString(), &quot;R&quot;,
                     innerClassName);
             String resourceName = variableElement.getSimpleName().toString();
             symbols.put(id, new Id(id, rClassName, resourceName));
           }
         }
       }
     }
   }
 }

 private static class RClassScanner extends TreeScanner {
   private final Set&lt;String&gt; rClasses = new LinkedHashSet&lt;&gt;();

   @Override public void visitSelect(JCTree.JCFieldAccess jcFieldAccess) {
     Symbol symbol = jcFieldAccess.sym;
     if (symbol != null
         &amp;&amp; symbol.getEnclosingElement() != null
         &amp;&amp; symbol.getEnclosingElement().getEnclosingElement() != null
         &amp;&amp; symbol.getEnclosingElement().getEnclosingElement().enclClass() != null) {
       rClasses.add(symbol.getEnclosingElement().getEnclosingElement().enclClass().className());
     }
   }

   Set&lt;String&gt; getRClasses() {
     return rClasses;
   }
 }

 private static class IdScanner extends TreeScanner {
   private final Map&lt;Integer, Id&gt; ids;
   private final String packageName;

   IdScanner(Map&lt;Integer, Id&gt; ids, String packageName) {
     this.ids = ids;
     this.packageName = packageName;
   }

   @Override public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {
     for (JCTree tree : jcClassDecl.defs) {
       if (tree instanceof ClassTree) {
         ClassTree classTree = (ClassTree) tree;
         String className = classTree.getSimpleName().toString();
         if (SUPPORTED_TYPES.contains(className)) {
           ClassName rClassName = ClassName.get(packageName, &quot;R&quot;, className);
           VarScanner scanner = new VarScanner(ids, rClassName);
           ((JCTree) classTree).accept(scanner);
         }
       }
     }
   }
 }

 private static class VarScanner extends TreeScanner {
   private final Map&lt;Integer, Id&gt; ids;
   private final ClassName className;

   private VarScanner(Map&lt;Integer, Id&gt; ids, ClassName className) {
     this.ids = ids;
     this.className = className;
   }

   @Override public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl) {
     if (&quot;int&quot;.equals(jcVariableDecl.getType().toString())) {
       int id = Integer.valueOf(jcVariableDecl.getInitializer().toString());
       String resourceName = jcVariableDecl.getName().toString();
       ids.put(id, new Id(id, className, resourceName));
     }
   }
 }
</code></pre>
<p>这里,如何关于如何生成这个对应关系的里面用到一些api我不是很了解,网上的资料也很少,后续等到研究明白了再补充吧,只是通过字面理解应该是通过遍历java的语法分析树找到R文件中对应的filed的ID,组合成一个 <em>Id</em> .<br>中间的部分就是用来做生成builderMap的,我们挑其中的一个方法来看,大部分的方法都是类似的.</p>
<pre><code class="java">private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,
                              Set&lt;TypeElement&gt; erasedTargetNames) {
       TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();

       // Start by verifying common generated code restrictions.
       boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, &quot;fields&quot;, element)
               || isBindingInWrongPackage(BindView.class, element);

       // Verify that the target type extends from View.
       TypeMirror elementType = element.asType();
       if (elementType.getKind() == TypeKind.TYPEVAR) {
           TypeVariable typeVariable = (TypeVariable) elementType;
           elementType = typeVariable.getUpperBound();
       }
       if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) {
           if (elementType.getKind() == TypeKind.ERROR) {
               note(element, &quot;@%s field with unresolved type (%s) &quot;
                               + &quot;must elsewhere be generated as a View or interface. (%s.%s)&quot;,
                       BindView.class.getSimpleName(), elementType, enclosingElement.getQualifiedName(),
                       element.getSimpleName());
           } else {
               error(element, &quot;@%s fields must extend from View or be an interface. (%s.%s)&quot;,
                       BindView.class.getSimpleName(), enclosingElement.getQualifiedName(),
                       element.getSimpleName());
               hasError = true;
           }
       }

       if (hasError) {
           return;
       }

       // Assemble information on the field.
       int id = element.getAnnotation(BindView.class).value();

       BindingSet.Builder builder = builderMap.get(enclosingElement);
       if (builder != null) {
           String existingBindingName = builder.findExistingBindingName(getId(id));
           if (existingBindingName != null) {
               error(element, &quot;Attempt to use @%s for an already bound ID %d on &#39;%s&#39;. (%s.%s)&quot;,
                       BindView.class.getSimpleName(), id, existingBindingName,
                       enclosingElement.getQualifiedName(), element.getSimpleName());
               return;
           }
       } else {
           builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
       }

       String name = element.getSimpleName().toString();
       TypeName type = TypeName.get(elementType);
       boolean required = isFieldRequired(element);

       builder.addField(getId(id), new FieldViewBinding(name, type, required));

       // Add the type-erased version to the valid binding targets set.
       erasedTargetNames.add(enclosingElement);
   }
</code></pre>
<p>这个方法前半部分用来做ID校验,防止有重复的Id定义出现错误.<br>后半部分生成一个 <em>BindingSet.Builder</em> 对象,这个对象就是用来后续通过 <em>javapoet</em> 来生成制定的java源文件的.builderMap的key是声明注解的类,通常是我们的Activity或者viewHolder.<br>然后把 <em>FieldViewBinding</em> 放入builder中,其中 filed的key就是view本身的ID.</p>
<p><em>findAndParseTargets</em> 的最后一部分是用来生成bindingMap的,key是声明类,value是BindingSet对象.<br>通过中间生成的 <em>builderMap</em> 来完成.主要是用来子类和父类如果同时声明的时把两者合并成一个BindingSet对象.</p>
<p><em>BindingSet</em> 对象就是用来交给javaPoet来生成中间源文件的对象.</p>
<p>生成了BindingMap之后回到顶层的 <em>process</em> 方法:</p>
<pre><code class="java">for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) {
            TypeElement typeElement = entry.getKey();
            BindingSet binding = entry.getValue();

            JavaFile javaFile = binding.brewJava(sdk);
            try {
                javaFile.writeTo(filer);
            } catch (IOException e) {
                error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage());
            }
        }
</code></pre>
<p>可以看到这里调用的是 <em>bindingSet</em> 对象的 <em>brewJava</em> 方法来完成java源文件的写入的:</p>
<pre><code class="java">
  JavaFile brewJava(int sdk) {
    return JavaFile.builder(bindingClassName.packageName(), createType(sdk))
        .addFileComment(&quot;Generated code from Butter Knife. Do not modify!&quot;)
        .build();
  }
</code></pre>
<p>然后调用 <em>createType</em> 方法:</p>
<pre><code class="java">private TypeSpec createType(int sdk) {
    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())
        .addModifiers(PUBLIC);
    if (isFinal) {
      result.addModifiers(FINAL);
    }

    if (parentBinding != null) {
      result.superclass(parentBinding.bindingClassName);
    } else {
      result.addSuperinterface(UNBINDER);
    }

    if (hasTargetField()) {
      result.addField(targetTypeName, &quot;target&quot;, PRIVATE);
    }

    if (!constructorNeedsView()) {
      // Add a delegating constructor with a target type + view signature for reflective use.
      result.addMethod(createBindingViewDelegateConstructor(targetTypeName));
    }
    result.addMethod(createBindingConstructor(targetTypeName, sdk));

    if (hasViewBindings() || parentBinding == null) {
      result.addMethod(createBindingUnbindMethod(result, targetTypeName));
    }

    return result.build();
  }
</code></pre>
<p><em>createType</em> 分为三部分,一部分是createBindingViewDelegateConstructor,一部分是createBindingConstructor,还有一部分是createBindingUnbindMethod</p>
<pre><code class="java">private MethodSpec createBindingViewDelegateConstructor(TypeName targetType) {
  return MethodSpec.constructorBuilder()
      .addJavadoc(&quot;@deprecated Use {@link #$T($T, $T)} for direct creation.\n    &quot;
              + &quot;Only present for runtime invocation through {@code ButterKnife.bind()}.\n&quot;,
          bindingClassName, targetType, CONTEXT)
      .addAnnotation(Deprecated.class)
      .addAnnotation(UI_THREAD)
      .addModifiers(PUBLIC)
      .addParameter(targetType, &quot;target&quot;)
      .addParameter(VIEW, &quot;source&quot;)
      .addStatement((&quot;this(target, source.getContext())&quot;))
      .build();
}
</code></pre>
<p>这个构造函数的作用暂时没有弄明白,看说明好像是用来在运行的时候反射用的.</p>
<pre><code class="java">private MethodSpec createBindingConstructor(TypeName targetType, int sdk) {
    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
        .addAnnotation(UI_THREAD)
        .addModifiers(PUBLIC);

    if (hasMethodBindings()) {
      constructor.addParameter(targetType, &quot;target&quot;, FINAL);
    } else {
      constructor.addParameter(targetType, &quot;target&quot;);
    }

    if (constructorNeedsView()) {
      constructor.addParameter(VIEW, &quot;source&quot;);
    } else {
      constructor.addParameter(CONTEXT, &quot;context&quot;);
    }

    if (hasUnqualifiedResourceBindings()) {
      // Aapt can change IDs out from underneath us, just suppress since all will work at runtime.
      constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
          .addMember(&quot;value&quot;, &quot;$S&quot;, &quot;ResourceType&quot;)
          .build());
    }

    if (hasOnTouchMethodBindings()) {
      constructor.addAnnotation(AnnotationSpec.builder(SUPPRESS_LINT)
          .addMember(&quot;value&quot;, &quot;$S&quot;, &quot;ClickableViewAccessibility&quot;)
          .build());
    }

    if (parentBinding != null) {
      if (parentBinding.constructorNeedsView()) {
        constructor.addStatement(&quot;super(target, source)&quot;);
      } else if (constructorNeedsView()) {
        constructor.addStatement(&quot;super(target, source.getContext())&quot;);
      } else {
        constructor.addStatement(&quot;super(target, context)&quot;);
      }
      constructor.addCode(&quot;\n&quot;);
    }
    if (hasTargetField()) {
      constructor.addStatement(&quot;this.target = target&quot;);
      constructor.addCode(&quot;\n&quot;);
    }

    if (hasViewBindings()) {
      if (hasViewLocal()) {
        // Local variable in which all views will be temporarily stored.
        constructor.addStatement(&quot;$T view&quot;, VIEW);
      }
      for (ViewBinding binding : viewBindings) {
        addViewBinding(constructor, binding);
      }
      for (FieldCollectionViewBinding binding : collectionBindings) {
        constructor.addStatement(&quot;$L&quot;, binding.render());
      }

      if (!resourceBindings.isEmpty()) {
        constructor.addCode(&quot;\n&quot;);
      }
    }

    if (!resourceBindings.isEmpty()) {
      if (constructorNeedsView()) {
        constructor.addStatement(&quot;$T context = source.getContext()&quot;, CONTEXT);
      }
      if (hasResourceBindingsNeedingResource(sdk)) {
        constructor.addStatement(&quot;$T res = context.getResources()&quot;, RESOURCES);
      }
      for (ResourceBinding binding : resourceBindings) {
        constructor.addStatement(&quot;$L&quot;, binding.render(sdk));
      }
    }

    return constructor.build();
  }
</code></pre>
<p>这个方法来生成中间类的构造函数,里面定义了view的findViewById和绑定事件,生成的结果在前面已经列出了,就是 <em>javaPoet</em> 的API调用,非常容易理解.</p>
<p>最后是生成filed和unbind方法的 <em>createBindingUnbindMethod</em>:</p>
<pre><code class="java">
  private MethodSpec createBindingUnbindMethod(TypeSpec.Builder bindingClass,
      TypeName targetType) {
    MethodSpec.Builder result = MethodSpec.methodBuilder(&quot;unbind&quot;)
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC);
    if (!isFinal &amp;&amp; parentBinding == null) {
      result.addAnnotation(CALL_SUPER);
    }

    if (hasTargetField()) {
      if (hasFieldBindings()) {
        result.addStatement(&quot;$T target = this.target&quot;, targetType);
      }
      result.addStatement(&quot;if (target == null) throw new $T($S)&quot;, IllegalStateException.class,
          &quot;Bindings already cleared.&quot;);
      result.addStatement(&quot;$N = null&quot;, hasFieldBindings() ? &quot;this.target&quot; : &quot;target&quot;);
      result.addCode(&quot;\n&quot;);
      for (ViewBinding binding : viewBindings) {
        if (binding.getFieldBinding() != null) {
          result.addStatement(&quot;target.$L = null&quot;, binding.getFieldBinding().getName());
        }
      }
      for (FieldCollectionViewBinding binding : collectionBindings) {
        result.addStatement(&quot;target.$L = null&quot;, binding.name);
      }
    }

    if (hasMethodBindings()) {
      result.addCode(&quot;\n&quot;);
      for (ViewBinding binding : viewBindings) {
        addFieldAndUnbindStatement(bindingClass, result, binding);
      }
    }

    if (parentBinding != null) {
      result.addCode(&quot;\n&quot;);
      result.addStatement(&quot;super.unbind()&quot;);
    }
    return result.build();
  }
</code></pre>
<p>这里unBind方法不做过多的解释,主要是来看</p>
<pre><code class="java">for (ViewBinding binding : viewBindings) {
  addFieldAndUnbindStatement(bindingClass, result, binding);
}
</code></pre>
<pre><code class="java">
  private void addFieldAndUnbindStatement(TypeSpec.Builder result, MethodSpec.Builder unbindMethod,
      ViewBinding bindings) {
    // Only add fields to the binding if there are method bindings.
    Map&lt;ListenerClass, Map&lt;ListenerMethod, Set&lt;MethodViewBinding&gt;&gt;&gt; classMethodBindings =
        bindings.getMethodBindings();
    if (classMethodBindings.isEmpty()) {
      return;
    }

    String fieldName = bindings.isBoundToRoot() ? &quot;viewSource&quot; : &quot;view&quot; + bindings.getId().value;
    result.addField(VIEW, fieldName, PRIVATE);

    // We only need to emit the null check if there are zero required bindings.
    boolean needsNullChecked = bindings.getRequiredBindings().isEmpty();
    if (needsNullChecked) {
      unbindMethod.beginControlFlow(&quot;if ($N != null)&quot;, fieldName);
    }

    for (ListenerClass listenerClass : classMethodBindings.keySet()) {
      // We need to keep a reference to the listener
      // in case we need to unbind it via a remove method.
      boolean requiresRemoval = !&quot;&quot;.equals(listenerClass.remover());
      String listenerField = &quot;null&quot;;
      if (requiresRemoval) {
        TypeName listenerClassName = bestGuess(listenerClass.type());
        listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
        result.addField(listenerClassName, listenerField, PRIVATE);
      }

      if (!VIEW_TYPE.equals(listenerClass.targetType())) {
        unbindMethod.addStatement(&quot;(($T) $N).$N($N)&quot;, bestGuess(listenerClass.targetType()),
            fieldName, removerOrSetter(listenerClass, requiresRemoval), listenerField);
      } else {
        unbindMethod.addStatement(&quot;$N.$N($N)&quot;, fieldName,
            removerOrSetter(listenerClass, requiresRemoval), listenerField);
      }

      if (requiresRemoval) {
        unbindMethod.addStatement(&quot;$N = null&quot;, listenerField);
      }
    }

    unbindMethod.addStatement(&quot;$N = null&quot;, fieldName);

    if (needsNullChecked) {
      unbindMethod.endControlFlow();
    }
  }
</code></pre>
<p>这个方法用来生成中间类的filed,也就是view和事件的声明.之前在前面找了半天如何生成filed的方法一直没有找到,后来这这里才发现的.<br>声明的view名称是View+ID这种格式.</p>
<p>到这里大概的流程就讲完了,可能还是有些细节没有讲到,不过没有关系,只要明白了大概的运行方式就可以了.可以看到作者的思路非常的新颖就是通过中间类来完成一些初始化工作,这个给我们后续的android的编程中提供了一套可借鉴的思路.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://jakewharton.github.io/butterknife/" title="butterKnife document" target="_blank" rel="external">butterKnife document</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/13/2017/java class基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/13/2017/java class基础知识/" itemprop="url">java class基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-13T15:16:00+08:00">
                2017-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java-Class对象基础知识"><a href="#java-Class对象基础知识" class="headerlink" title="java Class对象基础知识"></a>java Class对象基础知识</h2><p>这里要说的说Class对象指的是在java源文件完成编译之后生成的.class字节码文件,然后通过JVM的classLoader来把字节码文件载入到虚拟机中生成对应的class对象.也就是平时我们通过 A.class 或者 Class.forName(“className”)等方式生成的Class对象.</p>
<h3 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h3><p>java默认提供了三个ClassLoader,分别是:</p>
<ol>
<li>BootStrap ClassLoader 是java类加载层次中最顶层的类加载器,负责加载jdk中的核心类库.</li>
<li>Extension ClassLoader 成为扩展类加载器,负责加载java的扩展类库,默认加载JAVA_HOME/jre/lib/ext/目录下的所有jar.</li>
<li>App ClassLoader 称为系统类加载器,负责加载应用程序classPath目录下的所有jar和class文件.</li>
</ol>
<p>除了java提供的三个默认的ClassLoader之外,用户还可以创建自定义的ClassLoader,只要继承自java.lang.ClassLoader就可以了.也包括java提供的另外两个ClassLoader(Extension和App classLoader),但是Bootstrap ClassLoader不继承自ClassLoader,因为它不是一个普通的java类,底层由C++编写,已经嵌入到JVM内核中,当JVM启动后,Bootstrap Loader也随之启动,负责加载完核心类库后,并构造Extension 和App ClassLoader.</p>
<h4 id="类加载器加载类原理"><a href="#类加载器加载类原理" class="headerlink" title="类加载器加载类原理"></a>类加载器加载类原理</h4><p>这里使用了一种叫 <em>双亲委派</em> 的模式来搜索类,每个classLoader对象都有一个父类classLoader对象的引用,每当要加载类的时候,会去父类去找,如果没有找到就去父类的父类去找,一直到顶层的classLoader.如果没有找到,就尝试从顶层开始加载类,如果失败就依次往回返,如果一直都没成功加载,就叫交回到当前的classLoader,直接返回一个 <em>classNotFound</em> 异常.</p>
<p>这里来看下jdk8的ClassLoader源码:</p>
<pre><code class="java">protected Class&lt;?&gt; loadClass(String name, boolean resolve)
      throws ClassNotFoundException
  {
      synchronized (getClassLoadingLock(name)) {
          // First, check if the class has already been loaded
          Class&lt;?&gt; c = findLoadedClass(name);
          if (c == null) {
              long t0 = System.nanoTime();
              try {
                  if (parent != null) {
                      c = parent.loadClass(name, false);
                  } else {
                      c = findBootstrapClassOrNull(name);
                  }
              } catch (ClassNotFoundException e) {
                  // ClassNotFoundException thrown if class not found
                  // from the non-null parent class loader
              }

              if (c == null) {
                  // If still not found, then invoke findClass in order
                  // to find the class.
                  long t1 = System.nanoTime();
                  c = findClass(name);

                  // this is the defining class loader; record the stats
                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                  sun.misc.PerfCounter.getFindClasses().increment();
              }
          }
          if (resolve) {
              resolveClass(c);
          }
          return c;
      }
  }
</code></pre>
<p>代码非常的清晰,就是从下到上的去找,然后再从上到下的加载.<br><img src="images/2017/01/java classloader加载流程.gif" alt="java classLoader加载顺序"></p>
<h4 id="为什么要使用双亲委派这种模式"><a href="#为什么要使用双亲委派这种模式" class="headerlink" title="为什么要使用双亲委派这种模式?"></a>为什么要使用双亲委派这种模式?</h4><ol>
<li>为了解决重复加载,当父类已经加载过了,子类就没有必要再去加载了.</li>
<li>为了安全性,比如如果我们自己定义了和系统中一样的基础类,这两个类就会引起安全隐患.如果通过双亲委派,就会优先加载系统的原生类.放在核心代码被 “污染”</li>
</ol>
<h4 id="JVM搜索的时候-如何判断两个class对象是否相同"><a href="#JVM搜索的时候-如何判断两个class对象是否相同" class="headerlink" title="JVM搜索的时候,如何判断两个class对象是否相同"></a>JVM搜索的时候,如何判断两个class对象是否相同</h4><p>JVM在判定两个Class是否相同时,不仅要判断两个类名是否相同,而且要判断是否由同一个类加载器加载出来的.只有两者同时满足,JVM才认为这两个Class是相同的.</p>
<h3 id="class对象加载注意点"><a href="#class对象加载注意点" class="headerlink" title="class对象加载注意点"></a>class对象加载注意点</h3><p>所有的类都是在对其第一次使用的时候,动态加载到JVM中的.当程序创建第一个对象的静态成员的引用时,就会加载这个类.<br>这个证明构造器也是类的静态方法,即使在构造器之前并没有static关键字.因此,使用new操作符创建类的新对象也会被当做对类的静态成员的引用.</p>
<h3 id="new-A-getClass-方法"><a href="#new-A-getClass-方法" class="headerlink" title="new A().getClass()方法"></a>new A().getClass()方法</h3><p>Class classA = new A().getClass();<br>class对象提供了一些非常实用的方法,比如getSimpleName用来返回不包含包名的类名称.而getName和getCanonicalName则会返回全限定的类名称<br>还可以通过 newInstance()方法来直接产生类的实例对象,前提是该类有默认的构造函数.<br>最后还有一些是 getInterfaces(),getSupperclass()等等,这里就不展开了.</p>
<h4 id="A-class-字面量"><a href="#A-class-字面量" class="headerlink" title="A.class 字面量"></a>A.class 字面量</h4><p>这里的字面量指的是通过类名加class后缀之后获得了class对象.这个对象有很多特殊的情况需要特别说明一下.</p>
<p>当通过使用 “.class”来创建Class对象的引用时,不会自动 <em>初始化</em> 该Class对象.<br>这里的 <em>初始化</em> 是什么意思呢?并不是说这个Class对象是空的,而生成的Class对象并没有调用Class内部的静态方法或者静态代码块.<br>为了使用类而做的准备工作实际上包含了三个步骤:</p>
<ol>
<li>加载. 这是由前面讲的类加载器执行的.该步骤讲查找字节码(通常在ClassPath所指定的路径下查找,但这并非必须),并从这些字节码中创建一个class对象.</li>
<li>链接. 在链接阶段将验证类中的字节码,为静态域分配存储空间,并且如果必需的话,将解析这个类创建的对其他类的所有引用.</li>
<li>初始化. 如果该类具有超类,则对其初始化,执行静态初始化器和静态代码块.</li>
</ol>
<p>初始化被延迟到了对静态方法 (构造器隐式地是静态的) 或者非常数静态域进行首次引用才执行.<br>下面通过几个例子来说明:</p>
<pre><code class="java">public class TestClass {
    public static void main(String[] args) throws ClassNotFoundException {
        System.out.println(TestInitable.num);
        System.out.println(TestInitable2.name);
        System.out.println(TestInitable2.num);
        System.out.println(Class.forName(&quot;com.justyan.TestInitable3&quot;));
        System.out.println(TestInitable4.bean);
        System.out.println(TestInitable5.num);
    }
}
class TestInitable{
    final static int num = 100;
    static{
        System.out.println(&quot;TestInitable is init!!!!&quot;);
    }
}
class TestInitable2{
    static final String name = &quot;YY&quot;;
    static int num = 20;
    static {
        System.out.println(&quot;TestInitable2 is init!!!!!&quot;);
    }
}
class TestInitable3{
    static{
        System.out.println(&quot;TestInitable3 is init!!!!&quot;);
    }
}
class TestInitable4{
    static final TestBean bean = new TestBean();
    static {
        System.out.println(&quot;TestInitable4 is init!!!!!&quot;);
    }
}
class TestInitable5 extends TestInitable{
    static{
        System.out.println(&quot;TestInitable5 is init!!!!&quot;);
    }
}
class TestBean {
    String name;
    static{
        System.out.println(&quot;TestBean is init!!!!&quot;);
    }
}
</code></pre>
<p>这个demo就是通过调用一些类的静态属性,来查看有没有打印类内部的静态代码块,表明这个类对象有没有初始化.<br>先看第一个:</p>
<pre><code class="java">  System.out.println(TestInitable.num);
</code></pre>
<p>由于TestInitable的num属性是 static final的,属于 “编译期常量” ,那么这个值是不需要TestInitable来初始化获取的,所以这个时候 TestInitable对象并不会初始化.内部静态代码块也不会执行,也就不会打印出里面的那条初始化信息.<br>这里只会打印</p>
<pre><code>100
</code></pre><pre><code class="java">System.out.println(TestInitable2.name);
System.out.println(TestInitable2.num);
</code></pre>
<p>第一行和上面的情况一样, <em>name</em> 也是属于 “编译器常量”,所以第一行的时候,TestInitable2是不会初始化,但是第二行的时候由于 <em>num</em> 不是final的,所以不属于 “编译期常量”,那么这个时候就会先执行静态代码块,然后才打印num的值<br>这里会打印:</p>
<pre><code>YY
TestInitable2 is init!!!!!
20
</code></pre><pre><code class="java">    System.out.println(Class.forName(&quot;com.justyan.TestInitable3&quot;));
</code></pre>
<p>如果通过 <em>Class.forName</em> 反射调用的话会直接初始化该类<br>这里会打印初始化信息:</p>
<pre><code>TestInitable3 is init!!!!!
</code></pre><pre><code class="java">  System.out.println(TestInitable4.bean);
</code></pre>
<p>这里由于用到了TestBean对象,故先去加载TestBean对象,执行TestBean的内部静态代码块,然后才是 TestInitable4的初始化<br>这里会答应:</p>
<pre><code>TestBean is init!!!!
TestInitable4 is init!!!!!
com.justyan.TestBean@610455d6
</code></pre><pre><code class="java">  System.out.println(TestInitable5.num);
</code></pre>
<p>这里TestInitable5继承自TestInitable,所以可以获取到里面的num属性.但是不会初始化 TestInitable5,因为那个属性不属于它.<br>这里只会打印</p>
<pre><code>100
</code></pre><p>这里的这种情况比较特殊,需要注意一下.实际上只要调用的父类的静态属性,这里 TestInitable5都不会初始化.</p>
<p>一定要理解 <em>编译期常量</em> 指的是static final的基础类型,不能是对象,如果是对象就不属于 <em>编译期常量</em> ,这个时候对该变量的调用都会导致类的初始化.<br>如果一个static域不是final的,那么对它访问时,总会要求在它被读取之前,要先进行链接(为这个域分配空间) 和初始化 (初始化该空间),就像对前面的TestBean的调用一样.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><java编程思想> 第14章 类型信息</java编程思想></p>
<p><a href="http://blog.csdn.net/xyang81/article/details/7292380" title="深入分析Java ClassLoader原理" target="_blank" rel="external">深入分析Java ClassLoader原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/12/2017/android 开源库NumberProgressBar源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/12/2017/android 开源库NumberProgressBar源码分析/" itemprop="url">android 开源库NumberProgressBar源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-12T15:12:00+08:00">
                2017-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="android-开源库NumberProgressBar源码分析"><a href="#android-开源库NumberProgressBar源码分析" class="headerlink" title="android 开源库NumberProgressBar源码分析"></a>android 开源库NumberProgressBar源码分析</h2><p>  这个view是一个简单的自定义view来实现一个横向进度的效果,左边显示完成的进度条,右边显示未完成的进度条,中间是当前的当前的进度说明.实现的思路非常的简单,就是分别画这个view的3部分,完成+文字+未完成的.<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/12/2017/android 开源库NumberProgressBar源码分析/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/11/2017/android 开源Logger库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/11/2017/android 开源Logger库/" itemprop="url">android 开源Logger库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T09:05:00+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="android-开源Logger库"><a href="#android-开源Logger库" class="headerlink" title="android 开源Logger库"></a>android 开源Logger库</h2><h3 id="需要明白的问题"><a href="#需要明白的问题" class="headerlink" title="需要明白的问题"></a>需要明白的问题</h3><ol>
<li><p>如何打印当前线程的名称的<br>直接Thread.currentThread.getName调用的</p>
</li>
<li><p>如何打印调用方法的名称和行数的<br>通过StackTraceElement来获取到引用的数组</p>
</li>
<li><p>StackTraceElement的概念<br>StackTraceElement是java1.5新增的用来输出方法调用栈信息的对象,通过它我们可以打印出当前线程中方法的调用栈,从里面可以可以获取到方法名称,行数,类名称等我们想要的信息</p>
</li>
<li><p>如何增加分割线的和边框的<br>为了把打印日志用方框圈起来,这里把整个日志分成了两部分,顶部叫header+剩下的我们真正需要的信息.<br>header又包含了当前顶部分割线,线程名称,方法调用栈信息<br>最后再把底部分割线加上,正好组合成一个方框,这个方框是没有右边的,因为分割线都是顶满整行的</p>
</li>
<li><p>如何保证打印日志没有超过最大字符个数限制<br>由于原生api的单次打印最大字符限制是4M,所以判断如果要打印的字符串超过4M就把字符串拆开成多段来分别打印</p>
</li>
<li><p>如何处理JSON数据<br>JSONObject原生api居然提供了一个带缩进的toString方法….<br>同时Arrays居然也提供了一个deepToString的方法…..</p>
</li>
<li><p>如何处理XML<br>通过java提供的Transformer API来打印XML</p>
</li>
</ol>
<h3 id="主要代码分析"><a href="#主要代码分析" class="headerlink" title="主要代码分析"></a>主要代码分析</h3><p>其他的方法都非常简单,核心方法就是下面这个log方法:</p>
<pre><code class="java">@Override public synchronized void log(int priority, String tag, String message, Throwable throwable) {
   if (settings.getLogLevel() == LogLevel.NONE) {
     return;
   }
   if (throwable != null &amp;&amp; message != null) {
     message += &quot; : &quot; + Helper.getStackTraceString(throwable);
   }
   if (throwable != null &amp;&amp; message == null) {
     message = Helper.getStackTraceString(throwable);
   }
   if (message == null) {
     message = &quot;No message/exception is set&quot;;
   }
   int methodCount = getMethodCount();
   if (Helper.isEmpty(message)) {
     message = &quot;Empty/NULL log message&quot;;
   }

   logTopBorder(priority, tag);
   logHeaderContent(priority, tag, methodCount);

   //get bytes of message with system&#39;s default charset (which is UTF-8 for Android)
   byte[] bytes = message.getBytes();
   int length = bytes.length;
   if (length &lt;= CHUNK_SIZE) {
     if (methodCount &gt; 0) {
       logDivider(priority, tag);
     }
     logContent(priority, tag, message);
     logBottomBorder(priority, tag);
     return;
   }
   if (methodCount &gt; 0) {
     logDivider(priority, tag);
   }
   for (int i = 0; i &lt; length; i += CHUNK_SIZE) {
     int count = Math.min(length - i, CHUNK_SIZE);
     //create a new String with system&#39;s default charset (which is UTF-8 for Android)
     logContent(priority, tag, new String(bytes, i, count));
   }
   logBottomBorder(priority, tag);
 }
</code></pre>
<p>注意,这里加锁来保证数据顺序的正确性<br>通过 <em>logHeaderContent(priority, tag, methodCount);</em> 来打印线程信息和方法调用栈信息.</p>
<pre><code class="java">private void logHeaderContent(int logType, String tag, int methodCount) {
   StackTraceElement[] trace = Thread.currentThread().getStackTrace();
   if (settings.isShowThreadInfo()) {
     logChunk(logType, tag, HORIZONTAL_DOUBLE_LINE + &quot; Thread: &quot; + Thread.currentThread().getName());
     logDivider(logType, tag);
   }
   String level = &quot;&quot;;

   int stackOffset = getStackOffset(trace) + settings.getMethodOffset();

   //corresponding method count with the current stack may exceeds the stack trace. Trims the count
   if (methodCount + stackOffset &gt; trace.length) {
     methodCount = trace.length - stackOffset - 1;
   }

   for (int i = methodCount; i &gt; 0; i--) {
     int stackIndex = i + stackOffset;
     if (stackIndex &gt;= trace.length) {
       continue;
     }
     StringBuilder builder = new StringBuilder();
     builder.append(&quot;║ &quot;)
         .append(level)
         .append(getSimpleClassName(trace[stackIndex].getClassName()))
         .append(&quot;.&quot;)
         .append(trace[stackIndex].getMethodName())
         .append(&quot; &quot;)
         .append(&quot; (&quot;)
         .append(trace[stackIndex].getFileName())
         .append(&quot;:&quot;)
         .append(trace[stackIndex].getLineNumber())
         .append(&quot;)&quot;);
     level += &quot;   &quot;;
     logChunk(logType, tag, builder.toString());
   }
 }
</code></pre>
<p>获取到调用栈信息,从第三个开始获取,因为前两个都是系统的调用信息,忽略不计,从第三个开始真正的方法调用的.再加上设置里面要求打印的方法个数,组成了要打印的方法的最终个数.</p>
<pre><code class="java">private int getStackOffset(StackTraceElement[] trace) {
   for (int i = MIN_STACK_OFFSET; i &lt; trace.length; i++) {
     StackTraceElement e = trace[i];
     String name = e.getClassName();
     if (!name.equals(LoggerPrinter.class.getName()) &amp;&amp; !name.equals(Logger.class.getName())) {
       return --i;
     }
   }
   return -1;
 }
</code></pre>
<p>剩下的打印主要信息的时候做个容量判断,如果没超过原声API的最大字符串限制直接打印,如果超了就拆成几段分别打印.</p>
<pre><code class="java">byte[] bytes = message.getBytes();
   int length = bytes.length;
   if (length &lt;= CHUNK_SIZE) {
     if (methodCount &gt; 0) {
       logDivider(priority, tag);
     }
     logContent(priority, tag, message);
     logBottomBorder(priority, tag);
     return;
   }
   if (methodCount &gt; 0) {
     logDivider(priority, tag);
   }
   for (int i = 0; i &lt; length; i += CHUNK_SIZE) {
     int count = Math.min(length - i, CHUNK_SIZE);
     //create a new String with system&#39;s default charset (which is UTF-8 for Android)
     logContent(priority, tag, new String(bytes, i, count));
   }
   logBottomBorder(priority, tag)
</code></pre>
<p>非常的简单.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/orhanobut/logger" title="logger github" target="_blank" rel="external">logger github</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/09/2017/读书笔记/另外8小时/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/09/2017/读书笔记/另外8小时/" itemprop="url">另外8小时</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-09T20:27:00+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="另外8小时-作者-罗伯特-帕利亚里尼-出版社-南海出版社"><a href="#另外8小时-作者-罗伯特-帕利亚里尼-出版社-南海出版社" class="headerlink" title="另外8小时 作者:罗伯特.帕利亚里尼 出版社:南海出版社"></a>另外8小时 作者:罗伯特.帕利亚里尼 出版社:南海出版社</h2><p>  书中主要讲了如何通过工作和睡觉之外的8小时创造价值或者实现人生目标.</p>
<h3 id="如何找回剩下的8小时"><a href="#如何找回剩下的8小时" class="headerlink" title="如何找回剩下的8小时"></a>如何找回剩下的8小时</h3><p>以下有六大策略,可以帮助你尽可能的拿回这剩下的8小时:</p>
<h4 id="掌握你的时间"><a href="#掌握你的时间" class="headerlink" title="掌握你的时间"></a>掌握你的时间</h4><p>通过详细的时间记录来找到时间分配比例,然后把无用的删减,把重要的加重.</p>
<ol>
<li>列出大项</li>
<li>找出活动项目</li>
<li>列出花在每一项活动上面的时间</li>
<li>递延,消除,减少或保持</li>
</ol>
<h4 id="学着说不"><a href="#学着说不" class="headerlink" title="学着说不"></a>学着说不</h4><ol>
<li>避开 (学会拒绝别人,尽快结束无用的对话)</li>
<li>平衡 (保证从一项任务的时间增加,就要有另一项任务的时间减少)</li>
</ol>
<h4 id="从8小时里面变出9小时"><a href="#从8小时里面变出9小时" class="headerlink" title="从8小时里面变出9小时"></a>从8小时里面变出9小时</h4><p>没有钱也没有时间</p>
<ol>
<li>无摩擦互惠 (自己本来要做的顺便也帮着别人做了,之后要求对方也这样帮助自己)</li>
<li>专业分工 (做各自喜欢或者擅长的来与别人交换自己不喜欢或者不擅长的)</li>
</ol>
<p>有钱但没有时间</p>
<ol>
<li>写出攻击目标</li>
<li>最不想做的事</li>
<li>报价</li>
<li>设定预算</li>
<li>实际动手</li>
</ol>
<h4 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h4><p>诀窍在于结合脑力工作和体力工作,选择去做两种不会争夺同样资源的任务.</p>
<ol>
<li>列出无用时间</li>
<li>列出你想多做的有益活动</li>
<li>判定特定活动需要用到的是脑力还是体力</li>
<li>建立链接</li>
</ol>
<h4 id="注入正面因素"><a href="#注入正面因素" class="headerlink" title="注入正面因素"></a>注入正面因素</h4><p>火花指的是正面思考或者正向的做事态度,可以在你的人生中创造出极大的改变,带来不同的结果.</p>
<ol>
<li>选用一种火花</li>
<li>选择在无用时间点火</li>
<li>建立链接</li>
</ol>
<h4 id="善用科技"><a href="#善用科技" class="headerlink" title="善用科技"></a>善用科技</h4><p>(利用各种app,网站来帮助你提高效率,获取信息等等.)</p>
<h3 id="阅读的目的"><a href="#阅读的目的" class="headerlink" title="阅读的目的"></a>阅读的目的</h3><p>除了为自己高兴而阅读,阅读的另一个目的是为了学习.学习不是被动的:若要从投资在阅读的时间上获得最大报酬,你可以从以下秘诀入手.</p>
<ol>
<li>不要浪费时间去读不正确的东西(先略读一遍,了解以下书中的内容,如果看到感兴趣的地方就重点读一下,否则如果啥都没发现就没有读的必要了)</li>
<li>绝对不要在手边没有笔及纸时阅读.在你开始读每一章时,先问问自己从中能学到什么.阅读时,你要记笔记,划重点,在书空白处写下心得,并不断的自问要怎样把所学应用在生活中.</li>
</ol>
<h3 id="100万的问题"><a href="#100万的问题" class="headerlink" title="100万的问题"></a>100万的问题</h3><p>每天不断地问问自己,如果生死就在此一役,要怎样在365天内赚到100万美元? 如果答案仍然相同,你就应该慎重的考虑去完成这件事</p>
<h3 id="这要怎么改善"><a href="#这要怎么改善" class="headerlink" title="这要怎么改善"></a>这要怎么改善</h3><p>你可以挑选心里想到的任务产品或服务,然后在一分钟内尽量想出任何可改善的地方.</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>把每一次接触到的机会当做学习经验,”有时候你赢了,有时候你学到了.”</p>
<h3 id="创8者法则"><a href="#创8者法则" class="headerlink" title="创8者法则"></a>创8者法则</h3><ol>
<li>保有全职工作</li>
<li>核子大爆发 (高杠杆率高回报)</li>
<li>了解你的最高最优用途 (自己做擅长最容易成功的领域)</li>
<li>限制风险</li>
<li>常挥棒 (多试错)</li>
<li>市场 (营销)</li>
<li>货币化 (盈利)</li>
<li>拥有 (所有权)</li>
</ol>
<h3 id="创8者的10大渠道"><a href="#创8者的10大渠道" class="headerlink" title="创8者的10大渠道"></a>创8者的10大渠道</h3><p>想法</p>
<ol>
<li>经营博客</li>
<li>发明</li>
<li>出书,写剧本,创作音乐</li>
</ol>
<p>产品</p>
<ol>
<li>开办公司</li>
<li>经销,策略联盟,授权</li>
<li>善用风尚或噱头</li>
</ol>
<p>时间</p>
<ol>
<li>以服务交换公司股票</li>
<li>推进事业发展或大跃进</li>
<li>成为自由职业者</li>
<li>把闲暇爱好变成收入</li>
</ol>
<h4 id="经营博客的规则"><a href="#经营博客的规则" class="headerlink" title="经营博客的规则"></a>经营博客的规则</h4><ol>
<li>创作有价值的内容</li>
<li>有特色</li>
<li>找出普遍的市场</li>
<li>要有主见</li>
<li>要表现个人的那一面</li>
<li>打造品牌</li>
<li>全力营销你的博客</li>
<li>建立多重收入来源</li>
</ol>
<h3 id="“拥有人生”是什么意思"><a href="#“拥有人生”是什么意思" class="headerlink" title="“拥有人生”是什么意思"></a>“拥有人生”是什么意思</h3><h4 id="少一点"><a href="#少一点" class="headerlink" title="少一点"></a>少一点</h4><ul>
<li>后悔 (我本可以)</li>
</ul>
<ol>
<li>克服你身上背负的后悔</li>
<li>通过防范遗憾发生来战胜未来的遗憾</li>
</ol>
<ul>
<li>恐惧</li>
<li>懒散</li>
<li>生命水蛭</li>
</ul>
<h4 id="多一点"><a href="#多一点" class="headerlink" title="多一点"></a>多一点</h4><ul>
<li>成长</li>
<li>经验</li>
<li>改变</li>
<li>向前看</li>
<li>错误</li>
<li>恐惧</li>
<li>闲暇爱好</li>
<li>感恩</li>
<li>人生目标</li>
<li>方向</li>
<li>人际关系</li>
<li>贡献</li>
<li>学习</li>
<li>行动</li>
</ul>
<h3 id="找到你的人生脉动"><a href="#找到你的人生脉动" class="headerlink" title="找到你的人生脉动"></a>找到你的人生脉动</h3><p>遵循下面6个步骤,你会知道如何运用这剩下的8个小时去实现你的理想:</p>
<ol>
<li>拥抱差距 (定位)</li>
<li>写下座右铭 (信念,人生观,价值观)</li>
<li>判定优先次序 (高收益,低半衰)</li>
<li>设定目标 (SMART)</li>
<li>预期挫折 (WOOP)</li>
<li>养成习惯 (习惯)</li>
</ol>
<h4 id="预期挫折"><a href="#预期挫折" class="headerlink" title="预期挫折"></a>预期挫折</h4><p>下面是一些常见的放弃理由:</p>
<ol>
<li>没有时间</li>
<li>失去动力</li>
<li>分心</li>
<li>害怕失败</li>
</ol>
<h3 id="不要做而言-马上起而行-动起来"><a href="#不要做而言-马上起而行-动起来" class="headerlink" title="不要做而言,马上起而行(动起来)"></a>不要做而言,马上起而行(动起来)</h3><p>以下是培养习惯的9个步骤:</p>
<ol>
<li>写出日程表中的固定事项</li>
<li>改掉你的”早叹” (一日之计在于晨)</li>
<li>找出你一天的可用时间</li>
<li>写出其他固定事项</li>
<li>找到开放的时间</li>
<li>排入你的目标</li>
<li>写出任务</li>
<li>组合多重任务</li>
<li>增强精力</li>
</ol>
<h4 id="改掉你的”早叹”"><a href="#改掉你的”早叹”" class="headerlink" title="改掉你的”早叹”"></a>改掉你的”早叹”</h4><p>每天最初的30分钟拥有强大的力量,能帮助你好好掌握眼前的一天.你每天早上的行为和态度会影响你的感受和当天的所作所为.你要做以下几件简单的事,以比较美妙的基调展开一天的生活:</p>
<ol>
<li>毁掉让你越来越衰弱的”克星石”</li>
<li>善用前五秒</li>
<li>让血液奔腾</li>
<li>力量日志(感恩,新事业点子,未来,灵性,一年赚100美元)</li>
<li>早餐</li>
</ol>
<h4 id="排入你的目标"><a href="#排入你的目标" class="headerlink" title="排入你的目标"></a>排入你的目标</h4><p>当你把目标写入目标行动计划书中时,要注意一下这些因素:</p>
<ol>
<li>精力 (合适的时间做合适的事)</li>
<li>流程 (把适合的活动安排在一起,劳逸结合)</li>
</ol>
<h4 id="增强精力"><a href="#增强精力" class="headerlink" title="增强精力"></a>增强精力</h4><ol>
<li>努力缩短差距</li>
<li>成就</li>
<li>运动</li>
<li>营养</li>
<li>榨出”兴奋”</li>
<li>音乐</li>
<li>电视节目</li>
<li>太阳</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/09/2017/android 自定义URI Router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/09/2017/android 自定义URI Router/" itemprop="url">android 自定义URI Router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-09T10:25:00+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="android-自定义URI-Router"><a href="#android-自定义URI-Router" class="headerlink" title="android 自定义URI Router"></a>android 自定义URI Router</h2><h3 id="关于自定义Router学习之前的预备知识"><a href="#关于自定义Router学习之前的预备知识" class="headerlink" title="关于自定义Router学习之前的预备知识"></a>关于自定义Router学习之前的预备知识</h3><ol>
<li>为什么要使用google的auto-service这个包<br>如何才能获取一个接口的所有实现类?通过反射来遍历所有的类,然后判断该类是否是实现指定的接口,不过这样效率不太高,毕竟得对所有的类进行遍历;还有一种方法就是就是把实现了该接口的类的全路径名称放入一个配置文件中,这样在使用的时候,从配置文件中获取实现类就可以了.有点反着来的意思.那这里配置文件放在哪里呢?放在了jar包里面的META-INF这个文件夹中,这个文件夹中放的是jar包的一些签名和说明文件,通用的定义是把实现接口类的描述文件放在 META-INF/service/接口名称/中.注意,前面的这种方式是需要人工来完成的,每当你调整了实现接口的数量的话,就需要手动更新一下 META-INF文件,但是 auto-service可以自动完成这些工作,这个就是它的作用.<br><img src="images/2017/01/auto-service生成的配置文件.png" alt="auto-service生成的配置文件"></li>
</ol>
<ol>
<li><p>为什么要使用squareup:javapoet这个包<br>用来通过封装的API来生成java源文件,非常的方便,这里还没有深入的学习</p>
</li>
<li><p>java的METE-INF的作用是说明?</p>
<p>jar包中的签名,配置文件,清单文件,还有接口实现类的列表文件</p>
</li>
<li><p>java的serviceLoader类作用</p>
<p>可以从 METE-INF 中取出指定接口的实现类名称列表,方便直接调用</p>
<pre><code class="java">public static void main(String[] args) {

    ServiceLoader&lt;ITest&gt; serviceLoader = ServiceLoader.load(ITest.class);
    for (ITest iTest : serviceLoader) {
        iTest.test();
    }
}
</code></pre>
</li>
<li><p>自定义的注解是怎么起作用的<br>实现步骤如下:</p>
<ol>
<li>顶部工程的gradle中配置:<br>```java<br>dependencies {<br>classpath ‘com.android.tools.build:gradle:2.2.2’<br>….<br>//引入apt插件<br>classpath ‘com.neenbedankt.gradle.plugins:android-apt:1.8’</li>
</ol>
<p>}</p>
<pre><code>2. 主工程的gradle中配置:
```java
apply plugin: &#39;com.neenbedankt.android-apt&#39;
.....
compile project (&#39;:annotationprocessor&#39;)
apt project (&#39;:annotationprocessor&#39;)
</code></pre><p>这里的 <em>annotationprocessor</em> 用来包含自定义的processor的java子工程</p>
<ol>
<li>用来包含自定义processor的java工程中的gradle中配置:<br>```java<br>dependencies {<br>compile fileTree(dir: ‘libs’, include: [‘*.jar’])<br>compile project(‘:annotation’)<br>compile ‘com.google.auto.service:auto-service:1.0-rc2’<br>compile ‘com.squareup:javapoet:1.7.0’<br>}</li>
</ol>
</li>
</ol>
<p>sourceCompatibility = “1.7”<br>targetCompatibility = “1.7”</p>
<pre><code>这里的 *javapoet* 根据需求添加,默认可以不适用.
*annotation* 工程中存放的是自定义的 *annotation* 类文件

4. 最后就是java代码的书写了,首先是一个自定义的java注解类
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface YYAnnotation {
    String value();
}
</code></pre><p>然后是自定义的解析processor</p>
<pre><code class="java">@AutoService(Processor.class)
public class YYAnnotationProcessor extends AbstractProcessor {

    private Filer filer;
    private Messager messager;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnvironment) {
        super.init(processingEnvironment);
        filer = processingEnvironment.getFiler();
        messager = processingEnvironment.getMessager();
    }


    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }
    @Override
    public Set&lt;String&gt; getSupportedAnnotationTypes() {
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        //这里是你要处理注解的集合
        set.add(YYAnnotation.class.getCanonicalName());
        return set;
    }

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        try {
            Set&lt;? extends Element&gt; mainAppElement = roundEnv.getElementsAnnotatedWith(YYAnnotation.class);
            if (!mainAppElement.isEmpty()) {
                //这里实现自己的需求
                process(mainAppElement);
                return true;
            }
        } catch (Exception e) {
            messager.printMessage(Diagnostic.Kind.ERROR, e.getMessage());
        }

        return true;
    }
    private void process(Set&lt;? extends Element&gt; elementsAnnotatedWith) throws IOException {
      TypeElement typeElement = (TypeElement) elementsAnnotatedWith.iterator().next();
      //这里的Config.FILE_NAME是你要生成的java源文件的名称
      JavaFileObject javaFileObject = filer.createSourceFile(Config.FILE_NAME, typeElement);
      //通过printWriter来生成java源文件
      PrintWriter writer = new PrintWriter(javaFileObject.openWriter());
      //这里的Config.PACKAGE_NAME你要生成的java源文件的包名
      writer.println(&quot;package &quot; + Config.PACKAGE_NAME + &quot;;&quot;);
      writer.println(&quot;public class TestProcessor {&quot;);
      writer.println(&quot;public static void test () {&quot;);

      YYAnnotation componentsAnnotation = typeElement.getAnnotation(YYAnnotation.class);
      String components = componentsAnnotation.value();
      writer.println(&quot;System.out.println(\&quot;&quot;+components+&quot;\&quot;);&quot;);

      writer.println(&quot;}&quot;);
      writer.println(&quot;}&quot;);

      writer.flush();
      writer.close();
    }

}
</code></pre>
<p>是不是非常的神奇,你可以再编译之前做一些事情,比如生成一个java文件,或者对一些java源文件做处理等等,给了我们很大的灵活性,在这里我们是通过apt生成了可以打印信息的java类,非常的简单,后期可以根据需求调整成更加复杂的逻辑.</p>
<ol>
<li>如何某个接口的所有实现类或者某个父类的所有子类<br>反射遍历所有的java类文件,找到实现该接口的类名称.</li>
</ol>
<h3 id="别人写的Router框架解析"><a href="#别人写的Router框架解析" class="headerlink" title="别人写的Router框架解析"></a>别人写的Router框架解析</h3><p>首先要明白,Router的真正的作用是用在模块之间的解耦上,我们都知道android可以分为主工程+多个library,多个library可以作为单独module的体现,这里Router的作用就是可以让多个library互相之间调用各自的页面,service或者广播,而不用互相知道对方的具体类名称等信息,达到了内部解耦的功能.<br>先看工程目录结构:<br><img src="/images/2017/01/router工程目录结构.png" alt="router工程目录结构"></p>
<p>这里主要的功能实现就在 annotation,router,routerhelper中实现的.其他的两个shoplib和bbslib代表了两个独立模块.主工程app,uitlslib和reslib内部定义了一些工具类,这里不过多的介绍了.</p>
<h4 id="annotation工程"><a href="#annotation工程" class="headerlink" title="annotation工程"></a>annotation工程</h4><p>首先来看annotation,这个工程主要放置的是关于Router定义的各种注解.是一个纯java工程.<br><img src="/images/2017/01/annotation项目类定义.png" alt=""></p>
<p>其中, <em>AutoRouter</em> , <em>StaticRouter</em> 是router注解的两种模式,分别对应自动根据绑定的class类型来给URI添加对应的前缀,比如如果绑定的是activity则前缀为 <em>activity://</em> ,而后者则是完全按照注解的value值来作为绑定的URI.这个后续在代码中就明白怎么用了.<br><em>Components</em> 对应所有模块的注解,主要用在application中声明都有那几个需要Router的模块.<br><em>Component</em> 对应每个独立的模块<br>下面来看代码定义,非常的简单,就是普通的java注解声明:</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface AutoRouter {
}
</code></pre>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface StaticRouter {
    String value();
}
</code></pre>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface Component {
    String value();
}
</code></pre>
<pre><code class="java">@Retention(RetentionPolicy.CLASS)
@Target(ElementType.TYPE)
public @interface Components {
    String[] value();
}
</code></pre>
<h4 id="routerhelper工程"><a href="#routerhelper工程" class="headerlink" title="routerhelper工程"></a>routerhelper工程</h4><p>上面再 <em>annotation</em> 项目中完成了注解的定义,那势必会有一个 <em>processor</em> 来完成注解的解析和逻辑处理,这里如果对注解的处理流程不是很熟悉的话可以看下相关的java注解处理的资源.这里就不重点介绍了.直接进入 <em>RouterHelper</em> 这个解析注解类中.</p>
<pre><code class="java">@AutoService(Processor.class)
public class RouterProcessor extends AbstractProcessor {

    private Filer mFiler;
    private Messager mMessager;

    private Map&lt;String, String&gt; mStaticRouterMap = new HashMap&lt;&gt;();
    private List&lt;String&gt; mAutoRouterList = new ArrayList&lt;&gt;();

    @Override
    public synchronized void init(ProcessingEnvironment processingEnvironment) {
        super.init(processingEnvironment);
        mFiler = processingEnvironment.getFiler();
        mMessager = processingEnvironment.getMessager();
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    @Override
    public Set&lt;String&gt; getSupportedAnnotationTypes() {
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        set.add(AutoRouter.class.getCanonicalName());
        set.add(StaticRouter.class.getCanonicalName());
        set.add(Component.class.getCanonicalName());
        set.add(Components.class.getCanonicalName());
        return set;
    }

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) {
        mStaticRouterMap.clear();
        mAutoRouterList.clear();

        try {
            Set&lt;? extends Element&gt; mainAppElement = roundEnvironment.getElementsAnnotatedWith(Components.class);
            if (!mainAppElement.isEmpty()) {
                processInstaller(mainAppElement);
                return true;
            }
            processComponent(roundEnvironment);
        } catch (Exception e) {
            mMessager.printMessage(Diagnostic.Kind.ERROR, e.getMessage());
        }

        return true;
    }

    private void processInstaller(Set&lt;? extends Element&gt; mainAppElement) throws IOException {
        TypeElement typeElement = (TypeElement) mainAppElement.iterator().next();
        JavaFileObject javaFileObject = mFiler.createSourceFile(Config.ROUTER_MANAGER, typeElement);
        PrintWriter writer = new PrintWriter(javaFileObject.openWriter());

        writer.println(&quot;package &quot; + Config.PACKAGE_NAME + &quot;;&quot;);
        writer.println(&quot;public class &quot; + Config.ROUTER_MANAGER + &quot; {&quot;);
        writer.println(&quot;public static void &quot; + Config.ROUTER_MANAGER_METHOD + &quot;() {&quot;);

        Components componentsAnnotation = typeElement.getAnnotation(Components.class);
        String[] components = componentsAnnotation.value();
        for (String item : components) {
            writer.println(Config.FILE_PREFIX + item + &quot;.router();&quot;);
        }

        writer.println(&quot;}&quot;);
        writer.println(&quot;}&quot;);

        writer.flush();
        writer.close();
    }

    private void processComponent(RoundEnvironment roundEnvironment) throws Exception {
        Set&lt;? extends Element&gt; compElements = roundEnvironment.getElementsAnnotatedWith(Component.class);
        if (compElements.isEmpty()) { return;}

        Element item = compElements.iterator().next();
        String componentName = item.getAnnotation(Component.class).value();

        Set&lt;? extends Element&gt; routerElements = roundEnvironment.getElementsAnnotatedWith(StaticRouter.class);
        for (Element e : routerElements) {
            if (! (e instanceof TypeElement)) { continue;}
            TypeElement typeElement = (TypeElement) e;
            String pattern = typeElement.getAnnotation(StaticRouter.class).value();
            mStaticRouterMap.put(pattern, typeElement.getQualifiedName().toString());
        }

        Set&lt;? extends Element&gt; autoRouterElements = roundEnvironment.getElementsAnnotatedWith(AutoRouter.class);
        for (Element e : autoRouterElements) {
            if (!(e instanceof TypeElement)) { continue;}
            TypeElement typeElement = (TypeElement) e;
            mAutoRouterList.add(typeElement.getQualifiedName().toString());
        }

        writeComponentFile(componentName);
    }

    private void writeComponentFile(String componentName) throws Exception {
        String className = Config.FILE_PREFIX + componentName;
        JavaFileObject javaFileObject = mFiler.createSourceFile(className);
//        javaFileObject.delete();

        PrintWriter printWriter = new PrintWriter(javaFileObject.openWriter());

        printWriter.println(&quot;package &quot; + Config.PACKAGE_NAME + &quot;;&quot;);

        printWriter.println(&quot;import android.app.Activity;&quot;);
        printWriter.println(&quot;import android.app.Service;&quot;);
        printWriter.println(&quot;import android.content.BroadcastReceiver;&quot;);

        printWriter.println(&quot;public class &quot; + className + &quot; {&quot;);
        printWriter.println(&quot;public static void router() {&quot;);

        // // Router.router(ActivityRule.ACTIVITY_SCHEME + &quot;shop.main&quot;, ShopActivity.class);
        for(Map.Entry&lt;String, String&gt; entry : mStaticRouterMap.entrySet()) {
            printWriter.println(&quot;org.loader.router.Router.router(\&quot;&quot; + entry.getKey()
                    +&quot;\&quot;, &quot;+entry.getValue()+&quot;.class);&quot;);
        }

        for (String klass : mAutoRouterList) {
            printWriter.println(&quot;if (Activity.class.isAssignableFrom(&quot; + klass + &quot;.class)) {&quot;);
            printWriter.println(&quot;org.loader.router.Router.router(org.loader.router.rule.ActivityRule.ACTIVITY_SCHEME + \&quot;&quot;
                    +klass+&quot;\&quot;, &quot; + klass + &quot;.class);&quot;);
            printWriter.println(&quot;}&quot;);

            printWriter.println(&quot;else if (Service.class.isAssignableFrom(&quot; + klass + &quot;.class)) {&quot;);
            printWriter.println(&quot;org.loader.router.Router.router(org.loader.router.rule.ServiceRule.SERVICE_SCHEME + \&quot;&quot;
                    +klass+&quot;\&quot;, &quot; + klass + &quot;.class);&quot;);
            printWriter.println(&quot;}&quot;);

            printWriter.println(&quot;else if (BroadcastReceiver.class.isAssignableFrom(&quot; + klass + &quot;.class)) {&quot;);
            printWriter.println(&quot;org.loader.router.Router.router(org.loader.router.rule.ReceiverRule.RECEIVER_SCHEME + \&quot;&quot;
                    +klass+&quot;\&quot;, &quot;+klass+&quot;.class);&quot;);
            printWriter.println(&quot;}&quot;);
        }

        printWriter.println(&quot;}&quot;);
        printWriter.println(&quot;}&quot;);
        printWriter.flush();
        printWriter.close();
    }
}
</code></pre>
<p>首先在顶部声明了 <em>AutoService</em> 对应本文最上面提到的它的作用用来更新METE-INF中接口的列表文件的.这样可以快速找到工程都有哪些 <em>processor</em> .</p>
<pre><code class="java">@Override
public Set&lt;String&gt; getSupportedAnnotationTypes() {
    Set&lt;String&gt; set = new HashSet&lt;&gt;();
    set.add(AutoRouter.class.getCanonicalName());
    set.add(StaticRouter.class.getCanonicalName());
    set.add(Component.class.getCanonicalName());
    set.add(Components.class.getCanonicalName());
    return set;
}
</code></pre>
<p>用来声明这个processor可以支持处理哪些注解.是一个set集合<br>mFiler可以用来生成一些自定义的源文件,class或其他文件.<br>mMessager 可以把错误信息打印出来<br>重点解析注解的逻辑就在 <em>process</em> 方法中.</p>
<pre><code class="java">Set&lt;? extends Element&gt; mainAppElement = roundEnvironment.getElementsAnnotatedWith(Components.class);
if (!mainAppElement.isEmpty()) {
    processInstaller(mainAppElement);
    return true;
}
</code></pre>
<p>来看第一个关键点,先是找到所有声明 <em>Components</em> 的类对象,这里注意由于 <em>Components</em> 声明的是 <em>ElementType.TYPE</em> 表明只能在类顶部定义,那么这里找到的element都是TypeElement表示类元素.<br>前面说到 <em>Components</em> 的作用是用来表示都有哪些模块需要Router的.比如这里在Application顶部声明了:</p>
<pre><code class="java">
@Components({&quot;shop&quot;, &quot;bbs&quot;})
public class App extends MultiDexApplication {
  ....
}
</code></pre>
<p>说明了有两个工程工程需要Router功能,对应上面说的 shop和bbs两个模块.<br>回到 <em>process</em> 方法中,找到了 <em>Components</em> 的声明类并且不为空的话就进入 <em>processInstaller</em> 方法</p>
<pre><code class="java">private void processInstaller(Set&lt;? extends Element&gt; mainAppElement) throws IOException {
       TypeElement typeElement = (TypeElement) mainAppElement.iterator().next();
       JavaFileObject javaFileObject = mFiler.createSourceFile(Config.ROUTER_MANAGER, typeElement);
       PrintWriter writer = new PrintWriter(javaFileObject.openWriter());

       writer.println(&quot;package &quot; + Config.PACKAGE_NAME + &quot;;&quot;);
       writer.println(&quot;public class &quot; + Config.ROUTER_MANAGER + &quot; {&quot;);
       writer.println(&quot;public static void &quot; + Config.ROUTER_MANAGER_METHOD + &quot;() {&quot;);

       Components componentsAnnotation = typeElement.getAnnotation(Components.class);
       String[] components = componentsAnnotation.value();
       for (String item : components) {
           writer.println(Config.FILE_PREFIX + item + &quot;.router();&quot;);
       }

       writer.println(&quot;}&quot;);
       writer.println(&quot;}&quot;);

       writer.flush();
       writer.close();
   }
</code></pre>
<p>可以看到这里,通过mFiler对象创建了新的java源文件,位于 <em>Config.PACKAGE_NAME</em> 中的叫做 <em>Config.ROUTER_MANAGER</em> 的java文件,其内部定义了一个 <em>Config.ROUTER_MANAGER_METHOD</em> 方法,我们可以在编译完成后,在我们的工程中对应的目录中找到这个生成的源文件.<br><img src="/images/2017/01/processor生成的java源码.png" alt="processor生成的java源码"></p>
<p>看到这里就发现我们居然可以自己生成java源文件,简直是打开了新世界的大门啊,用java来写java源文件,这本身就有种递归的感觉在里边,通过想象,我们可以做很多事情了,这个后续我们可以研究一下更多的用法.<br>生成的java类中的方法调用了每个模块的Router类的Router方法.可以看到这个Router是红色的,但是搜索一下发现,这个类居然也是生成的.那我们可以发现这个类肯定是通过 <em>processor</em> 方法中剩下那句代码来完成, 进入 <em>processComponent(roundEnvironment);</em></p>
<pre><code class="java">private void processComponent(RoundEnvironment roundEnvironment) throws Exception {
       Set&lt;? extends Element&gt; compElements = roundEnvironment.getElementsAnnotatedWith(Component.class);
       if (compElements.isEmpty()) { return;}

       Element item = compElements.iterator().next();
       String componentName = item.getAnnotation(Component.class).value();

       Set&lt;? extends Element&gt; routerElements = roundEnvironment.getElementsAnnotatedWith(StaticRouter.class);
       for (Element e : routerElements) {
           if (! (e instanceof TypeElement)) { continue;}
           TypeElement typeElement = (TypeElement) e;
           String pattern = typeElement.getAnnotation(StaticRouter.class).value();
           mStaticRouterMap.put(pattern, typeElement.getQualifiedName().toString());
       }

       Set&lt;? extends Element&gt; autoRouterElements = roundEnvironment.getElementsAnnotatedWith(AutoRouter.class);
       for (Element e : autoRouterElements) {
           if (!(e instanceof TypeElement)) { continue;}
           TypeElement typeElement = (TypeElement) e;
           mAutoRouterList.add(typeElement.getQualifiedName().toString());
       }

       writeComponentFile(componentName);
   }
</code></pre>
<p>可以看到,这里也很好理解,把所有的router声明类和URI放入集合中.通过后面的 <em>writeComponentFile</em> 方法来完成每个工程自己的router类生成.<br>之前读到这里这里的时候有个问题一直不明白:就是很明显关于 <em>Component</em> 注解应该有两个啊,但是这里却只是通过iterator的next方法获取注解集合中的一个然就去生成router类,那不就少了另外一个 <em>Component</em> 吗?,也就是说一个shop,一个bbs,都是注册了 <em>Component</em> 注解的,但是这里确只是从集合中取了一个,那后面那个就没人管了,岂不是少了一个.后来想明白了:<br>每个工程都是单独的调用 <em>processor</em> 来完成注解解析的,也就是说 shop工程中会调用一次这个 <em>processor</em> ,bbs工程中也会调用一次这个 <em>processor</em> ,这样关于 <em>component</em> 注解的处理就会执行两次,同时为每个模块各自生成一个 Router类.</p>
<pre><code class="java">private void writeComponentFile(String componentName) throws Exception {
      String className = Config.FILE_PREFIX + componentName;
      JavaFileObject javaFileObject = mFiler.createSourceFile(className);
//        javaFileObject.delete();

      PrintWriter printWriter = new PrintWriter(javaFileObject.openWriter());

      printWriter.println(&quot;package &quot; + Config.PACKAGE_NAME + &quot;;&quot;);

      printWriter.println(&quot;import android.app.Activity;&quot;);
      printWriter.println(&quot;import android.app.Service;&quot;);
      printWriter.println(&quot;import android.content.BroadcastReceiver;&quot;);

      printWriter.println(&quot;public class &quot; + className + &quot; {&quot;);
      printWriter.println(&quot;public static void router() {&quot;);

      // // Router.router(ActivityRule.ACTIVITY_SCHEME + &quot;shop.main&quot;, ShopActivity.class);
      for(Map.Entry&lt;String, String&gt; entry : mStaticRouterMap.entrySet()) {
          printWriter.println(&quot;org.loader.router.Router.router(\&quot;&quot; + entry.getKey()
                  +&quot;\&quot;, &quot;+entry.getValue()+&quot;.class);&quot;);
      }

      for (String klass : mAutoRouterList) {
          printWriter.println(&quot;if (Activity.class.isAssignableFrom(&quot; + klass + &quot;.class)) {&quot;);
          printWriter.println(&quot;org.loader.router.Router.router(org.loader.router.rule.ActivityRule.ACTIVITY_SCHEME + \&quot;&quot;
                  +klass+&quot;\&quot;, &quot; + klass + &quot;.class);&quot;);
          printWriter.println(&quot;}&quot;);

          printWriter.println(&quot;else if (Service.class.isAssignableFrom(&quot; + klass + &quot;.class)) {&quot;);
          printWriter.println(&quot;org.loader.router.Router.router(org.loader.router.rule.ServiceRule.SERVICE_SCHEME + \&quot;&quot;
                  +klass+&quot;\&quot;, &quot; + klass + &quot;.class);&quot;);
          printWriter.println(&quot;}&quot;);

          printWriter.println(&quot;else if (BroadcastReceiver.class.isAssignableFrom(&quot; + klass + &quot;.class)) {&quot;);
          printWriter.println(&quot;org.loader.router.Router.router(org.loader.router.rule.ReceiverRule.RECEIVER_SCHEME + \&quot;&quot;
                  +klass+&quot;\&quot;, &quot;+klass+&quot;.class);&quot;);
          printWriter.println(&quot;}&quot;);
      }

      printWriter.println(&quot;}&quot;);
      printWriter.println(&quot;}&quot;);
      printWriter.flush();
      printWriter.close();
  }
</code></pre>
<p>这个 <em>writeComponentFile</em> 方法就是用来完成Router注册的,可以看到很直白的java代码,把java代码作为输入交给pritWriter来写入指定的文件中.<br>来看下两个生成的Router类的代码:</p>
<pre><code class="java">package org.loader.router;
import android.app.Activity;
import android.app.Service;
import android.content.BroadcastReceiver;
public class Router_bbs {
public static void router() {
if (Activity.class.isAssignableFrom(org.loader.bbslib.BBSActivity.class)) {
org.loader.router.Router.router(org.loader.router.rule.ActivityRule.ACTIVITY_SCHEME + &quot;org.loader.bbslib.BBSActivity&quot;, org.loader.bbslib.BBSActivity.class);
}
else if (Service.class.isAssignableFrom(org.loader.bbslib.BBSActivity.class)) {
org.loader.router.Router.router(org.loader.router.rule.ServiceRule.SERVICE_SCHEME + &quot;org.loader.bbslib.BBSActivity&quot;, org.loader.bbslib.BBSActivity.class);
}
else if (BroadcastReceiver.class.isAssignableFrom(org.loader.bbslib.BBSActivity.class)) {
org.loader.router.Router.router(org.loader.router.rule.ReceiverRule.RECEIVER_SCHEME + &quot;org.loader.bbslib.BBSActivity&quot;, org.loader.bbslib.BBSActivity.class);
}
}
}
</code></pre>
<pre><code class="java">package org.loader.router;
import android.app.Activity;
import android.app.Service;
import android.content.BroadcastReceiver;
public class Router_shop {
public static void router() {
org.loader.router.Router.router(&quot;activity://shop.main&quot;, org.loader.shoplib.ShopActivity.class);
}
}
</code></pre>
<p>可以看到这两个通过代码生成源文件最后都是进入了Router类的router方法.<br>到这里关于注解的解析就完成,下面开始进入的Router的核心实现.</p>
<h3 id="router工程"><a href="#router工程" class="headerlink" title="router工程"></a>router工程</h3><p>到这里,才算真正开始Router核心实现,要知道两个模块互相调用对方的元素,而又不直接调用,势必会有一个中间的东西来完成Router功能,首先是每个模块把自己的对外开放的元素注册到中间人,然后在需要调用别的模块的元素的时候,通过URI从中间人中来匹配找到对方的元素.这就是一个完成的Router流程.<br>很明显,需要一个map结构,key是URI,value是对应的class对象或者className.<br>上面每个模块的Router类都是最终调用的这个工程的Router类的router方法:</p>
<pre><code class="java">public class Router {

    /**
     * 添加自定义路由规则
     * @param scheme 路由scheme
     * @param rule 路由规则
     * @return {@code RouterInternal} Router真实调用类
     */
    public static RouterInternal addRule(String scheme, Rule rule) {
        RouterInternal router = RouterInternal.get();
        router.addRule(scheme, rule);
        return router;
    }

    /**
     * 添加路由
     * @param pattern 路由uri
     * @param klass 路由class
     * @return {@code RouterInternal} Router真实调用类
     */
    public static &lt;T&gt; RouterInternal router(String pattern, Class&lt;T&gt; klass) {
        return RouterInternal.get().router(pattern, klass);
    }

    /**
     * 路由调用
     * @param ctx Context
     * @param pattern 路由uri
     * @return {@code V} 返回对应的返回值
     */
    public static &lt;V&gt; V invoke(Context ctx, String pattern) {
        return RouterInternal.get().invoke(ctx, pattern);
    }

    /**
     * 是否存在该路由
     * @param pattern
     * @return
     */
    public static boolean resolveRouter(String pattern) {
        return RouterInternal.get().resolveRouter(pattern);
    }
}
</code></pre>
<p>这个router方法就是用来注册URI的.<br>可以看到所有的逻辑都是在 <em>RouterInternal</em> 中实现的.</p>
<pre><code class="java">public class RouterInternal {

    private static RouterInternal sInstance;

    /** scheme-&gt;路由规则 */
    private HashMap&lt;String, Rule&gt; mRules;

    private RouterInternal() {
        mRules = new HashMap&lt;&gt;();
        initDefaultRouter();
    }

    /**
     * 添加默认的Activity，Service，Receiver路由
     */
    private void initDefaultRouter() {
        addRule(ActivityRule.ACTIVITY_SCHEME, new ActivityRule());
        addRule(ServiceRule.SERVICE_SCHEME, new ServiceRule());
        addRule(ReceiverRule.RECEIVER_SCHEME, new ReceiverRule());
    }

    /*package */ static RouterInternal get() {
        if (sInstance == null) {
            synchronized (RouterInternal.class) {
                if (sInstance == null) {
                    sInstance = new RouterInternal();
                }
            }
        }

        return sInstance;
    }

    /**
     * 添加自定义路由规则
     * @param scheme 路由scheme
     * @param rule 路由规则
     * @return {@code RouterInternal} Router真实调用类
     */
    public final RouterInternal addRule(String scheme, Rule rule) {
        mRules.put(scheme, rule);
        return this;
    }

    private &lt;T, V&gt; Rule&lt;T, V&gt; getRule(String pattern) {
        HashMap&lt;String, Rule&gt; rules = mRules;
        Set&lt;String&gt; keySet = rules.keySet();
        Rule&lt;T, V&gt; rule = null;
        for (String scheme : keySet) {
            if (pattern.startsWith(scheme)) {
                rule = rules.get(scheme);
                break;
            }
        }

        return rule;
    }

    /**
     * 添加路由
     * @param pattern 路由uri
     * @param klass 路由class
     * @return {@code RouterInternal} Router真实调用类
     */
    public final &lt;T&gt; RouterInternal router(String pattern, Class&lt;T&gt; klass) {
        Rule&lt;T, ?&gt; rule = getRule(pattern);
        if (rule == null) {
            throw new NotRouteException(&quot;unknown&quot;, pattern);
        }

        rule.router(pattern, klass);
        return this;
    }

    /**
     * 路由调用
     * @param ctx Context
     * @param pattern 路由uri
     * @return {@code V} 返回对应的返回值
     */
    /*package*/ final &lt;V&gt; V invoke(Context ctx, String pattern) {
        Rule&lt;?, V&gt; rule = getRule(pattern);
        if (rule == null) {
            throw new NotRouteException(&quot;unknown&quot;, pattern);
        }

        return rule.invoke(ctx, pattern);
    }

    /**
     * 是否存在该路由
     * @param pattern
     * @return
     */
    final boolean resolveRouter(String pattern) {
        Rule&lt;?, ?&gt; rule = getRule(pattern);
        return rule != null &amp;&amp; rule.resolveRule(pattern);
    }
}
</code></pre>
<p>这里 <em>RouterInternal</em> 对象通过一个两层map结构来完成路由功能,第一层就是pattern—&gt;rule对象,第二次是rule对象内部的pattern—–&gt;class对象.这样有什么好处呢?可以看到通过 <em>initDefaultRouter</em> 预置了3个默认的rule对象在 <em>RouterInternal</em> 内部的map中,分别对应activity,service和广播.然后每次先通过pattern来找到这3个内置rule中的一个,然后才把pattern和class对象放入rule对象中.<br>这样的好处是便于管理,所有的activity都放入一个rule对象的,所有的service都放入同一个rule中,结构非常的清晰,同时也节约了内存.</p>
<pre><code class="java">public interface Rule&lt;T, V&gt; {
    /**
     * 添加路由
     * @param pattern 路由uri
     * @param klass 路由class
     */
    void router(String pattern, Class&lt;T&gt; klass);

    /**
     * 路由调用
     * @param ctx Context
     * @param pattern 路由uri
     * @return {@code V} 返回对应的返回值
     */
    V invoke(Context ctx, String pattern);

    /**
     * 查看是否存在pattern对应的路由
     * @param pattern
     * @return
     */
    boolean resolveRule(String pattern);
}
</code></pre>
<p>rule是一个map结构的对象,用来URI匹配的细分,具体实现在 <em>BaseInternRule</em> 中</p>
<pre><code class="java">public abstract class BaseIntentRule&lt;T&gt; implements Rule&lt;T, Intent&gt; {

    private HashMap&lt;String, Class&lt;T&gt;&gt; mIntentRules;

    public BaseIntentRule() {
        mIntentRules = new HashMap&lt;&gt;();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void router(String pattern, Class&lt;T&gt; klass) {
        mIntentRules.put(pattern, klass);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Intent invoke(Context ctx, String pattern) {
        Class&lt;T&gt; klass = mIntentRules.get(pattern);
        if (klass == null) { throwException(pattern);}
        return new Intent(ctx, klass);
    }

    @Override
    public boolean resolveRule(String pattern) {
        return mIntentRules.get(pattern) != null;
    }

    /**
     * 当找不到路由规则时抛出异常
     * @param pattern 路由pattern
     */
    public abstract void throwException(String pattern);

}
</code></pre>
<p>可以看到这里就是一个简单的map结构<br>剩下的 <em>ActivityRule</em> ,<em>ReceiverRule</em> ,<em>ServiceRule</em> 都是继承自 <em>BaseIntentRule</em> 中,内部定义了各自的前缀.</p>
<p>到这里router的核心逻辑就完成了,下面来看怎么用的</p>
<h3 id="app工程的router调用"><a href="#app工程的router调用" class="headerlink" title="app工程的router调用"></a>app工程的router调用</h3><pre><code class="java">
@Components({&quot;shop&quot;, &quot;bbs&quot;})
public class App extends MultiDexApplication {

    @Override
    public void onCreate() {
        super.onCreate();
        setupRouter();
        Logger.dump(&quot;TAG&quot;, &quot;application: &quot; + getClass().getName());
    }

    private void setupRouter() {
        RouterHelper.install();

//        Router.router(ActivityRule.ACTIVITY_SCHEME + &quot;shop.main&quot;, ShopActivity.class);
//        Router.router(ActivityRule.ACTIVITY_SCHEME + &quot;bbs.main&quot;, BBSActivity.class);
    }
}
</code></pre>
<p>在工程的总入口application对象中完成了模块的注册,同是调用了 <em>RouterHelper.install();</em></p>
<pre><code class="java">public class RouterHelper {

    public static void install() {
        try {
            Class&lt;?&gt; klass = Class.forName(Config.PACKAGE_NAME + &quot;.&quot; + Config.ROUTER_MANAGER);
            Method method = klass.getDeclaredMethod(Config.ROUTER_MANAGER_METHOD);
            method.invoke(null);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

    }
}
</code></pre>
<p>这里就是通过反射来找到上面那个 <em>processor</em> 生成的java源文件,调用里面的唯一方法.完成router的注册的.</p>
<p>再看两个子模块是怎么互相调用对方的</p>
<h3 id="shop工程"><a href="#shop工程" class="headerlink" title="shop工程"></a>shop工程</h3><pre><code class="java">@Component(&quot;shop&quot;)
public class Shop {
}
</code></pre>
<pre><code class="java">@StaticRouter(ActivityRule.ACTIVITY_SCHEME + &quot;shop.main&quot;)
public class ShopActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        TextView tv = new TextView(this);
        tv.setTextSize(50);
        tv.setText(&quot;SHOP!!!&quot;);
        setContentView(tv);

        Logger.dump(&quot;TAG&quot;, &quot;Hei! I am shop!!!&quot;);
        UseContext.use(Application.get());

        tv.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(ShopActivity.this, getResources().getString(R.string.click_notice), Toast.LENGTH_SHORT).show();
                if (Router.resolveRouter(ActivityRule.ACTIVITY_SCHEME + &quot;org.loader.bbslib.BBSActivity&quot;)) {
                    Intent it = org.loader.router.Router.invoke(ShopActivity.this, ActivityRule.ACTIVITY_SCHEME + &quot;org.loader.bbslib.BBSActivity&quot;);
                    startActivity(it);
                }
            }
        });
    }
}
</code></pre>
<p>可以看到这里通过Shop对象完成模块的注册,最后在textView的跳转是调用 <em>Router的invoke</em> 方法来找到bbs的制定页面.<br>这里的注册用是 <em>StaticRouter</em> 所以要写完整的URI路径.</p>
<h3 id="bbs工程"><a href="#bbs工程" class="headerlink" title="bbs工程"></a>bbs工程</h3><pre><code class="java">@Component(&quot;bbs&quot;)
public class BBS {
}
</code></pre>
<pre><code class="java">
@AutoRouter
public class BBSActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        TextView tv = new TextView(this);
        tv.setTextSize(50);
        tv.setText(&quot;BBS!!!&quot;);
        setContentView(tv);

        Logger.dump(&quot;TAG&quot;, &quot;Hei! I am bbs!!!&quot;);
        UseContext.use(Application.get());

        tv.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(BBSActivity.this, getResources().getString(R.string.click_notice), Toast.LENGTH_SHORT).show();
                if (Router.resolveRouter(ActivityRule.ACTIVITY_SCHEME + &quot;shop.main&quot;)) {
                    Intent it = Router.invoke(BBSActivity.this, ActivityRule.ACTIVITY_SCHEME + &quot;shop.main&quot;);
                    startActivity(it);
                }
            }
        });
    }
}
</code></pre>
<p>这里的注册用的 <em>AutoRouter</em> 所以不需要写URI,自动生成的URI是 类型+类的全路径</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到 Router结构实际上就是通过一个URI找到对方的制定类.结构非常简单.之所以用了多点的时间主要是用来消化注解的相关处理逻辑,用着方便,但是要理解还是要话点时间的.<br>不过这种通过注解来生成中间类,最终达到解耦目的的思路非常值得尝试.开阔了视野.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/qibin0506/Module2Module" title="Module2Module" target="_blank" rel="external">Module2Module</a></p>
<p><a href="http://blog.csdn.net/qibin0506/article/details/53373412" title="Android路由实现" target="_blank" rel="external">Android路由实现</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/04/2017/java线程池源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/04/2017/java线程池源码分析/" itemprop="url">java线程池源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-04T08:27:00+08:00">
                2017-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java线程池源码分析"><a href="#java线程池源码分析" class="headerlink" title="java线程池源码分析"></a>java线程池源码分析</h2><h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><pre><code class="java">public interface Executor {
    void execute(Runnable command);
}
</code></pre>
<p>线程池的基础接口</p>
<h3 id="ExecutorService接口方法"><a href="#ExecutorService接口方法" class="headerlink" title="ExecutorService接口方法"></a>ExecutorService接口方法</h3><pre><code class="java">public interface ExecutorService extends Executor {


    void shutdown();


    List&lt;Runnable&gt; shutdownNow();


    boolean isShutdown();


    boolean isTerminated();


    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;


    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);


    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);


    Future&lt;?&gt; submit(Runnable task);


    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        throws InterruptedException;

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        throws InterruptedException, ExecutionException;


    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>
<p>线程池相关操作的定义接口</p>
<h3 id="RunnableFuture-接口"><a href="#RunnableFuture-接口" class="headerlink" title="RunnableFuture 接口"></a>RunnableFuture 接口</h3><pre><code class="java">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
</code></pre>
<p>通过适配器把两个不相关的对象组合在一起了.</p>
<h3 id="Future-和-FutureTask"><a href="#Future-和-FutureTask" class="headerlink" title="Future 和 FutureTask"></a>Future 和 FutureTask</h3><pre><code class="java">public interface Future&lt;V&gt; {


    boolean cancel(boolean mayInterruptIfRunning);


    boolean isCancelled();

    boolean isDone();


    V get() throws InterruptedException, ExecutionException;


    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>
<p>FutureTask是实现返回值的关键类,里面的核心方法就是 <em>get</em> 方法,下面来看一下具体实现:</p>
<pre><code class="java">public V get() throws InterruptedException, ExecutionException {
       int s = state;
       if (s &lt;= COMPLETING)
           s = awaitDone(false, 0L);
       return report(s);
   }

   /**
    * @throws CancellationException {@inheritDoc}
    */
   public V get(long timeout, TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
       if (unit == null)
           throw new NullPointerException();
       int s = state;
       if (s &lt;= COMPLETING &amp;&amp;
           (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)
           throw new TimeoutException();
       return report(s);
   }
</code></pre>
<p>很明显的就是通过state的状态来判断是否需要返回结果,还没有完成就进入 <em>awaitDone</em> ,目的是为了在结果没有返回的时候阻塞等待.</p>
<pre><code class="java">private int awaitDone(boolean timed, long nanos)
       throws InterruptedException {
       // The code below is very delicate, to achieve these goals:
       // - call nanoTime exactly once for each call to park
       // - if nanos &lt;= 0, return promptly without allocation or nanoTime
       // - if nanos == Long.MIN_VALUE, don&#39;t underflow
       // - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic
       //   and we suffer a spurious wakeup, we will do no worse than
       //   to park-spin for a while
       long startTime = 0L;    // Special value 0L means not yet parked
       WaitNode q = null;
       boolean queued = false;
       for (;;) {
           int s = state;
           if (s &gt; COMPLETING) {
               if (q != null)
                   q.thread = null;
               return s;
           }
           else if (s == COMPLETING)
               // We may have already promised (via isDone) that we are done
               // so never return empty-handed or throw InterruptedException
               Thread.yield();
           else if (Thread.interrupted()) {
               removeWaiter(q);
               throw new InterruptedException();
           }
           else if (q == null) {
               if (timed &amp;&amp; nanos &lt;= 0L)
                   return s;
               q = new WaitNode();
           }
           else if (!queued)
               queued = U.compareAndSwapObject(this, WAITERS,
                                               q.next = waiters, q);
           else if (timed) {
               final long parkNanos;
               if (startTime == 0L) { // first time
                   startTime = System.nanoTime();
                   if (startTime == 0L)
                       startTime = 1L;
                   parkNanos = nanos;
               } else {
                   long elapsed = System.nanoTime() - startTime;
                   if (elapsed &gt;= nanos) {
                       removeWaiter(q);
                       return state;
                   }
                   parkNanos = nanos - elapsed;
               }
               // nanoTime may be slow; recheck before parking
               if (state &lt; COMPLETING)
                   LockSupport.parkNanos(this, parkNanos);
           }
           else
               LockSupport.park(this);
       }
   }
</code></pre>
<p>具体的细节就不说了,最终就是如果状态是运行中的话就阻塞线程等待,直到那边run方法执行完成之后,修改线程状态:</p>
<pre><code class="java">public void run() {
      if (state != NEW ||
          !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))
          return;
      try {
          Callable&lt;V&gt; c = callable;
          if (c != null &amp;&amp; state == NEW) {
              V result;
              boolean ran;
              try {
                  result = c.call();
                  ran = true;
              } catch (Throwable ex) {
                  result = null;
                  ran = false;
                  setException(ex);
              }
              if (ran)
                  set(result);
          }
      } finally {
          // runner must be non-null until state is settled to
          // prevent concurrent calls to run()
          runner = null;
          // state must be re-read after nulling runner to prevent
          // leaked interrupts
          int s = state;
          if (s &gt;= INTERRUPTING)
              handlePossibleCancellationInterrupt(s);
      }
  }
</code></pre>
<p>执行完成之后进入set(result):</p>
<pre><code class="java">protected void set(V v) {
       if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) {
           outcome = v;
           U.putOrderedInt(this, STATE, NORMAL); // final state
           finishCompletion();
       }
   }
</code></pre>
<pre><code class="java">private void finishCompletion() {
      // assert state &gt; COMPLETING;
      for (WaitNode q; (q = waiters) != null;) {
          if (U.compareAndSwapObject(this, WAITERS, q, null)) {
              for (;;) {
                  Thread t = q.thread;
                  if (t != null) {
                      q.thread = null;
                      LockSupport.unpark(t);
                  }
                  WaitNode next = q.next;
                  if (next == null)
                      break;
                  q.next = null; // unlink to help gc
                  q = next;
              }
              break;
          }
      }

      done();

      callable = null;        // to reduce footprint
  }
</code></pre>
<p>在这里唤醒线程,通知get方法,已经完成处理了,可以获取返回值了.</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>ThreadPoolExecutor中的一个难点是在如何通过一个int值来代表两个作用,一个是线程池状态,一个是线程池运行任务的个数.</p>
<pre><code class="java">   private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
   private static final int COUNT_BITS = Integer.SIZE - 3;
   private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

   // runState is stored in the high-order bits
   private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
   private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
   private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
   private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
   private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

   // Packing and unpacking ctl
   private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
   private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
   private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>
<p>把一个int值的高位3为作为线程池的状态,后面的29位作为线程池的任务个数.<br>这里的 <em>COUNT_BITS</em> 是29,那么 <em>CAPACITY</em> 就是 00011111111111111111111111111111 ,这样 <em>~CAPACITY</em> 为 11100000000000000000000000000000,这样通过与操作就可以分别处理两个属性了.非常的巧妙.</p>
<p>然后要明白两个重要的属性 <em>corePoolSize</em> 和 <em>maximumPoolSize</em> . corePoolSize是用来表示当前允许运行的最小任务个数,也叫核心任务数.maximumPoolSize是指线程池运行运行的最大任务数.</p>
<p>正常情况下,如果没有满足 corePoolSize 的话就创建新的 <em>worker</em> 然后执行,如果超过了 corePoolSize 的话一般是进入阻塞队列中等待.如果连阻塞队列都满了的话,尝试在创建新的线程来执行任务,前提是运行的任务数不能超过最大的任务数,也就是 maximumPoolSize .这就是两个size的作用.4中不同的线程池类型的区别主要就在这两个参数上面.<br>举个例子,比如现在总共有12个任务, corePoolSize 为2,阻塞队列容量为5,最大线程数 maximumPoolSize为10,那首先会优先满足corePoolSize ,1号,2号运行,然后剩下的5个也就是,3,4,5,6,7进入阻塞队列,然后8,9,10号创建新线程来执行填满最大线程数,还剩下的11,12就不予执行了.</p>
<p>上面的这个流程就是线程池的核心流程原理,下面来看具体的代码实现:<br>ThreadPoolExecutor调用任务有两个方法一个是submit,一个是execute,二者的唯一区别就是submit有返回值,但是内部都是调用了execute方法.</p>
<pre><code class="java">public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
       if (task == null) throw new NullPointerException();
       RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);
       execute(ftask);
       return ftask;
   }


   public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
       if (task == null) throw new NullPointerException();
       RunnableFuture&lt;T&gt; ftask = newTaskFor(task);
       execute(ftask);
       return ftask;
   }
</code></pre>
<p>这里传入的就是FutureTask对象啦,FutureTask的细节前面已经说过了,先看 <em>execute</em> 方法的实现:</p>
<pre><code class="java">public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn&#39;t, by returning false.
         *
         * 如果要执行的任务数量小于corePoolSize,直接通过调用addWorker方法来执行任务.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 如果线程池处于运行状态并且任务成功的进入阻塞队列,二次检查线程池的状态,如果状态变为非运行的时候,尝试回退任务
         * 如果运行中的任务个数为0,运行一个空的任务到addWorker
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         * 如果不能入列,那尝试直接通过addWorker运行任务,如果失败说明线程池已经停止了或者已经满了,拒绝任务
         */
        int c = ctl.get();
        if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
</code></pre>
<p>这里就对应上面的三种情况,核心任务数没满直接addWorker,如果满了就放入阻塞队列中,如果阻塞队列也满了尝试直接运行,那如何运行任务就进入addWorker方法了.</p>
<pre><code class="java">private boolean addWorker(Runnable firstTask, boolean core) {
      /**
      * 通过一个循环标示来控制一个两层的死循环
      * 首先是判断线程池的状态,如果是停止或以上的状态直接返回false
      * 另外就是前面的 *execute* 方法的传入的 *addWorker(null, false);* 这种情况下说明阻塞队列还有任务没有执行完成,所以要继续把阻塞队列里面的任务执行完才可以,这种情况就会进入底下的第二个循环里面.
      * 第二个循环直接更改运行的线程数,如果成功就跳出循环,如果超出最大限制就返回false
      * 如果发现线程池的状态变化了就重新更新一下
      */
       retry:
       for (;;) {
           int c = ctl.get();
           int rs = runStateOf(c);

           // Check if queue empty only if necessary.
           if (rs &gt;= SHUTDOWN &amp;&amp;
               ! (rs == SHUTDOWN &amp;&amp;
                  firstTask == null &amp;&amp;
                  ! workQueue.isEmpty()))
               return false;

           for (;;) {
               int wc = workerCountOf(c);
               if (wc &gt;= CAPACITY ||
                   wc &gt;= (core ? corePoolSize : maximumPoolSize))
                   return false;
               if (compareAndIncrementWorkerCount(c))
                   break retry;
               c = ctl.get();  // Re-read ctl
               if (runStateOf(c) != rs)
                   continue retry;
               // else CAS failed due to workerCount change; retry inner loop
           }
       }
        /**
        * 如果进入这里说明任务可以执行了
        */
       boolean workerStarted = false;
       boolean workerAdded = false;
       Worker w = null;
       try {
          //包装一个worker对象
           w = new Worker(firstTask);
           //这里的Thread是通过线程池构造函数的ThreadFactory来创建出来的,这里的线程就是worker对象用来执行任务的线程对象,这个对象会陪伴着worker从生到死,不断的执行任务,如果阻塞队列中没有任务的时候,它会阻塞挂起,除非设置了keepAliveTime参数.
           final Thread t = w.thread;
           if (t != null) {
               final ReentrantLock mainLock = this.mainLock;
               mainLock.lock();
               try {
                   // Recheck while holding lock.
                   // Back out on ThreadFactory failure or if
                   // shut down before lock acquired.
                   int rs = runStateOf(ctl.get());
                    //运行态或者停止之后但是阻塞队列还有任务没有完成,设置workerAdded true
                   if (rs &lt; SHUTDOWN ||
                       (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                       if (t.isAlive()) // precheck that t is startable
                           throw new IllegalThreadStateException();
                       workers.add(w);
                       int s = workers.size();
                       //设置当前最大的运行任务数
                       if (s &gt; largestPoolSize)
                           largestPoolSize = s;
                       workerAdded = true;
                   }
               } finally {
                   mainLock.unlock();
               }
               if (workerAdded) {
                 //这里调用worker线程的start方法,最后进入了 *runWorker* 方法
                   t.start();
                   workerStarted = true;
               }
           }
       } finally {
           if (! workerStarted)
               addWorkerFailed(w);
       }
       return workerStarted;
   }
</code></pre>
<p>当调用worker的中线程的start方法实际上进入了runWorker方法中,先看下work对象的实现:</p>
<pre><code class="java">private final class Worker
      extends AbstractQueuedSynchronizer
      implements Runnable
  {
      /**
       * This class will never be serialized, but we provide a
       * serialVersionUID to suppress a javac warning.
       */
      private static final long serialVersionUID = 6138294804551838833L;

      /** Thread this worker is running in.  Null if factory fails. */
      final Thread thread;
      /** Initial task to run.  Possibly null. */
      Runnable firstTask;
      /** Per-thread task counter */
      volatile long completedTasks;

      /**
       * Creates with given first task and thread from ThreadFactory.
       * @param firstTask the first task (null if none)
       */
      Worker(Runnable firstTask) {
          setState(-1); // inhibit interrupts until runWorker
          this.firstTask = firstTask;
          this.thread = getThreadFactory().newThread(this);
      }

      /** Delegates main run loop to outer runWorker. */
      public void run() {
          runWorker(this);
      }

      // Lock methods
      //
      // The value 0 represents the unlocked state.
      // The value 1 represents the locked state.

      protected boolean isHeldExclusively() {
          return getState() != 0;
      }

      protected boolean tryAcquire(int unused) {
          if (compareAndSetState(0, 1)) {
              setExclusiveOwnerThread(Thread.currentThread());
              return true;
          }
          return false;
      }

      protected boolean tryRelease(int unused) {
          setExclusiveOwnerThread(null);
          setState(0);
          return true;
      }

      public void lock()        { acquire(1); }
      public boolean tryLock()  { return tryAcquire(1); }
      public void unlock()      { release(1); }
      public boolean isLocked() { return isHeldExclusively(); }

      void interruptIfStarted() {
          Thread t;
          if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {
              try {
                  t.interrupt();
              } catch (SecurityException ignore) {
              }
          }
      }
  }
</code></pre>
<p>worker是一个AQS的简单实现,其中要注意的就是它的构造函数,首先通过setState(-1)来把对象锁定,防止中断操作,然后就是thread对象,这里是通过ThreadFactory的newThread来创建出来的新线程,这个线程用来调用传入线程池的任务,相当于任务的载体.这个Thread对象就是worker用来执行任务的环境了,它会和worker一起丛生到死.</p>
<p>线程池是是如何减少了线程的创建的呢?<br>比如我有100个任务,那你直接调用100个任务的start方法相当于创建了100个线程对不对.而交给线程池却不会傻傻的创建100个线程对象,它会创建你设置的 <em>corePoolSize</em> 个worker对象,在worker对象的Thread中来执行任务代码,也就是说每个worker对象不仅仅只是运行一个任务就完了,它会不断的运行任务,从阻塞队列中不断的去取任务,直到没有任务给它处理为止.这个时候它会阻塞,一直等着阻塞队列有数据进来.</p>
<p>注意这里说的worker对象不止执行一个任务是理解线程池的关键.通过这样才能减少线程的创建和消耗,重点要理解worker是怎么处理任务的.下面我们来看runWorker方法的实现:</p>
<pre><code class="java">final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
          //这里getTask是从阻塞队列中取没有运行的任务,一直到阻塞队列中没有数据为止
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &amp;&amp;
                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                  //这个方法是个钩子函数
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                      //运行任务
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
</code></pre>
<p>这里就是调用任务的核心所在了,之所以有这么代码判断是为了处理线程池状态的变化的,比如正在运行任务的过程中,线程池调用了shutDown方法或者shutDownNow方法的时候,要协调这些任务的运行状态.<br>方法中while的判断,如果worker中的task为空的时候,就对应上面addWorker的时候线程池已经停止了,但是在阻塞队列中还是有任务,就得把阻塞队列中的任务取出来处理.这里就调用的是 <em>getTask</em> 方法,从阻塞队列中取任务.</p>
<pre><code class="java">private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;

            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
              //从阻塞队列中获取一个任务
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
</code></pre>
<p>这样就保证了只要worker活着它就会不断的从阻塞队列取数据并执行,这种阻塞了等待着执行任务的worker成为IdleWorker,也是在后面会被回收的worker对象.在每次执行完成任务之后来判断一下是不是需要回收闲置的worker对象.关键点就在这里的 <em>workQueue.poll</em> 和 <em>workQueue.take</em> ,poll支持超时,如果在指定的 <em>keepAliveTime</em> 的时间内,阻塞队列中还是没有数据,那么就返回null,如果是 <em>take</em> 的话,就会阻塞,等待有新的数据进入阻塞队列中.这个关键点是实现后面要讲的 <em>newCachedThreadPool</em> 关键所在.也就是在keepAliveTime的时间内,还是没有新的任务,那么这个worker对象就会被回收.<br>最后,如果是设置了keepAliveTime的话,超时没有取到数据,就会设置timedOut为true,再次进入上面的 <em>timed &amp;&amp; timedOut</em> 就会满足条件了,然后返回null,回到上面的runWoker的while循环并跳出,交给下面的 <em>processWorkerExit</em> 方法.</p>
<pre><code class="java">private void processWorkerExit(Worker w, boolean completedAbruptly) {
        if (completedAbruptly) // If abrupt, then workerCount wasn&#39;t adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }

        tryTerminate();

        int c = ctl.get();
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 &amp;&amp; ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) &gt;= min)
                    return; // replacement not needed
            }
            addWorker(null, false);
        }
    }
</code></pre>
<p>这里通过重入锁锁定之后修改workers集合的数据,把运行完成的worker移除.如果线程池还没到stop的状态,继续调用addWorker执行阻塞队列中的任务.同时还尝试结束线程池,再来看其中的 <em>tryTerminate</em> 方法:</p>
<pre><code class="java">final void tryTerminate() {
        for (;;) {
            int c = ctl.get();
            if (isRunning(c) ||
                runStateAtLeast(c, TIDYING) ||
                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))
                return;
            if (workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ONLY_ONE);
                return;
            }

            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                      //空方法,没有实现
                        terminated();
                    } finally {
                        ctl.set(ctlOf(TERMINATED, 0));
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }
</code></pre>
<p>如果现在状态是shutDown,但是阻塞队列中还是有任务就退出,不中止线程池.如果核心线程还是有在运行的时候,调用 <em>interruptIdleWorkers</em></p>
<pre><code class="java">private void interruptIdleWorkers(boolean onlyOne) {
      final ReentrantLock mainLock = this.mainLock;
      mainLock.lock();
      try {
          for (Worker w : workers) {
              Thread t = w.thread;
              if (!t.isInterrupted() &amp;&amp; w.tryLock()) {
                  try {
                      t.interrupt();
                  } catch (SecurityException ignore) {
                  } finally {
                      w.unlock();
                  }
              }
              if (onlyOne)
                  break;
          }
      } finally {
          mainLock.unlock();
      }
  }
</code></pre>
<p>如果是空闲线程,也就是没有任务在运行,所以可以获得锁,就把worker所在的线程中断.</p>
<p>到这里,就会引出两个中断方法的差异,shutDown和showDownNow的区别是:shutDown是中断之后,后续的加入的任务就无法直接运行了,已经在运行和阻塞队列中的还是会继续执行,而shutDownNow是直接中断全部的任务,不管是否在队列中,也不管是否在运行;</p>
<pre><code class="java">public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            advanceRunState(SHUTDOWN);
            interruptIdleWorkers();
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }
</code></pre>
<p>可以看到这里调用的是 <em>interruptIdleWorkers</em> 方法.</p>
<pre><code class="java">public List&lt;Runnable&gt; shutdownNow() {
       List&lt;Runnable&gt; tasks;
       final ReentrantLock mainLock = this.mainLock;
       mainLock.lock();
       try {
           checkShutdownAccess();
           advanceRunState(STOP);
           interruptWorkers();
           tasks = drainQueue();
       } finally {
           mainLock.unlock();
       }
       tryTerminate();
       return tasks;
   }
</code></pre>
<pre><code class="java">private void interruptWorkers() {
       final ReentrantLock mainLock = this.mainLock;
       mainLock.lock();
       try {
           for (Worker w : workers)
               w.interruptIfStarted();
       } finally {
           mainLock.unlock();
       }
   }
</code></pre>
<p>然后回到worker的内部interruptIfStarted:</p>
<pre><code class="java">void interruptIfStarted() {
           Thread t;
           if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {
               try {
                   t.interrupt();
               } catch (SecurityException ignore) {
               }
           }
       }
</code></pre>
<p>可以看到这里调用的 <em>interruptWorkers</em> 方法.这就是两个shutdown方法的区别所在.一个是中断空闲任务,一个是中断所有任务.</p>
<h3 id="newFixedThreadPool-newSingleThreadExecutor-newCachedThreadPool-newScheduledThreadPool-四种类型的区别"><a href="#newFixedThreadPool-newSingleThreadExecutor-newCachedThreadPool-newScheduledThreadPool-四种类型的区别" class="headerlink" title="newFixedThreadPool,newSingleThreadExecutor,newCachedThreadPool,newScheduledThreadPool 四种类型的区别"></a>newFixedThreadPool,newSingleThreadExecutor,newCachedThreadPool,newScheduledThreadPool 四种类型的区别</h3><p>这4种常用的线程池的创建都交给Executors来完成的,实际上就是创建了不同的ThreadPoolExecutor.</p>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) {
      return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;());
  }
</code></pre>
<p>可以看到核心任务数和最大任务数是一样的,那就是说线程池支持最多有 <em>nThreads</em> 个worker在运行,剩下的任务全部放入阻塞中,等待前面的任务完成后才取出来继续执行.</p>
<pre><code class="java">public static ExecutorService newSingleThreadExecutor() {
       return new FinalizableDelegatedExecutorService
           (new ThreadPoolExecutor(1, 1,
                                   0L, TimeUnit.MILLISECONDS,
                                   new LinkedBlockingQueue&lt;Runnable&gt;()));
   }
</code></pre>
<p>可以看到核心线程和最大线程数都是1,也就是说同一时间只能有一个任务执行,后续的任务挨个按顺序执行.</p>
<pre><code class="java">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue&lt;Runnable&gt;(),
                                    threadFactory);
  }
</code></pre>
<p>可以重复使用线程的线程池,直接把所有任务同时创建worker来运行,不管有多少个,同时由于设置了超时keepAliveTime,到了制定的时候就会回收空闲的worker对象,达到回收资源的目的.注意这里只是回收 <em>空闲</em> 的worker,正在运行的worker是不会回收的.</p>
<pre><code class="java">public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
    }
</code></pre>
<p>支持指定时间的任务的线程池,这里内部通过一个 <em>DelayedWorkQueue</em> 来完成定时操作,就不多做解释了.</p>
<h3 id="Callable和Runnable"><a href="#Callable和Runnable" class="headerlink" title="Callable和Runnable"></a>Callable和Runnable</h3><p>Callable是具有返回值的Runnable,这是两个区别.</p>
<pre><code class="java">public interface Callable&lt;V&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
</code></pre>
<pre><code class="java">public interface Runnable {

    /**
     * Starts executing the active part of the class&#39; code. This method is
     * called when a thread is started that has been created with a class which
     * implements {@code Runnable}.
     */
    public void run();
}
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程池的实现难点都在于 ThreadPoolExecutor 中,主要是对其中worker工作方式的理解,还有线程的运行和任务的运行的区别.这是关键,底层还是通过CAS来自旋判断线程的运行状态等属性变化,可以看到CAS是java多线程的核心基础.<br>刚开始完全不理解worker的实现,后来耐着性子看了好几遍别人的博客总于弄明白个大概,不得不说线程池的实现非常的巧妙.首先是一个int表示两个属性,然后是worker的实现思路来减少线程的创建消耗,对线程的理解更进一步.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/" title="Java线程池ThreadPoolExecutor源码分析" target="_blank" rel="external">Java线程池ThreadPoolExecutor源码分析</a></p>
<p><a href="http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor" title="Java并发包源码学习之线程池（一）ThreadPoolExecutor源码分析" target="_blank" rel="external">Java并发包源码学习之线程池（一）ThreadPoolExecutor源码分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2017/01/03/2017/android Handler,Looper,MessageQueue源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/03/2017/android Handler,Looper,MessageQueue源码分析/" itemprop="url">android Handler,Looper,MessageQueue源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-03T14:09:00+08:00">
                2017-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="android-Handler-Looper-MessageQueue源码分析"><a href="#android-Handler-Looper-MessageQueue源码分析" class="headerlink" title="android Handler,Looper,MessageQueue源码分析"></a>android Handler,Looper,MessageQueue源码分析</h2><p>  Handler是一个在android开发过程中经常用到的类,同时在面试的时候也会经常问道其中的实现原理,那今天就重点讲解一下Handler的用法和实现原理.</p>
<blockquote>
<p>一个Handler可以使你发送并处理一个消息或者线程通过关联一个 <em>MessageQueue</em> .每一个handler的实例都唯一关联一个线程和 <em>MessageQueue</em> .当你创建一个Handler它就和当前线程和线程的 <em>MessageQueue</em> 绑定在一起了.它会发送消息或者线程到对应 <em>MessageQueue</em> ,并且在从 <em>MessageQueue</em> 取出的时候执行它们.<br>Handler主要有两个作用:一个是可以在未来的某个时间点执行消息或者线程 ;另一个是在你当前拥有的另一个线程中排队执行一些任务.<br>发送消息一般可以使用 post(Runnable),postAtTime(Runnable,long),postDelay(Runnable,long),sendEmptyMessage(int),sendMessage(Message),sendMessageAtTime(Message,long) 和 sendMessageDelay(Message,long).这几个方法.post开头的方法可以在消息队列入队的时候调用.而sendMessage开头的方法允许把一个带有bundle对象的消息对象入队,并在未来交给 <em>handleMessage(Message)</em> 去处理.</p>
</blockquote>
<p>  上面这个是我照着官方文档翻译的,水平有限,说白了就是Handler可以把消息对象或者线程放入消息队列中,等到出列的时候调用.<br>  比如当子线程中发送网络请求之后回调可以通过给主线程的handler发送一个message,这样可以把网络请求的回调结果返回到主线程中处理.</p>
<p>  下面开始分析Handler的源码:</p>
<h3 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h3><p>  我们先从Handler的使用入口来看,也就是那一堆post和sendMessage开头的方法入手,可以看到所有的传递事件的方法最终都是调用了 <em>sendMessageAtTime</em> :</p>
<pre><code class="java">  public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }
</code></pre>
<p>  post方法开头的只是多做了一部处理,把Runnable对象作为message的回调使用了,然后也是调用了 <em>sendMessageAtTime</em> :</p>
<pre><code class="java">
    private static Message getPostMessage(Runnable r) {
        Message m = Message.obtain();
        m.callback = r;
        return m;
    }
</code></pre>
<p>  可以看到在 <em>sendMessageAtTime</em> 的方法刚开始的时候显示判断消息队列 <em>MessageQueue</em> 是否为空,如果为空的直接返回false不予执行.那这个消息队列是从哪里来的的呢?这个时候回到Handler的构造方法:</p>
<pre><code class="java">  public Handler() {
       this(null, false);
   }
   public Handler(Callback callback) {
       this(callback, false);
   }
   public Handler(Looper looper) {
       this(looper, null, false);
   }
   public Handler(Looper looper, Callback callback) {
      this(looper, callback, false);
  }
  /**
  *.......
  *@hide
  */
  public Handler(boolean async) {
        this(null, async);
  }
  public Handler(Callback callback, boolean async) {
       if (FIND_POTENTIAL_LEAKS) {
           final Class&lt;? extends Handler&gt; klass = getClass();
           if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                   (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
               Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                   klass.getCanonicalName());
           }
       }

       mLooper = Looper.myLooper();
       if (mLooper == null) {
           throw new RuntimeException(
               &quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&quot;);
       }
       mQueue = mLooper.mQueue;
       mCallback = callback;
       mAsynchronous = async;
  }
</code></pre>
<p>  这里有个细节就是6个构造函数的其中一个是不对外开放的,就是那个加了 <em>@hide</em> 注解的构造函数.也就是这个构造函数只能在手机自己内部调用,和android的internal包戏下面的代码一样,都是不对外开发的.</p>
<p>  可以看到在构造方法顶部有一个tip提示,就是说如果这里handler不是静态的话可能导致内存泄漏,这种情况是很常见的,内部类持有外部类的引用,也就是当前handler持有外部的activity对象,当activity销毁的时候,如果handler中还是有任务没有完成的,activity是无法被内存回收的.这就会导致内存泄漏,解决方法就是把handler设置为static并且把activity的关联设置为弱引用(WeakReference).</p>
<p>  继续往下看,开始调用 Looper.myLooper() 如果Looper对象为空的话抛出异常,看来handler必须能够获取到looper对象,否者没法往下执行.到了后面我们就知道,looper的作用是用来不停的从消息队列中取出消息来交给Handler来执行的.所以没有looper的话handler获取不到消息就没有了意义.<br>  在往下就会发现handler里面的 MessageQueue用的就是looper里面的mQueue.后面我们在分析looper的实现.现在消息队列有了,我们回到上面的 <em>sendMessageAtTime</em> 方法中.可以看到该方法最终调用了 <em>enqueueMessage</em> 方法.</p>
<pre><code class="java">  private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
       msg.target = this;
       if (mAsynchronous) {
           msg.setAsynchronous(true);
       }
       return queue.enqueueMessage(msg, uptimeMillis);
   }
</code></pre>
<p>  非常简单,调用消息队列自己的 <em>enqueueMessage</em> 方法,这里如果handler设置为异步(mAsynchronous)的话,那发送的消息类型也是异步的.至于异步有啥作用,我们后面会提到.<br>  可以看到Handler的代码非常的见到,就是把消息放入消息队列中就完成任务了.那怎么从消息队列中取出消息来回调了,这个功能就交给下面要讲的looper实现了.</p>
<h3 id="Looper的实现"><a href="#Looper的实现" class="headerlink" title="Looper的实现"></a>Looper的实现</h3><p>  上面看Handler得源码发现,其内部的消息队列指向的是Looper的内部的消息队列,那可以断定这个消息队列是由looper来维护的,同时由于每个线程都有一个唯一的线程队列,这个是怎么实现呢,可以马上想到之前我们学习过的 <em>ThreadLocal</em> 每个线程都拥有自己唯一的变量对象.这里就是 <em>ThreadLocal</em> 的典型实现场景了.</p>
<p>  可以看到Looper的构造函数是私有的,外面只能通过调用 <em>myLooper</em> 方法来获取到当前线程中的Looper对象.</p>
<pre><code class="java">  public static @Nullable Looper myLooper() {
      return sThreadLocal.get();
  }
</code></pre>
<pre><code class="java">   static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
</code></pre>
<p>  刚才说了Handler在发送之前必须得能通过 <em>myLooper</em> 方法获取到looper对象.但是这里的sThreadLocal并没有实现 <em>initialValue</em> 方法,所以必须得外部调用一个方法来给ThreadLocal赋值,这里使用的是 <em>prepare</em> 方法.</p>
<pre><code class="java">  public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
</code></pre>
<p>  通过 <em>prepare</em> 方法,就可以是当前线程中的looper对象不为空了,同时handler就可以来发送消息了.so,可以看到在创建Handler之前的必备步骤必须先得调用一下Looper.prepare()方法,这样才能正常运行.<br>  这个时候有人可能会说,为啥在activity的使用过程中,我们并没有显式的调用 <em>Looper.prepare()</em> 方法呢,其实是activity在创建的时候已经在底层帮我们调用过了,这样朱祥成中的looper对象就不为空,我们就可以随便创建新的Handler而不用担心looper为空了.</p>
<p>  looper为主线程的looper提供了直接调用方法:</p>
<pre><code class="java">  public static void prepareMainLooper() {
       prepare(false);
       synchronized (Looper.class) {
           if (sMainLooper != null) {
               throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
           }
           sMainLooper = myLooper();
       }
   }
</code></pre>
<p>  这个方法就是用来给UI主线程来生成唯一的looper的.我们平时经常通 <em>Looper.myLooper() == Looper.getMainLooper()</em> 来判断当前是不是在UI主线程中就是这个道理.<br>  looper的初始化完成后,怎么才能让消息队列的消息出列呢.这里是通过调用 <em>loop</em> 方法来完成的</p>
<pre><code class="java">  public static void loop() {
       final Looper me = myLooper();
       if (me == null) {
           throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);
       }
       final MessageQueue queue = me.mQueue;

       // Make sure the identity of this thread is that of the local process,
       // and keep track of what that identity token actually is.
       Binder.clearCallingIdentity();
       final long ident = Binder.clearCallingIdentity();

       for (;;) {
           Message msg = queue.next(); // might block
           if (msg == null) {
               // No message indicates that the message queue is quitting.
               return;
           }

           // This must be in a local variable, in case a UI event sets the logger
           Printer logging = me.mLogging;
           if (logging != null) {
               logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                       msg.callback + &quot;: &quot; + msg.what);
           }

           msg.target.dispatchMessage(msg);

           if (logging != null) {
               logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
           }

           // Make sure that during the course of dispatching the
           // identity of the thread wasn&#39;t corrupted.
           final long newIdent = Binder.clearCallingIdentity();
           if (ident != newIdent) {
               Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                       + Long.toHexString(ident) + &quot; to 0x&quot;
                       + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                       + msg.target.getClass().getName() + &quot; &quot;
                       + msg.callback + &quot; what=&quot; + msg.what);
           }

           msg.recycleUnchecked();
       }
   }
</code></pre>
<p>  这里去掉无用信息之后,实际上就是调用了消息队列的 <em>next</em> 方法,如果取到新的消息对象,就交给消息对象的target也就是handler来处理.同时也看到在注释写到消息队列的next方法可能会阻塞.回到了handler的 <em>dispatchMessage</em> 方法中了</p>
<pre><code class="java">  /**
   * Handle system messages here.
   */
  public void dispatchMessage(Message msg) {
      if (msg.callback != null) {
          handleCallback(msg);
      } else {
          if (mCallback != null) {
              if (mCallback.handleMessage(msg)) {
                  return;
              }
          }
          handleMessage(msg);
      }
  }
  private static void handleCallback(Message message) {
         message.callback.run();
     }
  /**
  * Subclasses must implement this to receive messages.
  */
   public void handleMessage(Message msg) {
   }
</code></pre>
<p>  这里可以看到,如果是post的时候,调用callBack,如果是sendMessage的话直接调用handleMessage,这个方法是个空方法,是交给我们自己根据需求去实现的.</p>
<p>  这里其实一直有一个疑问,就是明明在线程中调用Handler的post方法,传入一个线程对象,为啥就说这玩意是在主线程中运行的呢?明明代码都在线程里面的,要运行也应该是在子线程中运行,为啥大家都说是在主线程中运行?<br>  今天才明白了,一直忽略了一个细节,就是上面的 <em>handleCallback</em> 的内部实现,细细看它里面内部调用的居然是callback的 <em>run</em> 方法,而不是咱们一直使用的 <em>start</em> 方法,二者唯一的区别就是start是新开一个线程来执行run方法中的代码,而run方法是直接在当前线程中执行run方法中的代码,这是二者的不同之处,so,这里其实是在主线程中直接执行了run方法中的代码,那个子线程根本就没有运行,相当于一个普通的对象.</p>
<p>  到这里looper的功能就讲完了,可以看到looper就是不断的从消息队列中取消息的作用.<br>  下面我们进入消息队列的具体实现,来重点看一下两个方法 <em>enqueueMessage</em> , <em>next</em>:</p>
<h3 id="MessageQueue的实现"><a href="#MessageQueue的实现" class="headerlink" title="MessageQueue的实现"></a>MessageQueue的实现</h3><p>  先来看 <em>enqueueMessage</em> 的实现:</p>
<pre><code class="java">
    boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
        }

        synchronized (this) {
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // Inserted within the middle of the queue.  Usually we don&#39;t have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
</code></pre>
<p>  可以很明显的看出消息队列实际上是一个单向链表的实现.这里的全局变量 <em>mMessages</em> 代表着初始的头结点,如果刚开始列表为空的话就把当前的入队的message作为头结点,如果不为空的话就遍历整个列表直到找到触发时间(when)小于当前的message的消息,把message插入他的后面.</p>
<p>  这里的needWake变量是用来处理如果是异步任务的时候来h唤醒队列用的,平时我们用不到,这里不深入讲了</p>
<p>  下面再来看下 <em>next</em> 方法是如何阻塞线程的:</p>
<pre><code class="java">  Message next() {
        // Return here if the message loop has already quit and been disposed.
        // This can happen if the application tries to restart a looper after quit
        // which is not supported.
        final long ptr = mPtr;
        if (ptr == 0) {
            return null;
        }

        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        for (;;) {
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }

            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                if (msg != null &amp;&amp; msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null &amp;&amp; !msg.isAsynchronous());
                }
                if (msg != null) {
                    if (now &lt; msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // Got a message.
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }

                // Process the quit message now that all pending messages have been handled.
                if (mQuitting) {
                    dispose();
                    return null;
                }

                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
                if (pendingIdleHandlerCount &lt; 0
                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount &lt;= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    mBlocked = true;
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
                }

                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }

            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;

            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            nextPollTimeoutMillis = 0;
        }
    }
</code></pre>
<p>  可以看到这里已经来就弄出一个死循环来,就是这么的霸气,通过这个循环来不断从链表中获取头结点的message对象,for循环开始有一个 <em>nativePollOnce</em></p>
<pre><code class="java">    nativePollOnce(ptr, nextPollTimeoutMillis);
</code></pre>
<p>  这个方法是一个native方法,作用就是在指定的时间内唤醒ptr,也就是消息队列的内存地址.</p>
<p>  那这个参数 <em>nextPollTimeoutMillis</em> 就很是关键点了.如果头结点不为空的话,判断一下当前事件是不是小于message的when,如果小于说明还没有到消息出列的时候,把 <em>nextPollTimeoutMillis</em> 调整为二者的差值,等待下次的唤醒.如果时间正好,就把头结点返回,链表前移.<br>  有点像你定了6点闹钟上班,5点半醒了发现没到点就继续睡半小时的,等到了6点闹钟响了你就起床上班了.差不多就是这个意思.</p>
<p>  核心逻辑走完之后地下出现了一个 <em>IdleHandler</em> 数组,并调用了 <em>queueIdle</em> 这个东西的作用就是用来在消息队列空闲的时候执行一些额外的工作.比如GC说明的,你可以根据需要调用消息队列的 <em>addIdleHandler</em></p>
<pre><code class="java">  public void addIdleHandler(@NonNull IdleHandler handler) {
       if (handler == null) {
           throw new NullPointerException(&quot;Can&#39;t add a null IdleHandler&quot;);
       }
       synchronized (this) {
           mIdleHandlers.add(handler);
       }
   }

   public void removeIdleHandler(@NonNull IdleHandler handler) {
          synchronized (this) {
              mIdleHandlers.remove(handler);
          }
  }
</code></pre>
<p>  最后的最后我们可以看到在 <em>next</em> 方法中判断如果message的target为空的时候的处理.那什么情况下message的target为空的,是在消息队列中的 <em>postSyncBarrier</em></p>
<pre><code class="java">  public int postSyncBarrier() {
        return postSyncBarrier(SystemClock.uptimeMillis());
    }

    private int postSyncBarrier(long when) {
        // Enqueue a new sync barrier token.
        // We don&#39;t need to wake the queue because the purpose of a barrier is to stall it.
        synchronized (this) {
            final int token = mNextBarrierToken++;
            final Message msg = Message.obtain();
            msg.markInUse();
            msg.when = when;
            msg.arg1 = token;

            Message prev = null;
            Message p = mMessages;
            if (when != 0) {
                while (p != null &amp;&amp; p.when &lt;= when) {
                    prev = p;
                    p = p.next;
                }
            }
            if (prev != null) { // invariant: p == prev.next
                msg.next = p;
                prev.next = msg;
            } else {
                msg.next = p;
                mMessages = msg;
            }
            return token;
        }
    }
</code></pre>
<p>  这个barrier的作用翻译过来叫栅栏,也就是用来阻隔消息继续发送的.如果你调用了 <em>postSyncBarrier</em> 那这个时间点之后的同步消息都不会执行了,除非了你把它移除掉,调用 <em>removeSyncBarrier</em> .这里不包括异步消息,异步消息还是可以继续执行的.我们平时调用的都是同步消息,异步消息应该是系统内部使用的.</p>
<pre><code class="java">  public void removeSyncBarrier(int token) {
       // Remove a sync barrier token from the queue.
       // If the queue is no longer stalled by a barrier then wake it.
       synchronized (this) {
           Message prev = null;
           Message p = mMessages;
           while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) {
               prev = p;
               p = p.next;
           }
           if (p == null) {
               throw new IllegalStateException(&quot;The specified message queue synchronization &quot;
                       + &quot; barrier token has not been posted or has already been removed.&quot;);
           }
           final boolean needWake;
           if (prev != null) {
               prev.next = p.next;
               needWake = false;
           } else {
               mMessages = p.next;
               needWake = mMessages == null || mMessages.target != null;
           }
           p.recycleUnchecked();

           // If the loop is quitting then it is already awake.
           // We can assume mPtr != 0 when mQuitting is false.
           if (needWake &amp;&amp; !mQuitting) {
               nativeWake(mPtr);
           }
       }
   }
</code></pre>
<p>  消息队列的大概流程就讲完了,最后我们来看下Message对象的内部实现:</p>
<h3 id="Message源码"><a href="#Message源码" class="headerlink" title="Message源码"></a>Message源码</h3><p>  可以看到在Message中提供了一系列的obtain方法来用来初始赋值,这里有个简单对象池的实现,值得我们注意下:</p>
<p>  在上面的looper的loop方法中,当取出message之后并交给message的target执行完成后,后面有一句 <em>msg.recycleUnchecked();</em> 用来回收message对象</p>
<pre><code class="java">  void recycleUnchecked() {
      // Mark the message as in use while it remains in the recycled object pool.
      // Clear out all other details.
      flags = FLAG_IN_USE;
      what = 0;
      arg1 = 0;
      arg2 = 0;
      obj = null;
      replyTo = null;
      sendingUid = -1;
      when = 0;
      target = null;
      callback = null;
      data = null;

      synchronized (sPoolSync) {
          if (sPoolSize &lt; MAX_POOL_SIZE) {
              next = sPool;
              sPool = this;
              sPoolSize++;
          }
      }
  }
</code></pre>
<p>  可以看到这里把用完的对象清空属性之后赋给了sPool,达到了回收的目的.</p>
<pre><code class="java">  public static Message obtain() {
       synchronized (sPoolSync) {
           if (sPool != null) {
               Message m = sPool;
               sPool = m.next;
               m.next = null;
               m.flags = 0; // clear in-use flag
               sPoolSize--;
               return m;
           }
       }
       return new Message();
   }
</code></pre>
<p>  可以看到在obtain的时候优先从sPool中获取是否有么有使用的Message对象,如果有的话就直接使用了,没有的时候才创建新的Message对象.所以为了节约内存,最好还是使用obtain方法.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看了下Handler,Looper,MessageQueue的源码感觉难点是在 MessageQueue的内部 <em>next</em> 方法中,里面有一些底层native的东西,自己不是很了解,耽搁了点时间来消化.至于Handler和Looper上层实现还是比较简单的.那么,handler的讲解就到这里.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://hjdzone.gitbooks.io/thinkandroid/content/ThreadMessage/Chapter_1_6.html" title="MessageQueue源码分析" target="_blank" rel="external">MessageQueue源码分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JustinYan</p>
              <p class="site-description motion-element" itemprop="description">JustinYan的个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">Kategorien</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JustinYan</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
