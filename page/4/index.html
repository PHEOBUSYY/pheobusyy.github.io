<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="欢迎来到JustinYan的个人blog" type="application/atom+xml" />






<meta name="description" content="JustinYan的个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="欢迎来到JustinYan的个人blog">
<meta property="og:url" content="http://pheobusyy.github.io/page/4/index.html">
<meta property="og:site_name" content="欢迎来到JustinYan的个人blog">
<meta property="og:description" content="JustinYan的个人blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欢迎来到JustinYan的个人blog">
<meta name="twitter:description" content="JustinYan的个人blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pheobusyy.github.io/page/4/"/>





  <title>欢迎来到JustinYan的个人blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">欢迎来到JustinYan的个人blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">永远不要因为你觉得某个目标无法实现就否决它-《原则》</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/12/31/2016/计划与总结/2017年度计划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/31/2016/计划与总结/2017年度计划/" itemprop="url">2017年度计划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-31T15:30:00+08:00">
                2016-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>#2017年度计划</p>
<p>  今天是2016的最后一天,刚刚写完了201年度总结,对这一整年的所作所为做一个整体的总结,感觉还是很有收获的.下面开始填写2017年度的计划,还是分成工作,生活等这几个方面来说吧,最后再统一写一个list来量化要完成的内容.<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/12/31/2016/计划与总结/2017年度计划/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/12/31/2016/计划与总结/2016年度总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/31/2016/计划与总结/2016年度总结/" itemprop="url">2016年度总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-31T10:08:00+08:00">
                2016-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2016年度总结"><a href="#2016年度总结" class="headerlink" title="2016年度总结"></a>2016年度总结</h2><p>  今天是16年的最后一天了,决定对今年一整年做一个总结,看看这一年都有哪些收获和感悟,得到了什么,还没有得到什么,需要后续继续努力得到什么.</p>
<h3 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h3><p>  先说环境,从天下互联离开之后辗转金和,最后再到现在的用有,相当于一个职业的重新归零吧,想想在天下互联这5年自己的收获,不能说没有但是效果不尽如人意,技术上的进步基本上是靠自己的零敲碎打的学来的,流程的规范和大公司也没法相提并论,包括各种软硬件配置也是相差的很远,最大的成就可能就是通过邱哥丈母娘然后认识了我亲爱的老婆吧,现在的用有感觉软硬件都还可以,有班车食堂,有各种娱乐设施,最最满意的可以打篮球锻炼身体,同时单位距离家里的路程还是可以接受的,每天开车上下班,40多分钟就可以到公司和回家,想想之前每天光是在公交车上花费的事件就要1个半小时,这还是不包括走路还要走好远的事件,每天有4个小时都浪费在路途上,想想自己居然坚持了两年多真心不容易;</p>
<p>  其次再说领导,潘哥作为一个领导的话严格来说是不称职的,同时思维的局限性也制约了他的眼界和想法.导致我们这些小弟没有学到怎么做管理如何才能发动手下的兄弟一个奋斗有个清晰的目标管理.这些统统没有.来到用友之后马哥作为自己的新领导感觉对手下人都非常的和善,只要工作上按时完成要求其他一概可以ok,没有像以前对潘哥那么的心里压力,老是感觉很纠结,特别容易郁闷.</p>
<p>  最后是心情,以前在天下的时候每天感觉很压抑,看不到希望,那个东西翻来覆去做了那么多年,到现在还是那个样子,不能说自己的问题吧但是更多的是战略和用人的问题.之前老是觉得不合理需求坑爹的肯定是产品或者潘哥提的,后来潘哥走了之后直面老板发现,好吧确实错怪潘哥了,老板的思维可能停留在自己以前的辉煌时刻吧,现在真心已经out了,无法跟上现在节奏,抓不到现在用户的痛点同时也没有个明确的定位,大而空的东西很难成功.用人上潘哥为了”省钱”根本就不会把牛人给找进来,威胁自己的地位,这不能不说是一个从上到下的悲剧,后来幡然悔悟可是已经错过了.看着每次老板忽悠着各种假大空,渐渐感觉得很恶心,决定换工作,当时在找工作的时候感觉自己的水平真的很差,有很多东西是在面试过程中逼着自己学的,后来慢慢的面试的准备过过程中发现java基础,设计模式这些东西的好处了,面试的时候也不在慌张,对自己有了点点信心.这里有个小插曲就是差一点点就进入宜信了,当时面试3轮都非常的成功,可能最后就是错在找了猎头的问题上.这叫有缘无分吧,在金和的那一个月也不是很开心,做的东西和环境很糟糕,身边的人的想法和做法比较官僚主义,也是无法忍受,最后来到了用有,整体我都非常满意,除了可能待遇上比外面差一点点,其他可以总结为事少钱多离家近.现状就是身边的人有点不太负责任,混日子的比较多,自己还是在坚持做点东西的,想把东西做好,同时积极主动的帮着解决一些问题.总之,这一年的工作还是比较满意的,希望能在用有多呆段日子吧.调养下身心.</p>
<h3 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h3><p>  2016年技术来说是有巨大进步的一年,回想之前的工作的种种遇到的问题,可能很多的症结就是在java基础和编程思想上,也从根本上明白了java基础的重要性,从更高层面上对编程有个整体的认识,这点我觉得是巨大的收获.这可能就是之前大家都在说的”道”与”术”的区别,也就是”战略”和”战术”的区别,只要明白了很多抽象的东西,那所有的编程语言都是一样的,唯一不一样的可能是实现的思想和具体的语法,这个是通过学习IOS的过程中发现的;最终编程的目的就是实现各种各样帮助别人的工具或者提供信息的资源.而为什么我们平时要写很多很多的代码,其实是为了”缓存”的具体实现,有了”缓存”就可以把各种东西分层,然后替换,一种整体模块化的思想.我觉得这点是最重要的.</p>
<p>  首先的收获就是算勉强学会了点点IOS,完成IOS的一个基础的学习,虽然距离实战还是有点距离的,但是起码对IOS整体有个初步的了解,确实比android简单,并且很多地方比安卓要求规范些,可能制约IOS入门最大的问题就剩Xcode了,嘿嘿</p>
<p>  还有就是写博客,各种博客,不仅仅是技术博客,还包括其他方面的博客,好记性不如烂笔头,通过文字来把生活中遇到的各种问题和解决方法写出来,是一次重新整理和消化的过程,同时也加深了记忆.现在的博客是一个刚刚的开始,期待明年可以有所突破吧,提高自己的文学编写能力和表达能力.</p>
<p>  另一个感悟就是最近阅读源码体会到的,如何才能快速的提高编程能力,我觉得主要有两个方面:一个是通过阅读别人的开源代码来看下别人是怎么实现一个东西的,同时里面有很多的api或者技巧可能自己根本就不知道或者不清楚怎么用,通过看比人的代码来达到一个学习的过程;另一个就是编程想要提高就要明确目的性,也就是你到底要做出个说明东西出来,要以目的来导向,实际所有的学习都应该是带着问题和目的去学习的,这样的效率是最高的.这个后面的收获感悟会重新说明一下.明白了这两点对提高编程思想至关重要,这样在后续的学习和工作工程中可以少走很多弯路.</p>
<p>  还有一个感悟就是在对待开源项目的使用方式,之前看到别人的都是原封不动的把对方代码拿来直接用了,把自己的代码和对方的代码都掺杂在一起了,后面如果要替换掉这个库发现代价非常的大,”拿来主义”是要讲究形式的,最好在调用的时候再加一层中间层来解耦,这样在后续代码调整的过程中,只要直接替换中间层代码就可以,上层的代码是不需要改变的.这点非常非常的重要.在调整架构的时候要时刻保持关注.</p>
<p>  最后一个感悟就是自动化对工作效率上的提升,不过这一点目前做的还不是很到位,比如一些重复性的工作应该写脚本自动化运行,比如通过VI的学习来加快编程的速度.还有通过写一个命令来完成常用操作,等等,这些重复性的工作最好是都交给自动化来处理,不能傻傻的”硬”写.</p>
<h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><p>  生活方面我准备分几个方面来讲,一个生活习惯方面,一个是生活态度方面.</p>
<h4 id="生活习惯方面"><a href="#生活习惯方面" class="headerlink" title="生活习惯方面"></a>生活习惯方面</h4><p>  2016年在习惯方面有个巨大的进步就是写日记,感谢day one这个神奇的app,事件的起因就是通过app限免安装了day one这个神奇的软件,软件做的非常棒,可能是因为挺贵的,所以就坚持了几天写日记,没想到居然坚持下来了,不得不说真是一个奇迹,要知道长这么大,今天的写日记可能是我坚持的最久的一个习惯了.看了day one上的记录,从今年的2月18号开始,一直到今天,坚持了277天,歇了278条记录,拍了575张照片,真的,这是从小到大我坚持最久的一个习惯活动.再次谢谢day one这个app,后续等有钱了就买一个mac上的付费版本.</p>
<p>  另外一个坚持的算比较久的就是哑铃了,从9月份开始的,中间断断续续的一直坚持到最近,每天晚上在快10点的时候来个几十下,慢慢的发现胳膊居然越来越力量了,看看小习惯大作用啊,不过最近挺了几天了,前段时间打球伤到腰了,导致练哑铃的时候腰部不适很舒服,看看今天晚上能不能重新开始,争取把右手力量也练出来.</p>
<p>  还有一个没坚持下来但是非常应该坚持的习惯就是跑步,在5月份的时候坚持了一段时间,后来中间不知道为啥就停了,11月的时候早上去跑过几次,不过后来由于雾霾和天气的问题就停了,冬天果然不是一个适合跑步的季节.看开春的时候能不能重新开始,明年争取像13年的时候通过跑步来完成身体和精神上的重塑.</p>
<p>  还有就是明白读书笔记的重要性,以前读书都是看一遍就完了,以后可能过段时间就不记得了,白看,后来明白了读书一定做读书笔记,把书里重要的或者写的很精辟的地方记下来,整理归档,这样才算真正的”读书”.也谢谢&lt;如何有效阅读一本书：超实用笔记读书法&gt;,虽然写的比较简单,但是对阅读的技巧提出的建议是非常实用的.</p>
<p>  最后就是在游戏方面,之前玩dota玩的比较多了,后来发现越来越费神,同时玩完之后有很大的内疚和空虚感,所以就把dota给删除了,同时游戏也玩的很少很少了.明白了游戏的局限性,在减压方面还是运动和休息来的效果明显.玩游戏会越玩越累.</p>
<h4 id="生活态度方面"><a href="#生活态度方面" class="headerlink" title="生活态度方面"></a>生活态度方面</h4><p>  在生活态度方面主要是有被两件事给影响到了:<br>  一个是去年做胆结石手术,感觉特别不值得,身体被工作给拖垮了,身心都受到了很大的影响,以前老是觉得自己很重要,没有自己啥都搞不定,单位没了我不行,后来发现自己真的没那么重要,同时自己在老板眼里也没有那么重要,为了工作把身体搞垮是真的不值当的.</p>
<p>  另外一个就是高中的好友”鸭子”在青岛由于工作压力过大去世了,一个活生生的例子出现在自己的身边,以前觉得过劳死这种事情离自己很远,光是在网上听说了没有很重视,现在就活生生的发生的自己的身边,”鸭子”刚在青岛买房结婚,家里就他一个孩子,还要还房贷,可能这些种种原因吧,把自己给拖垮了,人没了,说明东西都没有了意义.so,身体和陪伴家人最重要,好好珍惜和家人在一起的每一天,世道艰辛,我们唯一能做的就是乐观的活着,好好享受每一天.</p>
<p>  总结下来,就是好好享受生活,想吃啥吃点啥,想买啥买点啥,好好珍惜和家人在一起的日子,每天都要学会感恩,同时每天都要开开心心的.这样才是生活的真正态度.活在当下!</p>
<h3 id="感情方面"><a href="#感情方面" class="headerlink" title="感情方面"></a>感情方面</h3><p>  在感情方面,今年做的还算不错,和老婆的相处越来越融洽,吵架的次数越来越少,随之而来就是俩人越来越胖,在减肥的道路上越走越远了.这一年明白了和家人相处的重要性,所以对老婆也格外的关心和爱护,可以说大事小事全都她说了算,我也乐得费脑子去思考,虽然老是被她说自己彪,嘿嘿,不过我自己不觉得,我只是不够”灵活”而已啦.</p>
<p>  做的不太好的方面可能是给奶奶和家里打电话的次数不算多,没有好好关注一下他们的动态,奶奶换了房子也是后来才知道的,父母身体也是后知后觉,感觉亏欠他们很多,明年一定好好的报答他们这么多年的养育之恩.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  好的方面就是明白了身体的重要性,同时也知道思考的重要性,还有写作的重要性,这些都是可以提升自己的全面素质的东西.差的的方面可能就是在计划的制定和执行上,还是在计划的制定上比较杂乱,同时执行力上还是不够强,导致效率不是很高,希望这点在来年可以好好的改善.同时,通过不断的”自省”,我发现今天一年突然很有收获,时间也过得慢了很多,往年都是不知不觉就过完了,没啥感觉也没啥收获,今年算是一个左右成效的一年吧.我把它称为”开智元年”.期待2017年我可以收获更大的进步,同时在”开智”方面取得长足的进步.下面就是2017年的年度计划了哦.</p>
<p>  最后,祝愿我和我的家人在新的一年里身体健康,事事顺心.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/12/20/2016/Java多线程知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/20/2016/Java多线程知识/" itemprop="url">Java多线程知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-20T15:45:00+08:00">
                2016-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>java的并行与并发</li>
<li>java线程安全的概念</li>
<li>java中CAS的概念</li>
<li>java中AtomicInteger相关类的实现原理</li>
<li>java乐观锁与悲观锁</li>
<li>java加锁 syncnized和reentrantlock</li>
<li>ReentrantLock的使用方法和原理</li>
<li>如何让多个线程顺序执行,迅雷面试题ABC三个线程顺序输出的问题</li>
<li>java的join方法</li>
<li>ReadWriteLock使用和实现原理</li>
<li>脏读,可重复读,幻读的概念</li>
<li>死锁相关概念</li>
<li>java信号量</li>
<li>java 多线程包下的常用类使用</li>
<li>生产者消费者</li>
</ol>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>  并发性(concurrency) : 有称共行性,是指有能力处理多个同时性活动的能力,并发事件之间不一定要同一事件发生.<br>  并行(parallelism) : 是指同时发生的两个并发事件,具有并发的含义,而并发不一定并行.</p>
<p>  可见两者最大的区别是能否在同一时间进行.并行是并发的子集.</p>
<p><img src="/images/2016/12/并发与并行.jpg" alt="并发与并行图例"></p>
<h3 id="java线程安全的概念"><a href="#java线程安全的概念" class="headerlink" title="java线程安全的概念"></a>java线程安全的概念</h3><p>  java线程安全是相对多线程概念来提出的,线程安全是指一个方法或者类实例可以在不同的线程中同时使用而不会引起任何的问题.<br>  考虑一下下面的情况</p>
<pre><code class="java">  private int myInt = 0;
  public int addOne(){
    int temp = myInt;
    temp = temp + 1;
    myInt = tmp;
    return temp;
  }
</code></pre>
<p>  现在有A和B两个线程将要同时执行addOne()方法,但是A先开始并且把myInt的值0赋给了temp,同时由于某些原因线程调度决定挂起A线程,同时执行B线程,B线程也是把myInt的值O赋值给了它自己的temp,并且方法完全执行结束,这个时候最终myInt=1 ,并且返回了1.现在又轮到了线程A,在A中的temp的值为0,执行加加一操作后,变为1,同时返回的值也为1.<br>  在上面的情况下,方法addOne执行了两边,但是由于该方法是非线程安全的导致没有返回预期的结果2,由于第二个线程先于第一个线程保存myInt的值,所以都是返回了1.</p>
<p>  创建线程安全的方法不算太繁琐,并且有一些技巧.在java中你可以声明一个方法为 <em>synchronized</em> ,这个关键字的含义是在同一时间只能有同一个线程来执行当前方法.其他线程需要等待.这会保证方法是线程安全的,但是假如在这个方法中有一堆事情要做的话会浪费很长的事件.另一种方式是 <em>对需要保证线程同步的方法中的部分</em> 来加锁或者信号量.只是锁住其中的一小部分(称为 <em>临界区</em> ).甚至在java中也提供了很多方法来保证非锁的线程安全,这些方法保证多线程可以在同一时间内竞争,并且导致该方法完成一套原子性的操作.原子性是指不能被中断并且在同一时间内只能在一个线程中执行. 后面我们会讲到的 <em>CAS</em> 就是这种方式的内部实现原理 .</p>
<h3 id="java中的CAS概念"><a href="#java中的CAS概念" class="headerlink" title="java中的CAS概念"></a>java中的CAS概念</h3><p>  CAS全称Compare And Swap ,即比较并交换,设计并发算法中常用到的一种技术,java.util.concurrent包完全建立在CAS的基础上.<br>  当前的处理器基本都支持CAS,只不过每家的实现不一样.<br>  <em>CAS有三个操作数,内存值V,旧的预期值A,要修改的值B,当且仅当预期的值A和内存值V相同时,将内存值修改为B并返回True,否者什么都不做返回False</em><br>  下面来看上面demo的CAS实现:<br>  首先myInt必须是 <em>valatile</em> 的了,这样才能保证多个线程之间的数据变化是可见的.(valatile的用法后面会提到)</p>
<pre><code class="java">  private int valatile myInt = 0;
  public final int get(){
    return myInt;
  }
  public final int addOneAndGet(){
    for (; ; ) {
      int current = get();
      int next = current + 1;
      if(compareAndSet(current,next)){
        return next;
      }
    }
  }
</code></pre>
<p>  这里通过方法 <em>compareAndSet</em> 来完成CAS的底层实现.也就是比较current和内存中的值,如果两个一样就放回true,退出死循环返回next,否者不断的从内存中获取和当前的current比较,知道匹配成功.这里通过一个死循环来达到不断更新current值得目的.<br>  再来回头想想上面的非线程安全情景,如果B处理完成后myInt变成1,这个时候A发现自己的myInt与内存中的不一致,就重新获取一下myInt的值,直到两者一致,然后完成加一操作,就达到了一种不用加锁也可以线程之间同步资源的目的.</p>
<pre><code class="java">  public final boolean compareAndSet(int expect, int update) {   
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
</code></pre>
<p>  这里unsafe是底层native的jni实现,借由C来调用CPU底层指令来实现的.</p>
<p>  上面的CAS实现其实也是java的同步包中 AtomicInteger的内部实现原理.</p>
<p>  可以看到CAS还是比较容易理解的,就是字面意思,对比然后赋值交换.下面说说CAS的缺点;</p>
<ol>
<li>ABA问题.因为CAS需要在操作的时候检查值有没有发生变化,如果没变化就更新,如果一个值原来是A,后来改成B,又变回到A,这个时候CAS检查发现值没有变化,实际上已经变化过了.这个就是ABA问题,通过在变量前面加上版本号的思路可以解决ABA问题,在变量前面加上版本号,每次变量更新的时候把版本号加1,那么A-B-A就会变成1A-2B-3A,这时就可以比较出第一个A和最后一个A是不一样的了.在java的current包中提供了AtomicStampedRefrence来解决ABA问题.</li>
<li>循环时间长开销大.自旋CAS如果长时间不成功,会给CPU带来很大的开销.如果JVM支持pause指令那么效率会有一定的提升.</li>
<li>只能保证一个共享变量的原子操作.很明显,上面的demo只是对一个变量做了原子加一操作.可以通过AtomicRefrence类来保证引用对象之间的原子性.</li>
</ol>
<h3 id="java中AtomicInteger的实现原理"><a href="#java中AtomicInteger的实现原理" class="headerlink" title="java中AtomicInteger的实现原理"></a>java中AtomicInteger的实现原理</h3><p>  AtomicInteger是一个完成的CAS实现,通过上面的CAS说明,可以发现最重要的就是比较内存值和当前值是否相等的逻辑.首先看如何获取内存值</p>
<pre><code class="java">  static {
      try {
          valueOffset = unsafe.objectFieldOffset
              (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
      } catch (Exception ex) { throw new Error(ex); }
  }
</code></pre>
<p>  这个是通过底层native直接获取 <em>value</em> 在内存中的偏移量.注意这个是静态的,只是在初次使用的时候就获取完成.<br>  由于 <em>value</em> 是 <em>valitale</em> 的,所以value的变化在各个线程中是可见.这样就可以比较当前value和内存中value是否相等了.<br>  其他的细节在上面已经提到了,这里就不在重复了.</p>
<h3 id="java的乐观锁和悲观锁"><a href="#java的乐观锁和悲观锁" class="headerlink" title="java的乐观锁和悲观锁"></a>java的乐观锁和悲观锁</h3><p>  我们都知道,CPU是时分复用的,也就是把cpu的时间片,分配给不同的thread/process轮流执行,时间片与时间片之间,需要cpu切换,也就是会发生线程切换.切换涉及到清空寄存器,缓存数据.然后重新加载新的thread所需数据.当一个线程被挂起的时候,加入阻塞队列,在一定的事件或者条件下,在通过notifiy(),notifiyAll()唤醒回来.</p>
<p>  悲观锁<br>  是指对数据被外界修改持保守态度,因此,在整个数据处理过程中,讲数据处于锁定状态.<br>  在某个资源不可用的时候,就将CPU让出,把当前等待线程切换为阻塞状态.等到资源(比如一个共享数据)可用了,那么就将线程唤醒,让他进入runaable状态等待CPU调度.这就是典型的悲观锁的实现.独占锁是一种悲观锁,Syncnized就是一种独占锁,它假设最坏的情况,并且只有在确保其他线程不会赵成干扰的情况下执行,会导致其它所有需要锁的线程挂起,等待持有锁的线程释放所;</p>
<p>  但是由于在进程挂起和恢复执行过程中存在着很大的开销.当一个线程正在等待锁时,它不能做任何事,所以悲观锁有很大的缺点.举个例子,如果一个线程需要某个资源,但是这个资源占用的时间很短,当线程第一次抢占这个资源时,可能这个资源被占用,如果此时挂起这个线程,可能立刻就发现资源可用,然后又需要花费很长的时间重新抢占锁,时间代价就会非常的高.</p>
<p>  所以就有了乐观锁的概念.它的核心概念就是,每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,知道成功为止.在上面的例子中,某个线程可以不让出cpu,而是一直while循环,如果失败就重试,知道成功为止.所以,当数据争用不严重时,乐观锁效果更好.比如上面说的CAS就是一种乐观锁思想的应用.</p>
<h3 id="java加锁-synchronized和reentrantlock"><a href="#java加锁-synchronized和reentrantlock" class="headerlink" title="java加锁 synchronized和reentrantlock"></a>java加锁 synchronized和reentrantlock</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>  可以通过给方法或代码块增加 <em>synchronized</em> 关键字来加互斥锁.如果是加在当前的对象中的实例方法中那锁对象就是当前的对象也就是 <em>this</em> ,如果是加在静态方法中的,那当前锁对象就是 <em>class</em> 对象.如果是代码块中的话就是括号里面传入的对象.<br>  下面通过一个demo来说明 <em>synchronized</em> 的用法</p>
<pre><code class="java">  public class Sync {
      public synchronized void test() {
              System.out.println(&quot;test 开始&quot;);
              try {
                  Thread.sleep(1000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println(&quot;test 结束&quot;);
      }
  }
</code></pre>
<p>  sync是一个普通的java类,内部的实例方法test增加了 <em>synchronized</em> 关键字来加锁,保证同一时间内只能有一个线程来调用test.<br>  然后是调用的线程MyThread</p>
<pre><code class="java">  public class MyThread extends Thread {
    private Sync sync;

    public MyThread() {
    }

    public MyThread(Sync sync) {
        this.sync = sync;
    }

    @Override
    public void run() {
        if (this.sync == null) {
            sync = new Sync();
        }
        sync.test();
    }
  }
</code></pre>
<p>  最后是测试类</p>
<pre><code class="java">  public class TestSynchronized {
    public static void main(String[] args) {
       test();
    }
    public static void test() {
        for (int i = 0; i &lt; 3; i++) {
            new MyThread().start();
        }
    }
    public static void test1() {
        Sync sync = new Sync();
        for (int i = 0; i &lt; 3; i++) {
            new MyThread(sync).start();
        }
    }
  }
</code></pre>
<p>  首先来看第一个test方法,通过创建3个MyThread来同时执行,那加的锁会成功吗?,看输出:</p>
<blockquote>
<p>test 开始<br>test 开始<br>test 开始<br>test 结束<br>test 结束<br>test 结束</p>
</blockquote>
<p>  很明显,锁没有起作用,3个线程同时执行的.</p>
<p>  在看调用第二个test方法,外部Sync对象创建后之后传入3个线程中,看输出:</p>
<blockquote>
<p>test 开始<br>test 结束<br>test 开始<br>test 结束<br>test 开始<br>test 结束</p>
</blockquote>
<p>  看来这种情况下是成功了.</p>
<p>  和上面的说明一致,方法锁锁定的是当前的实例对象,第一种情况下3个不同的实例对象,所以不行<br>  而第二个test是用的同一个实例对象,所以加锁成功.<br>  如果把Sync的test方法内部创建一个 Sync类锁的话,那两个test方法都会加锁成功</p>
<pre><code class="java">  public class Sync {
    public void test() {
        synchronized (Sync.class) {
            System.out.println(&quot;test 开始&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;test 结束&quot;);
        }
    }
  }
</code></pre>
<h4 id="reentrantLock详解"><a href="#reentrantLock详解" class="headerlink" title="reentrantLock详解"></a>reentrantLock详解</h4><p>首先 <em>reentrantLock</em> 是一种乐观锁,它比 <em>synchronized</em> 更加灵活,内部增加了很多机制,比如支持请求所超时,公平锁等功能.<br><em>reentrantLock</em> 的翻译是 “可重入的的锁”,可以对同一个线程申请多次锁,内部有一个计数器,每次调用 <em>lock</em> 方法的时候加一, <em>unlock</em> 的时候减一,知道计数器为0,最终释放锁.<br>普通的用法如下:</p>
<pre><code class="java">class X {
  private final ReentrantLock lock = new ReentrantLock();
  //...

  public void m(){
    lock.lock(); // block until condition holds
    try {
      //... method body
    }final{
      lock.unlock();
    }
  }
}
</code></pre>
<p>关于 <em>ReentrantLock</em> 的高级用法我们后面再讲,现在先看其内部实现,尝试讲解一下源码:<br><em>ReeentrantLock</em> 内部主要是通过一个Sync的抽象类来完成大部分的操作,这个Sync对象继承至 <em>AbstractQueuedSynchronizer</em> ,其中 <em>AbstractQueuedSynchronizer</em> 中实现了大部分的锁机制,只是抽象出了 <em>tryAcquire</em> 和 <em>tryReleas</em> 方法,交由子类实现.<br>而在 <em>ReeentrantLock</em> 中的 Sync对象有有两个实现类,分别是 <em>NonfairSync</em> 和 <em>FairSync</em> ,从命名上可以看出分别是不公平锁和公平锁的概念.<br>为啥会有公平不公共这种说法呢,还得从多线程的角度考虑:由于有锁的出现,导致同一时间只能有个线程可以执行,那其他的线程处在阻塞状态,如果锁释放了,那那些阻塞的线程将被唤醒,说明肯定是有个队列用来维护阻塞线程的.公平锁和非公平锁的区别就在于唤醒的时候是否需要按照队列的顺序来唤醒.公平锁的话是按照阻塞队列的顺序来获取锁,非公平锁的唤醒是先直接尝试取得锁,如果失败才会进入阻塞队列中按顺序获取锁.</p>
<p><em>ReentrantLock</em> 默认构造方法实现的是非公平锁.也就是 <em>NonfairSync</em> .</p>
<p>首先是从 <em>lock</em> 方法开始</p>
<pre><code class="java">public void lock() {
       sync.lock();
   }
</code></pre>
<p>lock方法调用的Sync对象的lock方法,这里默认初始化的是 <em>NonfairSync</em>,进入其内部来看:</p>
<pre><code class="java">static final class NonfairSync extends Sync {
      private static final long serialVersionUID = 7316153563782823691L;

      /**
       * Performs lock.  Try immediate barge, backing up to normal
       * acquire on failure.
       */
      final void lock() {
          if (compareAndSetState(0, 1))
              setExclusiveOwnerThread(Thread.currentThread());
          else
              acquire(1);
      }

      protected final boolean tryAcquire(int acquires) {
          return nonfairTryAcquire(acquires);
      }
  }
</code></pre>
<p>这里lock的时候直接通过CAS来获得锁,如果成功就把当前线程设为独占线程,失败的话进入 <em>acquire</em> 方法.这个方法是在 <em>AbstractQueuedSynchronizer</em> 实现的通用方法.</p>
<pre><code class="java">public final void acquire(int arg) {
       if (!tryAcquire(arg) &amp;&amp;
           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
           selfInterrupt();
   }
</code></pre>
<p>先看见if判断的第一个条件 <em>tryAcquire</em> ,就是上边的 <em>NonfairSync</em> 中的实现,最终进入了 <em>nonfairTryAcquire</em> 方法中.</p>
<pre><code class="java">final boolean nonfairTryAcquire(int acquires) {
           final Thread current = Thread.currentThread();
           int c = getState();
           if (c == 0) {
               if (compareAndSetState(0, acquires)) {
                   setExclusiveOwnerThread(current);
                   return true;
               }
           }
           else if (current == getExclusiveOwnerThread()) {
               int nextc = c + acquires;
               if (nextc &lt; 0) // overflow
                   throw new Error(&quot;Maximum lock count exceeded&quot;);
               setState(nextc);
               return true;
           }
           return false;
       }
</code></pre>
<p>这里的state就是前面说的计数器,通过state来说明当前锁的状态.</p>
<pre><code class="java">/**
    * The synchronization state.
    */
   private volatile int state;
</code></pre>
<p>这里如果state为0,说明还没有线程获得了锁,那正好,我是第一个,立马通过CAS来把自己设为当前独占线程,同时state变为传入的 <em>acquires</em> ,第一次的时候为1,后续每次调用都会加一.<br>如果当前state不为0,但是独占线程是自己的话,把state加一,可重入体现在这里了.这里很明显最大可重入的值是最大的int值.<br>最后,如果都不符合返回false,进入上面 <em>acquire</em> 方法if判断的第二个条件 <em>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</em>.先看其中的 <em>addWaiter</em> 方法:</p>
<pre><code class="java">/**
     * Creates and enqueues node for current thread and given mode.
     *
     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
     * @return the new node
     */
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
</code></pre>
<p>如果锁已经被抢占了,后续线程将进入这里维护的 <em>双向队列</em> 中, <em>addWaiter</em> 方法就是把节点对象放入队列中的实现.<br>如果队列不为空的话,直接通过CAS把结尾节点更新为当前请求的节点对象,否者会进入一个队列初始化方法 <em>enq</em> 方法中.</p>
<pre><code class="java">/**
    * Inserts node into queue, initializing if necessary. See picture above.
    * @param node the node to insert
    * @return node&#39;s predecessor
    */
   private Node enq(final Node node) {
       for (;;) {
           Node t = tail;
           if (t == null) { // Must initialize
               if (compareAndSetHead(new Node()))
                   tail = head;
           } else {
               node.prev = t;
               if (compareAndSetTail(t, node)) {
                   t.next = node;
                   return t;
               }
           }
       }
   }
</code></pre>
<p>如果尾部指针为空,说明队列没有初始化,把head和tail节点更新为一个创建的新的node对象<br>如果队列不为空,更新尾部节点,把当前请求的节点设为尾部节点.</p>
<p>回到 <em>acquireQueued(final Node node, int arg)</em> 方法中.</p>
<pre><code class="java">final boolean acquireQueued(final Node node, int arg) {
       boolean failed = true;
       try {
           boolean interrupted = false;
           for (;;) {
               final Node p = node.predecessor();
               if (p == head &amp;&amp; tryAcquire(arg)) {
                   setHead(node);
                   p.next = null; // help GC
                   failed = false;
                   return interrupted;
               }
               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                   parkAndCheckInterrupt())
                   interrupted = true;
           }
       } finally {
           if (failed)
               cancelAcquire(node);
       }
   }
</code></pre>
<p>首先是判断当前节点是不是头结点的后一个,同时再次申请锁,如果两个条件都满足就更新队列,把头结点置为当前的请求节点,然后返回false<br>如果不满足if条件就进入第二个判断,先看其第一个条件 <em>shouldParkAfterFailedAcquire(p, node)</em> :</p>
<pre><code class="java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;
        if (ws &gt; 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don&#39;t park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
</code></pre>
<p>默认node对象的waitStatus是0,进入最后面的else分支,返回false,由于外面的调用方法 <em>acquireQueued</em> 里面是个死循环,所以马上又会回到这里,然后更新waitStatus的值为 Node.SIGNAL, 返回true.<br>在看第二个判断条件 <em>parkAndCheckInterrupt()</em> :</p>
<pre><code class="java">/**
   * Convenience method to park and then check if interrupted
   *
   * @return {@code true} if interrupted
   */
  private final boolean parkAndCheckInterrupt() {
      LockSupport.park(this);
      return Thread.interrupted();
  }
</code></pre>
<p>这里,就进入了阻塞线程的核心代码了,通过 <em>LockSupport.park(this);</em> 来阻塞当前的线程.至于 <em>LockSupport</em> 的用法,以后有时间再解释,只要明白这个就是阻塞现场的实现就ok了.<br>非公平锁的lock实现就到这里,再来简单看下公平锁的lock的实现,其实只是 <em>tryAcquire</em> 方法的实现不一样.</p>
<pre><code class="java">/**
        * Fair version of tryAcquire.  Don&#39;t grant access unless
        * recursive call or no waiters or is first.
        */
       protected final boolean tryAcquire(int acquires) {
           final Thread current = Thread.currentThread();
           int c = getState();
           if (c == 0) {
               if (!hasQueuedPredecessors() &amp;&amp;
                   compareAndSetState(0, acquires)) {
                   setExclusiveOwnerThread(current);
                   return true;
               }
           }
           else if (current == getExclusiveOwnerThread()) {
               int nextc = c + acquires;
               if (nextc &lt; 0)
                   throw new Error(&quot;Maximum lock count exceeded&quot;);
               setState(nextc);
               return true;
           }
           return false;
       }
</code></pre>
<p>这里公平锁首先还是根据state来获取锁,只不过增加了一个条件 <em>hasQueuedPredecessors()</em>  ,也就是说判断队列前面还有没有正在等待的节点了</p>
<pre><code class="java">public final boolean hasQueuedPredecessors() {
       // The correctness of this depends on head being initialized
       // before tail and on head.next being accurate if the current
       // thread is first in queue.
       Node t = tail; // Read fields in reverse initialization order
       Node h = head;
       Node s;
       return h != t &amp;&amp;
           ((s = h.next) == null || s.thread != Thread.currentThread());
   }
</code></pre>
<p>这里就是上面提到的公平锁和非公平锁的请求实现方式的区别所在了.</p>
<p>lock流程就到了这里结束了,其实不算复杂.下面是unlock方法的实现:<br>unlock在公平锁和非公平锁中的实现是一样的</p>
<pre><code class="java">/**
    * Releases in exclusive mode.  Implemented by unblocking one or
    * more threads if {@link #tryRelease} returns true.
    * This method can be used to implement method {@link Lock#unlock}.
    *
    * @param arg the release argument.  This value is conveyed to
    *        {@link #tryRelease} but is otherwise uninterpreted and
    *        can represent anything you like.
    * @return the value returned from {@link #tryRelease}
    */
   public final boolean release(int arg) {
       if (tryRelease(arg)) {
           Node h = head;
           if (h != null &amp;&amp; h.waitStatus != 0)
               unparkSuccessor(h);
           return true;
       }
       return false;
   }
</code></pre>
<p>先来看 <em>tryRelease</em> 方法:</p>
<pre><code class="java">protected final boolean tryRelease(int releases) {
          int c = getState() - releases;
          if (Thread.currentThread() != getExclusiveOwnerThread())
              throw new IllegalMonitorStateException();
          boolean free = false;
          if (c == 0) {
              free = true;
              setExclusiveOwnerThread(null);
          }
          setState(c);
          return free;
      }
</code></pre>
<p>只有当前是独占线程,并且计数器state为0的时候,释放锁,把独占线程对象置为空,同时state清零.free返回true<br>上面进入if判断后,调用 <em>unparkSuccessor</em> 方法.</p>
<pre><code class="java">
    /**
     * Wakes up node&#39;s successor, if one exists.
     *
     * @param node the node
     */
    private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        if (ws &lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
</code></pre>
<p>这里设置当前节点的waitStatus为0,同时获取node的下一个节点,并且唤醒该节点的线程.那么问题来了,唤醒后面节点的线程之后,如何保证队列的顺序呢,同时把已经执行完的的node移除呢.还记得上面 <em>acquireQueued</em> 的方法吗,内部有个死循环</p>
<pre><code class="java">final boolean acquireQueued(final Node node, int arg) {
       boolean failed = true;
       try {
           boolean interrupted = false;
           for (;;) {
               final Node p = node.predecessor();
               if (p == head &amp;&amp; tryAcquire(arg)) {
                   setHead(node);
                   p.next = null; // help GC
                   failed = false;
                   return interrupted;
               }
               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                   parkAndCheckInterrupt())
                   interrupted = true;
           }
       } finally {
           if (failed)
               cancelAcquire(node);
       }
   }
</code></pre>
<p>这里p节点确实是head,进入里面第一个if判断,这个时候会把头结点更新,然后旧的头结点由于没有关联了会在后面被gc回收掉,这样就达到了动态维护阻塞队列的目的.</p>
<h4 id="ReentrantLock的用法"><a href="#ReentrantLock的用法" class="headerlink" title="ReentrantLock的用法"></a>ReentrantLock的用法</h4><p>除了普通的加锁方式之外, ReentrantLock还提供了 tryLock(),tryLock(int mill,TimeUtil util),lockInterruptibly()方法等,下面分别解释一下:<br><em>tryLock()</em> 判断能否获取获取到锁,如果当前锁是空置状态,直接返回true,否者返回false<br><em>tryLock(int mill,TimeUtil unit)</em> 类似上面的tryLock,只不过加入了时间控制,也就说说在指定的时间内能否获得到锁.<br><em>lockInterruptibly</em> 支持中断的获取锁,如果在获取锁的过程中线程被中断,会直接返回已给中断异常.它与普通lock方法的区别在于,如果是 <em>lock</em> 方法,会忽略中断请求,继续获取锁直到的成功,而 <em>lockInterruptibly</em> 方法会直接响应中断操作,返回一个中断异常交由上层处理.如果要求中断操作线程不能参与锁的竞争可以使用 <em>lockInterruptibly</em> ,否则使用 <em>lock</em> 方法.</p>
<p>除了上面说的这几个方法,平时常用的还有Condition方式,也就是更加灵活的唤醒阻塞方式,对应Object的wait,notify,notifiyAll等方法.<br>Condition 提供了 await,signal,signalAll等三个方法.可以用来灵活调整唤醒的次序,下面通过一个面试题来说明Condition的用法.</p>
<blockquote>
<p>如何让两个线程交替答应A和B十次,输出结果为ABABABABABABABABABAB</p>
</blockquote>
<p>思路:我们可以让保持一个index,每次答应之后加一,如果是偶数,唤醒A线程先答应A字符,然后在A中唤醒B线程,如果是奇数唤醒B线程答应A,然后在B中唤醒A线程.</p>
<pre><code class="java">public class TestReentrantLockCondition3 {
    static Lock lock = new ReentrantLock();
    static Condition condition = lock.newCondition();

    int index;

    public void printFirst() {
        lock.lock();
        try {
            while (index % 2 != 0) {
                condition.await();
            }
            System.out.print(&quot;A&quot;);
            index++;
            condition.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printLast() {
        lock.lock();
        try {
            while (index % 2 != 1) {
                condition.await();
            }
            System.out.print(&quot;B&quot;);
            index++;
            condition.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    static class MyThread extends Thread {
        private TestReentrantLockCondition3 condition3;

        public MyThread(TestReentrantLockCondition3 condition3) {
            this.condition3 = condition3;
        }

        @Override
        public void run() {
            condition3.printFirst();
        }
    }

    static class MyThread2 extends Thread {
        private TestReentrantLockCondition3 condition3;

        public MyThread2(TestReentrantLockCondition3 condition3) {
            this.condition3 = condition3;
        }

        @Override
        public void run() {
            condition3.printLast();
        }
    }

    public static void main(String[] args) {
        TestReentrantLockCondition3 condition3 = new TestReentrantLockCondition3();
        for (int i = 0; i &lt; 10; i++) {
            new MyThread(condition3).start();
            new MyThread2(condition3).start();
        }
    }
  }
</code></pre>
<p>核心就在上面的 <em>printFirst</em> 和 <em>printLast</em> 两个方法,在index为偶数的情况下A唤醒B阻塞,反之,然后通过不断的更新index来达到交替打印的逻辑.</p>
<h4 id="java-线程join方法"><a href="#java-线程join方法" class="headerlink" title="java 线程join方法"></a>java 线程join方法</h4><p>join方法的含义是等待对应的时长直到调用的线程执行完成.<br>也就是说,在调用的线程没有完成的时候,当前线程处于阻塞状态,不会继续往下执行,直到调用的join方法的线程完成或者超时.</p>
<p>来看源码:</p>
<pre><code>public final void join() throws InterruptedException {
       join(0);
   }
</code></pre><pre><code class="java">public final synchronized void join(long millis)
   throws InterruptedException {
       long base = System.currentTimeMillis();
       long now = 0;

       if (millis &lt; 0) {
           throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
       }

       if (millis == 0) {
           while (isAlive()) {
               wait(0);
           }
       } else {
           while (isAlive()) {
               long delay = millis - now;
               if (delay &lt;= 0) {
                   break;
               }
               wait(delay);
               now = System.currentTimeMillis() - base;
           }
       }
   }
</code></pre>
<p>如果当前线程不是Alive的话,join方法无效,如果是alive的话等待.<br>下面通过一个demo来说明用法:</p>
<pre><code class="java">public class TestJoin {
    static class TestThread extends Thread{
        @Override
        public void run() {
            System.out.println(&quot;I am TestThread !!!!&quot;);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;TestThread done&quot;);
        }
    }
    static class TestThread2 extends Thread{
        @Override
        public void run() {
            System.out.println(&quot;I am TestThread2 !!!!&quot;);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;TestThread2 done&quot;);
        }
    }

    public static void main(String[] args) {
        Thread thread1 = new TestThread();
        Thread thread2 = new TestThread2();
        thread1.start();
        try {
            thread1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread2.start();


    }
}
</code></pre>
<p>输出:</p>
<pre><code class="java">I am TestThread !!!!
TestThread done
I am TestThread2 !!!!
TestThread2 done
</code></pre>
<h4 id="ReentrantReadWriteLock用法和原理"><a href="#ReentrantReadWriteLock用法和原理" class="headerlink" title="ReentrantReadWriteLock用法和原理"></a>ReentrantReadWriteLock用法和原理</h4><p>首先 <em>ReentrantReadWriteLock</em> 和 <em>ReentrantLock</em> 的唯一关联就是都是 <em>AbstractQueuedSynchronizer</em> 的实现,其他就没有任何联系了,不要认为二者是继承关系.<br><em>ReentrantReadWriteLock</em> 主要是内部分别包含该一个读锁和写锁,主要是用的大量读少量写的时候保证性能时使用,毕竟如果直接 <em>ReentrantLock</em> 的话就是读写都加锁,性能上会有写影响.在 <em>ReentrantReadWriteLock</em> 中写锁基本类似于 <em>ReentrantLock</em> 是一种独占锁,也就是说同一时间只能有一个线程来写.而 <em>ReentrantReadWriteLock</em> 中的读锁是一种共享锁,可以有多个线程来同时读取数据.<br>读写锁的目的说白了就是为了保证数据一致性,在大量读取少量修改的时候,为了节约性能,就通过加读写锁的方式来解决独占锁的长时间的占用问题.从而达到数据一致的目的.</p>
<p>读与写的机制:<br>“读-读” 不互斥<br>“读-写” 互斥<br>“写-写” 互斥</p>
<p>即在任何时候必须保证:<br>只有一个线程在写入<br>线程正在读取的时候,写入操作等待<br>线程正在写入的时候,其他线程的写入操作和读取操作都要等待;</p>
<p>锁降级:写线程可以在写入锁后可以获取读取锁,然后释放写入锁,这样就从写入锁变成了读取锁,从而实现了锁降级的特性</p>
<p>下面是读写锁的一个使用场景实现:</p>
<pre><code class="java">private final ReadWriteLock lock = new ReentrantReadWriteLock();//读写锁  
// 读取缓存：  
    public Object read(String key) {  
        lock.readLock().lock();  
        Object obj = null;  
        try {  
            obj = cache.get(key);  
            if (obj == null) {  
                lock.readLock().unlock();  
                // 在这里的时候，其他的线程有可能获取到锁  
                lock.writeLock().lock();  
                try {  
                    if (obj == null) {  
                        obj = &quot;查找数据库&quot;; // 实际动作是查找数据库  
                        // 把数据更新到缓存中：  
                        cache.put(key, obj);  
                    }  
                } finally {  
                    // 当前线程在获取到写锁的过程中，可以获取到读锁，这叫锁的重入，然后导致了写锁的降级，称为降级锁。  
                    // 利用重入可以将写锁降级，但只能在当前线程保持的所有写入锁都已经释放后，才允许重入 reader使用  
                    // 它们。所以在重入的过程中，其他的线程不会有获取到锁的机会（这样做的好处）。试想，先释放写锁，在  
                    // 上读锁，这样做有什么弊端？--如果这样做，那么在释放写锁后，在得到读锁前，有可能被其他线程打断。  
                    // 重入————&gt;降级锁的步骤：先获取写入锁，然后获取读取锁，最后释放写入锁（重点）  
                    lock.readLock().lock();   
                    lock.writeLock().unlock();  
                }  
            }  
        } finally {  
            lock.readLock().unlock();  
        }  
        return obj;  
    }
</code></pre>
<p>读写锁的写锁和上面的降到的ReentrantLock的实现类似这里就不展开了,重点讲下读锁也就是共享锁的实现,共享锁其实严格来说不能算作锁,其内部只是维护了一个计算器.</p>
<pre><code class="java">public void lock() {
           sync.acquireShared(1);
       }
</code></pre>
<p>这里的 <em>acquireShared</em> 属于AQS中的实现:</p>
<pre><code class="java">public final void acquireShared(int arg) {
       if (tryAcquireShared(arg) &lt; 0)
           doAcquireShared(arg);
   }
</code></pre>
<pre><code class="java">protected final int tryAcquireShared(int unused) {
          /*
           * Walkthrough:
           * 1. If write lock held by another thread, fail.
           * 2. Otherwise, this thread is eligible for
           *    lock wrt state, so ask if it should block
           *    because of queue policy. If not, try
           *    to grant by CASing state and updating count.
           *    Note that step does not check for reentrant
           *    acquires, which is postponed to full version
           *    to avoid having to check hold count in
           *    the more typical non-reentrant case.
           * 3. If step 2 fails either because thread
           *    apparently not eligible or CAS fails or count
           *    saturated, chain to version with full retry loop.
           */
          Thread current = Thread.currentThread();
          int c = getState();
          if (exclusiveCount(c) != 0 &amp;&amp;
              getExclusiveOwnerThread() != current)
              return -1;
          int r = sharedCount(c);
          if (!readerShouldBlock() &amp;&amp;
              r &lt; MAX_COUNT &amp;&amp;
              compareAndSetState(c, c + SHARED_UNIT)) {
              if (r == 0) {
                  firstReader = current;
                  firstReaderHoldCount = 1;
              } else if (firstReader == current) {
                  firstReaderHoldCount++;
              } else {
                  HoldCounter rh = cachedHoldCounter;
                  if (rh == null || rh.tid != getThreadId(current))
                      cachedHoldCounter = rh = readHolds.get();
                  else if (rh.count == 0)
                      readHolds.set(rh);
                  rh.count++;
              }
              return 1;
          }
          return fullTryAcquireShared(current);
      }
</code></pre>
<p>可以看到首先是判断当前有没有写锁占用着并且占用的线程不是当前线程,直接返回失败<br><em>readerShouldBlock</em> 是一个抽象方法,在公平锁和非公平锁中实现方式不一样<br>这是公平锁的</p>
<pre><code class="java">final boolean readerShouldBlock() {
           return hasQueuedPredecessors();
}
public final boolean hasQueuedPredecessors() {
       // The correctness of this depends on head being initialized
       // before tail and on head.next being accurate if the current
       // thread is first in queue.
       Node t = tail; // Read fields in reverse initialization order
       Node h = head;
       Node s;
       return h != t &amp;&amp;
           ((s = h.next) == null || s.thread != Thread.currentThread());
   }
</code></pre>
<p>这是非公平锁的</p>
<pre><code class="java">final boolean readerShouldBlock() {
           /* As a heuristic to avoid indefinite writer starvation,
            * block if the thread that momentarily appears to be head
            * of queue, if one exists, is a waiting writer.  This is
            * only a probabilistic effect since a new reader will not
            * block if there is a waiting writer behind other enabled
            * readers that have not yet drained from the queue.
            */
return apparentlyFirstQueuedIsExclusive();
}
final boolean apparentlyFirstQueuedIsExclusive() {
     Node h, s;
     return (h = head) != null &amp;&amp;
         (s = h.next)  != null &amp;&amp;
         !s.isShared()         &amp;&amp;
         s.thread != null;
 }
</code></pre>
<p> ,第二个条件是r得小于最大的读锁限制,最大的读锁的限制是65535.因为读写锁是把state的高16位存放读锁数量,后16位存放写锁数量.然后通过CAS来更新计数器.<br>HoldCounter是这样一个对象,内部包含该了线程ID和线程中的读锁计数,然后通过ThreadLocal <em>readHolds</em> 来对应不同的线程.</p>
<pre><code class="java">static final class HoldCounter {
          int count = 0;
          // Use id, not reference, to avoid garbage retention
          final long tid = getThreadId(Thread.currentThread());
      }
</code></pre>
<pre><code class="java">static final class ThreadLocalHoldCounter
         extends ThreadLocal&lt;HoldCounter&gt; {
         public HoldCounter initialValue() {
             return new HoldCounter();
         }
     }
       private transient ThreadLocalHoldCounter readHolds;
</code></pre>
<p>如果上面的判断条件成功放回1,否者进入下面的 <em>fullTryAcquireShared</em> ;</p>
<pre><code class="java">final int fullTryAcquireShared(Thread current) {
          /*
           * This code is in part redundant with that in
           * tryAcquireShared but is simpler overall by not
           * complicating tryAcquireShared with interactions between
           * retries and lazily reading hold counts.
           */
          HoldCounter rh = null;
          for (;;) {
              int c = getState();
              if (exclusiveCount(c) != 0) {
                  if (getExclusiveOwnerThread() != current)
                      return -1;
                  // else we hold the exclusive lock; blocking here
                  // would cause deadlock.
              } else if (readerShouldBlock()) {
                  // Make sure we&#39;re not acquiring read lock reentrantly
                  if (firstReader == current) {
                      // assert firstReaderHoldCount &gt; 0;
                  } else {
                      if (rh == null) {
                          rh = cachedHoldCounter;
                          if (rh == null || rh.tid != getThreadId(current)) {
                              rh = readHolds.get();
                              if (rh.count == 0)
                                  readHolds.remove();
                          }
                      }
                      if (rh.count == 0)
                          return -1;
                  }
              }
              if (sharedCount(c) == MAX_COUNT)
                  throw new Error(&quot;Maximum lock count exceeded&quot;);
              if (compareAndSetState(c, c + SHARED_UNIT)) {
                  if (sharedCount(c) == 0) {
                      firstReader = current;
                      firstReaderHoldCount = 1;
                  } else if (firstReader == current) {
                      firstReaderHoldCount++;
                  } else {
                      if (rh == null)
                          rh = cachedHoldCounter;
                      if (rh == null || rh.tid != getThreadId(current))
                          rh = readHolds.get();
                      else if (rh.count == 0)
                          readHolds.set(rh);
                      rh.count++;
                      cachedHoldCounter = rh; // cache for release
                  }
                  return 1;
              }
          }
      }
</code></pre>
<p>这里通过自旋的方式来不断的获取读锁的状态,并通过CAS来更新.<br>最后是释放锁:</p>
<pre><code class="java">protected final boolean tryReleaseShared(int unused) {
           Thread current = Thread.currentThread();
           if (firstReader == current) {
               // assert firstReaderHoldCount &gt; 0;
               if (firstReaderHoldCount == 1)
                   firstReader = null;
               else
                   firstReaderHoldCount--;
           } else {
               HoldCounter rh = cachedHoldCounter;
               if (rh == null || rh.tid != getThreadId(current))
                   rh = readHolds.get();
               int count = rh.count;
               if (count &lt;= 1) {
                   readHolds.remove();
                   if (count &lt;= 0)
                       throw unmatchedUnlockException();
               }
               --rh.count;
           }
           for (;;) {
               int c = getState();
               int nextc = c - SHARED_UNIT;
               if (compareAndSetState(c, nextc))
                   // Releasing the read lock has no effect on readers,
                   // but it may allow waiting writers to proceed if
                   // both read and write locks are now free.
                   return nextc == 0;
           }
       }
</code></pre>
<h4 id="脏读-幻读-不可重复读"><a href="#脏读-幻读-不可重复读" class="headerlink" title="脏读,幻读,不可重复读"></a>脏读,幻读,不可重复读</h4><p>脏读:是指当一个事物正在访问数据,对数据进行了修改,而这种事物还没有提交到数据库,这时另一个事物访问了该数据,然后使用了就得数据<br>不可重复读:是指在一个事物,多次访问同一事物,两次结果不一致.比如在一个事物中先读取了一条数据,这时另一个数据对这条数据进行了修改并提交,这时前面的事物如果再次读取同一数据,发现两次的事物不一致,这就是不可重复读<br>幻读:是指事物对数据进行两次查询,第二次的查询结果包含第一次查询中没有的数据后者少了第一次查询中出现的数据.这是因为在两次查询过程中另外一个事物进行了插入操作</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁问题是多线程特有的问题,在死锁时,线程间相互等待资源,而又不释放自身资源,导致无穷尽的等待,其结果时系统任务永远无法执行完成.<br>一般来说,要出现死锁必须满足下面几个条件:</p>
<ol>
<li>互斥条件:一个资源一次只能被一个线程使用</li>
<li>请求与保持条件:一个线程因请求资源而阻塞时,对已获得资源保持不妨</li>
<li>不剥夺条件:线程已获得的资源,在未使用完之前,不强行剥夺</li>
<li>循环等待条件:若干线程之间形成了一种头尾相连的等待循环关系</li>
</ol>
<p>如果要打破死锁,只要打破4个必要条件中一个或多个就可以了.<br>如何避免死锁:</p>
<ol>
<li>让程序每次至多获取一个锁.当然,在多线程环境下,这种情况通常不现实</li>
<li>设计时考虑清楚锁的顺序,尽量减少嵌套的加锁数量</li>
<li>既然死锁的是两个线程无线等待对方持有的所,那只要设置一个等待时间上限就可以了,可以使用Lock类中tryLock方法来尝试获得所,在超时之后返回获取失败</li>
</ol>
<h4 id="java信号量Semaphore"><a href="#java信号量Semaphore" class="headerlink" title="java信号量Semaphore"></a>java信号量Semaphore</h4><p>java信号量有点像”许可证集合”,比如银行排队有3个窗口(permit),但是有10个人排队,那这里窗口就相当于许可证,每当一个窗口处理完成后,释放(realse)出一个许可证,排队的人进入一个窗口,知道所有排队的人完成业务处理.<br>下面通过一个demo来说明用法:</p>
<pre><code class="java">public class TestSemaphore {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(5);
        for (int i = 0; i &lt; 20; i++) {
            final int NO = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        semaphore.acquire();
                        System.out.println(&quot;Access No =&quot; + NO);
                        Thread.sleep((long)(Math.random()*1000));
                        semaphore.release();
                        System.out.println(&quot;Semaphore availiable =&quot; + semaphore.availablePermits());
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }).start();
        }
    }
}
</code></pre>
<p>输出</p>
<pre><code>Access No =1
Access No =2
Access No =0
Access No =3
Access No =4
Semaphore availiable =1
Access No =5
Semaphore availiable =1
Access No =6
Semaphore availiable =1
Access No =7
Semaphore availiable =1
Access No =8
Semaphore availiable =1
Access No =9
Semaphore availiable =1
Access No =10
Semaphore availiable =1
Access No =11
Semaphore availiable =1
Access No =12
Semaphore availiable =1
Access No =13
Semaphore availiable =1
Access No =14
Semaphore availiable =1
Access No =15
Semaphore availiable =1
Access No =16
Semaphore availiable =1
Access No =17
Semaphore availiable =1
Access No =18
Semaphore availiable =1
Access No =19
Semaphore availiable =1
Semaphore availiable =2
Semaphore availiable =3
Semaphore availiable =4
Semaphore availiable =5
</code></pre><p>用法非常简单,有点类似线程池的实现</p>
<h4 id="java-多线程包下的常用类使用"><a href="#java-多线程包下的常用类使用" class="headerlink" title="java 多线程包下的常用类使用"></a>java 多线程包下的常用类使用</h4><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><p>CountDownLatch是指在其内部计数器不为0的情况下,运行把制定的线程阻塞并等待,直到内部计数器为0后,才唤醒阻塞的线程</p>
<pre><code class="java">public class TestCountdownLatch {

    static class Thread1 extends Thread{
        private CountDownLatch latch;

        public Thread1(CountDownLatch latch) {
            this.latch = latch;
        }

        @Override
        public void run() {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            latch.countDown();
            System.out.println(&quot;latch down  &quot;+latch.getCount());
        }
    }

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);
        for (int i = 0; i &lt; 3; i++) {
            Thread1 thread1 = new Thread1(latch);
            thread1.start();
            thread1.join();
        }
        latch.await();
        System.out.println(&quot;done!!!!&quot;);
    }
}
</code></pre>
<p>输出:</p>
<pre><code>latch down  2
latch down  1
latch down  0
done!!!!
</code></pre><h5 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h5><p>阻塞队列是一个支持两种附加超值的队列.这两个附加操作是: 在队列为空的时候,获取元素的线程会一直等待队列变为非空.当队列满时,存储元素的线程会等待队列可用.一个典型的生产者消费者的应用场景.<br>阻塞队列提供了下面四种处理方式:</p>
<table>
<thead>
<tr>
<th>方法\处理方法</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>  插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>  移除方法</td>
<td>remove</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>  检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<h4 id="生产者消费者队列"><a href="#生产者消费者队列" class="headerlink" title="生产者消费者队列"></a>生产者消费者队列</h4><p>生产者消费者队列有两种常用的实现,一种是通过对象本身的wait和notify来实现,另一种是通过阻塞队列来实现<br>先看第一种方式:</p>
<pre><code class="java">public class Channel {
    private Queue&lt;Good&gt; goodList = new LinkedList&lt;&gt;();

    public synchronized Good get() {
        if (goodList.size() == 0) {
            return null;
        }
        return goodList.remove();
    }

    public synchronized void put(Good good) {
        goodList.add(good);
        notify();
    }
}
public class Good {
    private String name;

    public Good(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<p>Channel表示仓库的含义,good表示里面放入的物品,在put的时候唤醒</p>
<pre><code class="java">public class Consumer implements Runnable{
    private String name;
    private Channel channel;

    public Consumer(String name, Channel channel) {
        this.name = name;
        this.channel = channel;
    }

    @Override
    public void run() {
        while (true) {
            Good good = channel.get();
            if (good != null) {
                System.out.println(name + &quot;获得商品: &quot; + good.getName());
            } else {
                synchronized (channel) {
                    try {
                        System.out.println(name + &quot; 进入等待 &quot;);
                        channel.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
</code></pre>
<p>消费者不断的从仓库中获取,如果发现没有了,阻塞进入等待  </p>
<pre><code class="java">public class Producer implements Runnable {

    private static volatile int goodNumber = 0;
    private String name;
    private Channel channel;

    public Producer(String name, Channel channel) {
        this.name = name;
        this.channel = channel;
    }

    @Override
    public void run() {
        while (true) {
            int sleep = new Random().nextInt(2000);
            try {
                Thread.sleep(sleep);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Good good = new Good(&quot;商品-编号&quot; + (++goodNumber));
            System.out.println(name + &quot;生成商品:&quot; + good.getName());
            channel.put(good);
        }
    }
}
</code></pre>
<p>生产者不断的放入物品到仓库中</p>
<pre><code class="java">public class Tester {
    public static void main(String[] args) {
        Channel channel = new Channel();
        new Thread(new Producer(&quot;生成者1&quot;, channel)).start();
        new Thread(new Producer(&quot;生成者2&quot;, channel)).start();
        new Thread(new Producer(&quot;生成者3&quot;, channel)).start();

        new Thread(new Consumer(&quot;消费者1&quot;,channel)).start();
        new Thread(new Consumer(&quot;消费者2&quot;,channel)).start();
        new Thread(new Consumer(&quot;消费者3&quot;,channel)).start();
    }

}
</code></pre>
<p>输出:</p>
<pre><code>消费者1 进入等待
消费者3 进入等待
消费者2 进入等待
生成者2生成商品:商品-编号1
消费者1获得商品: 商品-编号1
消费者1 进入等待
生成者3生成商品:商品-编号2
消费者3获得商品: 商品-编号2
消费者3 进入等待
生成者1生成商品:商品-编号3
消费者2获得商品: 商品-编号3
消费者2 进入等待
生成者3生成商品:商品-编号4
消费者1获得商品: 商品-编号4
消费者1 进入等待
生成者3生成商品:商品-编号5
消费者3获得商品: 商品-编号5
消费者3 进入等待
生成者2生成商品:商品-编号6
消费者2获得商品: 商品-编号6
消费者2 进入等待
生成者3生成商品:商品-编号7
消费者1获得商品: 商品-编号7
消费者1 进入等待
生成者2生成商品:商品-编号8
消费者3获得商品: 商品-编号8
消费者3 进入等待
生成者1生成商品:商品-编号9
消费者2获得商品: 商品-编号9
消费者2 进入等待
生成者3生成商品:商品-编号10
消费者1获得商品: 商品-编号10
消费者1 进入等待
生成者1生成商品:商品-编号11
消费者3获得商品: 商品-编号11
消费者3 进入等待
生成者1生成商品:商品-编号12
消费者2获得商品: 商品-编号12
消费者2 进入等待
生成者2生成商品:商品-编号13
消费者1获得商品: 商品-编号13
消费者1 进入等待
生成者3生成商品:商品-编号14
消费者3获得商品: 商品-编号14
消费者3 进入等待
生成者2生成商品:商品-编号15
消费者2获得商品: 商品-编号15
消费者2 进入等待
生成者1生成商品:商品-编号16
消费者1获得商品: 商品-编号16
消费者1 进入等待
生成者3生成商品:商品-编号17
消费者3获得商品: 商品-编号17
消费者3 进入等待
生成者1生成商品:商品-编号18
消费者2获得商品: 商品-编号18
消费者2 进入等待
生成者2生成商品:商品-编号19
消费者1获得商品: 商品-编号19
消费者1 进入等待
生成者3生成商品:商品-编号20
</code></pre><p>第二种方式,通过阻塞队列来实现:</p>
<pre><code class="java">public class TestBlockingQueue {
    static class Consumer extends Thread{
        private BlockingQueue&lt;Integer&gt; blockingQueue;

        public Consumer(BlockingQueue&lt;Integer&gt; blockingQueue) {
            this.blockingQueue = blockingQueue;
        }

        @Override
        public void run() {
            while (true) {
                try {
                   int i = blockingQueue.take();
                    System.out.println(&quot;get &quot;+i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    static class Producer extends Thread{
        private BlockingQueue&lt;Integer&gt; blockingQueue;

        public Producer(BlockingQueue&lt;Integer&gt; blockingQueue) {
            this.blockingQueue = blockingQueue;
        }

        @Override
        public void run() {
            try {
                for (int i = 0; i &lt; 10; i++) {
                    System.out.println(&quot;put &quot; + i);
                    blockingQueue.put(i);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;();
        new Consumer(queue).start();
        new Producer(queue).start();
    }
}
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/12/16/2016/ThreadLocal源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/16/2016/ThreadLocal源码分析/" itemprop="url">ThreadLocal源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-16T09:44:00+08:00">
                2016-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h2><p>  根据命名可以理解为”线程独有的”变量,也就是说这些变量是与所属线程相对应的,每个线程都有该变量独有的一份拷贝,相互之间是透明的.ThreadLocal实例的典型运用应该是private static的成员变量,比如去获取userId或者Transaction ID.</p>
<p>  ThreadLocal是一种线程安全的区别于锁机制的实现方式,通过线程隔离来完成线程数据之间不互相干扰.</p>
<p>  ThreadLocal使用非常简单,只有4个常用方法,分别是:</p>
<p>  <em>get()</em> :用来获取当前线程中的变量值<br>  <em>set(T value)</em> :用来给当前线程中的变量赋值<br>  <em>remove</em> :用来移除当前线程中的变量值<br>  <em>initialValue()</em> :用来在第一次get没有值得时候做初始化操作,一般是通过复写该方法来完成初始化的</p>
<p>  下面是一个demo代码,用来给每个调用它的线程产生一个唯一ID:</p>
<pre><code class="java">  public class ThreadId {
     // Atomic integer containing the next thread ID to be assigned
     private static final AtomicInteger nextId = new AtomicInteger(0);

     // Thread local variable containing each thread&#39;s ID
     private static final ThreadLocal&lt;Integer&gt; threadId =
         new ThreadLocal&lt;Integer&gt;() {
             @Override protected Integer initialValue() {
                 return nextId.getAndIncrement();
         }
     };

     // Returns the current thread&#39;s unique ID, assigning it if necessary
     public static int get() {
         return threadId.get();
     }
 }
</code></pre>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>  既然不同的线程所包含的变量值不一样,那么内部肯定是有一种类似map的数据结构在做一一对应关系.<br>  构造函数就是一个普通构造函数,我们从 <em>set()</em> 方法开始:</p>
<pre><code class="java">  public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings(&quot;unchecked&quot;)
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
</code></pre>
<p>  首先是获取当前的线程对象,然后调用 <em>getMap</em> 方法返回一个 <em>ThreadLocalMap</em> 对象,再看 <em>getMap</em> 方法:</p>
<pre><code class="java">  ThreadLocalMap getMap(Thread t) {
       return t.threadLocals;
   }
</code></pre>
<p>  说明 <em>ThreadLocalMap</em> 来自于每个线程对象中.不过定义是在ThreadLocal中定义的,从明明商可以看到这个对象就是我们前面猜测的一种具有map性质的数据结构.<br>  其中key就是this也就是当前的ThreadLocal对象本身,value就是我们给ThreadLocal的赋值对象了.如果没有找到 <em>ThreadLocalMap</em> 对象,进入 <em>setInitialValue</em> 方法</p>
<pre><code class="java">  /**
    * Variant of set() to establish initialValue. Used instead
    * of set() in case user has overridden the set() method.
    *
    * @return the initial value
    */
   private T setInitialValue() {
       T value = initialValue();
       Thread t = Thread.currentThread();
       ThreadLocalMap map = getMap(t);
       if (map != null)
           map.set(this, value);
       else
           createMap(t, value);
       return value;
   }
</code></pre>
<p>  在这里就会调用前面说过的4个常用方法之一的 <em>initialValue</em> 方法,用来做初始化赋值.同样,如果map存在就直接赋值,否者进入 <em>createMap</em> 方法</p>
<pre><code class="java">
    /**
     * Create the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param t the current thread
     * @param firstValue value for the initial entry of the map
     */
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }
</code></pre>
<p>  非常简单,给Thread的对象的ThreadLocalMap对象赋值,同时把变量值也赋给ThreadLocalMap.<br>  再看 <em>set</em> 方法,也很简单清晰:</p>
<pre><code class="java">  /**
    * Sets the current thread&#39;s copy of this thread-local variable
    * to the specified value.  Most subclasses will have no need to
    * override this method, relying solely on the {@link #initialValue}
    * method to set the values of thread-locals.
    *
    * @param value the value to be stored in the current thread&#39;s copy of
    *        this thread-local.
    */
   public void set(T value) {
       Thread t = Thread.currentThread();
       ThreadLocalMap map = getMap(t);
       if (map != null)
           map.set(this, value);
       else
           createMap(t, value);
   }
</code></pre>
<p>  4个方法分分钟就讲完了,是不是非常简单,剩余核心其实就是 <em>ThreadLocalMap</em> 的实现方式了,在其内部实现了map类型的数据结构,先来看map中的Entry对象:</p>
<pre><code class="java">  /**
        * The entries in this hash map extend WeakReference, using
        * its main ref field as the key (which is always a
        * ThreadLocal object).  Note that null keys (i.e. entry.get()
        * == null) mean that the key is no longer referenced, so the
        * entry can be expunged from table.  Such entries are referred to
        * as &quot;stale entries&quot; in the code that follows.
        */
       static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
           /** The value associated with this ThreadLocal. */
           Object value;

           Entry(ThreadLocal&lt;?&gt; k, Object v) {
               super(k);
               value = v;
           }
       }
</code></pre>
<p>  可以看到key是 通过弱引用包含的ThreadLocal对象,value就是我们给ThreadLocal的赋值.<br>  下面来看map中的set实现:</p>
<pre><code class="java">  /**
         * Set the value associated with key.
         *
         * @param key the thread local object
         * @param value the value to be set
         */
        private void set(ThreadLocal&lt;?&gt; key, Object value) {

            // We don&#39;t use a fast path as with get() because it is at
            // least as common to use set() to create new entries as
            // it is to replace existing ones, in which case, a fast
            // path would fail more often than not.

            Entry[] tab = table;
            int len = tab.length;
            int i = key.threadLocalHashCode &amp; (len-1);

            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) {
                ThreadLocal&lt;?&gt; k = e.get();

                if (k == key) {
                    e.value = value;
                    return;
                }

                if (k == null) {
                    replaceStaleEntry(key, value, i);
                    return;
                }
            }

            tab[i] = new Entry(key, value);
            int sz = ++size;
            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
                rehash();
        }
</code></pre>
<p>  遍历所有的Entry数组,如果找到key值一样的直接覆盖,如果发现一个key为空的情况,把那个位置的对象更新一下,否者如果刚开始Entry数组对象为空的时候,直接赋值数组的指定位置.这个位置是通过上面的对应hash算法生成的.<br>  map内部的清空无用的值的算法太复杂了,就不介绍了,重点是明白ThreadLocal的原理就可以了.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/12/09/2016/java基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/09/2016/java基础知识/" itemprop="url">java基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-09T14:50:00+08:00">
                2016-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="map的put方法的返回值"><a href="#map的put方法的返回值" class="headerlink" title="map的put方法的返回值"></a>map的put方法的返回值</h2><p>  今天在看EventBus源码的时候发现一行代码 ,是放一个map中put数据,关键是map的put方法居然有返回值,今天才是刚刚发现这个神奇的常识,后来通过写个demo验证一下返回值情况</p>
<pre><code class="java">
Map&lt;String, String&gt; map = new TreeMap&lt;&gt;();
        String a = map.put(&quot;a&quot;, &quot;123&quot;);
        System.out.println(&quot;a = &quot; + a);

        String a1 = map.put(&quot;a&quot;, &quot;123&quot;);
        System.out.println(&quot;a1 = &quot; + a1);

        String a2 = map.put(&quot;a&quot;, &quot;789&quot;);
        System.out.println(&quot;a2 = &quot; + a2);

        String b = map.put(&quot;b&quot;, &quot;456&quot;);
        System.out.println(&quot;b = &quot;+ b);
</code></pre>
<p>返回值为:</p>
<pre><code class="java">a = null
a1 = 123
a2 = 123
b = null
</code></pre>
<p>可见,如果是map中没有的数据,返回空,如果已经存在的数据,返回对应的value,如果是覆盖数据的话会返回之前存储的value</p>
<pre><code class="java">/**
     * Implements Map.put and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don&#39;t change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>
<h2 id="java-isAssignableFrom-Class-lt-gt-code-方法的使用"><a href="#java-isAssignableFrom-Class-lt-gt-code-方法的使用" class="headerlink" title="java isAssignableFrom(Class&lt;?&gt; code)方法的使用"></a>java isAssignableFrom(Class&lt;?&gt; code)方法的使用</h2><p>下面是该方法的个人翻译:</p>
<blockquote>
<p>决定当前的class对象是否是传入对象的父类,父接口,或者相同的类对象<br>特别是这个用来判断传入的class对象是否可以转换为当前class对象或者更宽的关联转换</p>
</blockquote>
<p>可见,该方法正好和 <em>instance of</em> 方法相反,用来判断当前class是不是param class的父类或本身.而 <em>instance of</em> 是判断一个对象是不是另一个类的实现<br>还有一个方法是class里面的 <em>isInstance(Object obj)</em> ,用来判断当前的obj是不是当前class的实现, <em>instance of</em> 和 <em>isInstance</em> 功能一样</p>
<h2 id="A-class和new-A-getClass的区别"><a href="#A-class和new-A-getClass的区别" class="headerlink" title="A.class和new A().getClass的区别"></a>A.class和new A().getClass的区别</h2><p>两个方法都是返回class实例变量,正常情况下是一样的,除了多态的时候</p>
<blockquote>
<p>a.getClass返回的是运行时类型,如果A a = new B(),那么a.getClass返回的是B class<br>A.class返回的是A class静态对象 ,一般用作反射时候使用<br>A.class是在编译的时候就确定了,而a.getClass()却是在运行的时候确定的</p>
</blockquote>
<h2 id="java中的transient关键字"><a href="#java中的transient关键字" class="headerlink" title="java中的transient关键字"></a>java中的transient关键字</h2><p>transient英文的意思是”瞬态的,短暂的”,反义词是”permament”,永久的.<br>在java中,如果一个变量的前面添加了 <em>transient</em> 关键字,表明在当前对象的序列号中中,该变量将不被序列化.<br>关于 <em>transient</em> 的使用有下面三点:</p>
<ol>
<li>一旦变量被 <em>transient</em> 修饰,变量将不再是对象持久化的一部分,该变量内容在序列化后无法获得访问</li>
<li><em>transient</em> 关键字只能修饰变量,而不能修饰类和方法.注意,本地变量是不能被 <em>transient</em> 关键字修饰的.变量如果是用户自定义变量,则改类需要实现Serialiazble接口.</li>
<li>被 <em>transient</em> 关键字修饰的变量不再能被序列化,一个静态变量不管是否被 <em>transient</em> 修饰,均不能被序列化.  </li>
</ol>
<h2 id="java中如何快速的跳出多重循环"><a href="#java中如何快速的跳出多重循环" class="headerlink" title="java中如何快速的跳出多重循环"></a>java中如何快速的跳出多重循环</h2><p>一种是通过外面设置一个flag,通过判断flag来结束每一层的循环,还有一种是通过循环标签来快速完成:</p>
<pre><code class="java">public static void loop(){
    OK:
    for (int i = 1 ; i &lt; 100 ; i++ ) {
        for (int j = 1 ;j &lt;=i ;j++ ) {
            if (i == 10) {
              //在这里会退出所有的循环
              break OK;
            }else if(i == 2){
              //只会退出当前一次的内层循环
              continue OK;
            }
        }
    }
}
</code></pre>
<h2 id="java中Thread-的run和start方法的区别"><a href="#java中Thread-的run和start方法的区别" class="headerlink" title="java中Thread 的run和start方法的区别"></a>java中Thread 的run和start方法的区别</h2><p>run是在当前线程中直接调用run方法中的代码,这个时候线程对象就是一个普通的对象,线程没有运行.<br>start方法新开一个线程来执行run方法中的代码.</p>
<pre><code class="java">public synchronized void start() {
      checkNotStarted();

      hasBeenStarted = true;

      nativeCreate(this, stackSize, daemon);
  }
</code></pre>
<pre><code class="java">public void run() {
    if (target != null) {
        target.run();
    }
}
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/12/09/2016/EventBus源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/09/2016/EventBus源码解析/" itemprop="url">EventBus源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-09T14:05:00+08:00">
                2016-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="EventBus3-0源码解析"><a href="#EventBus3-0源码解析" class="headerlink" title="EventBus3.0源码解析"></a>EventBus3.0源码解析</h2><p>  使用方法是在工程的任何一个地方都可以通过EventBus对象来post一个Event对象给EventBus，然后在需要处理Event对象的类中register该类来响应处理，那么程序的入口就从EventBus的register方法入手了。</p>
<pre><code class="java">public void register(Object subscriber) {
        Class&lt;?&gt; subscriberClass = subscriber.getClass();
        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
        synchronized (this) {
            for (SubscriberMethod subscriberMethod : subscriberMethods) {
                subscribe(subscriber, subscriberMethod);
            }
        }
    }
</code></pre>
<p>可以看到register方法中的核心方法在 <em>subscriberMethodFinder.findSubscriberMethods</em> 来返回所有注册的方法对象<br>那么下一步就进入 <em>subscriberMethodFinder</em> 来查看这个 <em>findSubscriberMethods</em> 方法</p>
<pre><code class="java">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) {
       List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);
       if (subscriberMethods != null) {
           return subscriberMethods;
       }

       if (ignoreGeneratedIndex) {
           subscriberMethods = findUsingReflection(subscriberClass);
       } else {
           subscriberMethods = findUsingInfo(subscriberClass);
       }
       if (subscriberMethods.isEmpty()) {
           throw new EventBusException(&quot;Subscriber &quot; + subscriberClass
                   + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);
       } else {
           METHOD_CACHE.put(subscriberClass, subscriberMethods);
           return subscriberMethods;
       }
   }
</code></pre>
<p>可以看到 <em>findSubscriberMethods</em> 方法中,关键点就在 <em>findUsingReflection</em> 和 <em>findUsingInfo</em> 这两个方法中.由于 <em>findUsingReflection</em> 的代码比较少,所以先从这个方法开始.</p>
<pre><code class="java">private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) {
       FindState findState = prepareFindState();
       findState.initForSubscriber(subscriberClass);
       while (findState.clazz != null) {
           findUsingReflectionInSingleClass(findState);
           findState.moveToSuperclass();
       }
       return getMethodsAndRelease(findState);
   }
</code></pre>
<p>这里用来存放匹配结果的中间对象叫做 <em>FindState</em> ,稍后具体来说 <em>FindState</em> 的内部实现,现在先看一个生成 <em>FindState</em> 对象的方法 <em>prepareFindState</em></p>
<pre><code class="java">private FindState prepareFindState() {
        synchronized (FIND_STATE_POOL) {
            for (int i = 0; i &lt; POOL_SIZE; i++) {
                FindState state = FIND_STATE_POOL[i];
                if (state != null) {
                    FIND_STATE_POOL[i] = null;
                    return state;
                }
            }
        }
        return new FindState();
    }
</code></pre>
<pre><code class="java">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) {
        List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);
        findState.recycle();
        synchronized (FIND_STATE_POOL) {
            for (int i = 0; i &lt; POOL_SIZE; i++) {
                if (FIND_STATE_POOL[i] == null) {
                    FIND_STATE_POOL[i] = findState;
                    break;
                }
            }
        }
        return subscriberMethods;
    }
</code></pre>
<p>这里 <em>FIND_STATE_POOL</em> 是一个对象池,最大容量4个,可以想象,如果每次都生成一个 <em>findState</em> 的方法的话,会生成很多很多的中间对象,对性能造成影响,所以通过一个对象池来解决大量中间计算对象的问题,首先如果在对象池中找到有对象就直接使用,同时把对象池中的对象置空,最后回收的时候把用完了的对象放入对象池中,达到了循环引用的目的.感觉这个设计非常巧妙.</p>
<p>下一步我们来到 <em>findUsingReflection</em> 方法中的 <em>findUsingReflectionInSingleClass</em> 方法中</p>
<pre><code class="java">private void findUsingReflectionInSingleClass(FindState findState) {
        Method[] methods;
        try {
            // This is faster than getMethods, especially when subscribers are fat classes like Activities
            methods = findState.clazz.getDeclaredMethods();
        } catch (Throwable th) {
            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
            methods = findState.clazz.getMethods();
            findState.skipSuperClasses = true;
        }
        for (Method method : methods) {
            int modifiers = method.getModifiers();
            if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {
                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
                if (parameterTypes.length == 1) {
                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                    if (subscribeAnnotation != null) {
                        Class&lt;?&gt; eventType = parameterTypes[0];
                        if (findState.checkAdd(method, eventType)) {
                            ThreadMode threadMode = subscribeAnnotation.threadMode();
                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                        }
                    }
                } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {
                    String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();
                    throw new EventBusException(&quot;@Subscribe method &quot; + methodName +
                            &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);
                }
            } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {
                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();
                throw new EventBusException(methodName +
                        &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);
            }
        }
    }
</code></pre>
<p>核心代码在for循环中的第一个if中,其他的是严格模式下返回异常信息.<br>首先取到注册类中的所有的声明方法,然后遍历找到其中是public的并且不是静态,抽象,中间编译器生成的方法,下面是这需要忽略类型的并集</p>
<pre><code class="java"> private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;
</code></pre>
<p>看代码,明确要求注册方法必须只能有一个参数,同时注解必须是Subscribe对象类型,然后获取第一个param的类型,交由 <em>findState.checkAdd(method,eventType)</em> 方法去判断是否需要添加到事件绑定中.</p>
<pre><code class="java">boolean checkAdd(Method method, Class&lt;?&gt; eventType) {
            // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.
            // Usually a subscriber doesn&#39;t have methods listening to the same event type.
            Object existing = anyMethodByEventType.put(eventType, method);
            if (existing == null) {
                return true;
            } else {
                if (existing instanceof Method) {
                    if (!checkAddWithMethodSignature((Method) existing, eventType)) {
                        // Paranoia check
                        throw new IllegalStateException();
                    }
                    // Put any non-Method object to &quot;consume&quot; the existing Method
                    anyMethodByEventType.put(eventType, this);
                }
                return checkAddWithMethodSignature(method, eventType);
            }
        }
</code></pre>
<p>通过该方法的注释可以看到,有两层快速判断:第一层是通过eventType来判断,这种比较快,第二层是通过完成的签名来判断;通常情况下一个事件接受类不应该有多个方法对同一种类型的事件进行监听;<br>首先把eventType作为key,method对象作为value放入anyMethodByEventType这个map中,如果返回null说明之前是没有的放过的同样类型的eventType的,如果返回不为Null,说明anyMethodByEventType中已经有了同样的eventType事件监听,就需要更进一步的判断,交给下面的 <em>checkAddWithMethodSignature</em> 方法来处理.</p>
<pre><code class="java">private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) {
           methodKeyBuilder.setLength(0);
           methodKeyBuilder.append(method.getName());
           methodKeyBuilder.append(&#39;&gt;&#39;).append(eventType.getName());

           String methodKey = methodKeyBuilder.toString();
           Class&lt;?&gt; methodClass = method.getDeclaringClass();
           Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);
           if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {
               // Only add if not already found in a sub class
               return true;
           } else {
               // Revert the put, old class is further down the class hierarchy
               subscriberClassByMethodKey.put(methodKey, methodClassOld);
               return false;
           }
       }
</code></pre>
<p>首先是把方法名+接收参数类型名作为key存入map中,如果之前没有放入过,那么直接把返回true,交给上面的checkAdd返回true,说明事件绑定成功<br>如果已经放入过了,说明有两个同样名称的方法并且监听的居然是同一种eventType,获取方法的声明类class对象,和之前放入的声明class对象做isAssignableFrom判断,如果isAssignableFrom为true,说明已经放入的class是新放入的class本身类或者父类,返回true,可以添加,否则返回false,不可以添加,交给 <em>checkState</em> 方法throw一个异常.为什么会出现这种情况呢?个人思考了下应该是首先子类已经注册了一个subscribe方法对某一eventType做监听,同事父类里面有个同名方法对同样的eventType做监听,那么就会出现到底该绑定哪个方法的问题,这个时候优先绑定子类中同名方法,也就是离继承结构更远的方法,越靠近实现优先放入.</p>
<p>当当前类所有的绑定都完成之后, 通过 <em>findState.moveToSuperclass();</em> 让findState对象的class属性指向当前类的父类继续完成上面的操作,直到没有父类为止.</p>
<pre><code class="java">
void moveToSuperclass() {
           if (skipSuperClasses) {
               clazz = null;
           } else {
               clazz = clazz.getSuperclass();
               String clazzName = clazz.getName();
               /** Skip system classes, this just degrades performance. */
               if (clazzName.startsWith(&quot;java.&quot;) || clazzName.startsWith(&quot;javax.&quot;) || clazzName.startsWith(&quot;android.&quot;)) {
                   clazz = null;
               }
           }
       }
</code></pre>
<p>这里忽略掉了java和android的公共类,节省性能,系统的类是没有必要继续遍历的.<br>当当前类包括其自定义父类全部都遍历完成后,调用 <em>getMethodsAndRelease(findState)</em> 生成绑定方法的集合</p>
<pre><code class="java">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) {
        List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);
        findState.recycle();
        synchronized (FIND_STATE_POOL) {
            for (int i = 0; i &lt; POOL_SIZE; i++) {
                if (FIND_STATE_POOL[i] == null) {
                    FIND_STATE_POOL[i] = findState;
                    break;
                }
            }
        }
        return subscriberMethods;
    }
</code></pre>
<p>上面的流程是 <em>findUsingReflection</em> 方法的主要实现流程,还记得有两个绑定事件的方法吗?还有一个是 <em>findUsingInfo</em> 通过一个变量开关来开启 <em>ignoreGeneratedIndex</em> ,刚开始么有看懂是啥意思,上网查了下资料发现这个功能是3.0新加的,个人理解有点像 <em>预编译</em> 在编译的时候通过 apt中新增一个AnnotationProcessor来把代码中声明了subscribe的方法提前生成一个index集合,这样可以快速的完成事件的绑定,加快运行速度.</p>
<p>java的annotation如果声明为source的target的时候,可以通过继承一个AbstractProcessor来处理自定义annotation.<br>具体的实现方式这里先不展开了,感兴趣的话可以上网去看下官方说明<a href="http://greenrobot.org/eventbus/documentation/subscriber-index/" title="subscriber-index" target="_blank" rel="external">subscriber-index</a></p>
<p>完成了事件绑定之后,就进入EventBus的核心方法 <em>subscribe</em> 了,通过它来完成一个观察者模式,在post的时候找到事件绑定的方法然后调用它,这样就完成了一个事件从绑定到响应的主流程.</p>
<pre><code class="java">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
        Class&lt;?&gt; eventType = subscriberMethod.eventType;
        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);
        if (subscriptions == null) {
            subscriptions = new CopyOnWriteArrayList&lt;&gt;();
            subscriptionsByEventType.put(eventType, subscriptions);
        } else {
            if (subscriptions.contains(newSubscription)) {
                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                        + eventType);
            }
        }

        int size = subscriptions.size();
        for (int i = 0; i &lt;= size; i++) {
            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {
                subscriptions.add(i, newSubscription);
                break;
            }
        }

        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);
        if (subscribedEvents == null) {
            subscribedEvents = new ArrayList&lt;&gt;();
            typesBySubscriber.put(subscriber, subscribedEvents);
        }
        subscribedEvents.add(eventType);

        if (subscriberMethod.sticky) {
            if (eventInheritance) {
                // Existing sticky events of all subclasses of eventType have to be considered.
                // Note: Iterating over all events may be inefficient with lots of sticky events,
                // thus data structure should be changed to allow a more efficient lookup
                // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).
                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();
                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {
                    Class&lt;?&gt; candidateEventType = entry.getKey();
                    if (eventType.isAssignableFrom(candidateEventType)) {
                        Object stickyEvent = entry.getValue();
                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                    }
                }
            } else {
                Object stickyEvent = stickyEvents.get(eventType);
                checkPostStickyEventToSubscription(newSubscription, stickyEvent);
            }
        }
    }
</code></pre>
<h3 id="subscribe方法"><a href="#subscribe方法" class="headerlink" title="subscribe方法"></a>subscribe方法</h3><p>  当通过register方法获得了绑定事件的集合之后,就需要把注册类和绑定事件结合在一起,这样在post方法调用之后,可以快速的找到哪些类的哪些方法可以响应这次post事件,然后通过method对象的反射方法invoke(Object obj,Object… args)来调用绑定事件的方法.其中第二个参数就是post方法传入的eventType对象,第一个参数是register传入的绑定对象.一般是class对象.</p>
<pre><code class="java">  // Must be called in synchronized block
   private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
       Class&lt;?&gt; eventType = subscriberMethod.eventType;
       Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
       CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);
       if (subscriptions == null) {
           subscriptions = new CopyOnWriteArrayList&lt;&gt;();
           subscriptionsByEventType.put(eventType, subscriptions);
       } else {
           if (subscriptions.contains(newSubscription)) {
               throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                       + eventType);
           }
       }

       int size = subscriptions.size();
       for (int i = 0; i &lt;= size; i++) {
           if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {
               subscriptions.add(i, newSubscription);
               break;
           }
       }

       List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);
       if (subscribedEvents == null) {
           subscribedEvents = new ArrayList&lt;&gt;();
           typesBySubscriber.put(subscriber, subscribedEvents);
       }
       subscribedEvents.add(eventType);

       if (subscriberMethod.sticky) {
           if (eventInheritance) {
               // Existing sticky events of all subclasses of eventType have to be considered.
               // Note: Iterating over all events may be inefficient with lots of sticky events,
               // thus data structure should be changed to allow a more efficient lookup
               // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).
               Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();
               for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {
                   Class&lt;?&gt; candidateEventType = entry.getKey();
                   if (eventType.isAssignableFrom(candidateEventType)) {
                       Object stickyEvent = entry.getValue();
                       checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                   }
               }
           } else {
               Object stickyEvent = stickyEvents.get(eventType);
               checkPostStickyEventToSubscription(newSubscription, stickyEvent);
           }
       }
</code></pre>
<p>  抛开该方法最底下的sticky判断那块,代码其实很简单,主要是为两个map完成赋值操作.<br>  两个map分别是:</p>
<pre><code class="java">  private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;
</code></pre>
<p>  key是eventType,value是所有的绑定该事件的方法对象,可以理解就是触发post的时候,可以通过这个map快速的找到都有哪些方法绑定了该事件,然后通过遍历调用他们</p>
<pre><code class="java">  private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;
</code></pre>
<p>  这个map的key是register传入的对象,value是这个对象内部所有的绑定方法,这个map主要是用来unRegister的时候可以把该对象中所有的绑定方法全部移除,节省时间,提升效率</p>
<p>  当完成两个map的赋值工作之后,时间绑定对应关系就确定了,那么剩下逻辑就是看post方法的相关处理了.</p>
<h3 id="post方法"><a href="#post方法" class="headerlink" title="post方法"></a>post方法</h3><pre><code class="java">  /** Posts the given event to the event bus. */
  public void post(Object event) {
      PostingThreadState postingState = currentPostingThreadState.get();
      List&lt;Object&gt; eventQueue = postingState.eventQueue;
      eventQueue.add(event);

      if (!postingState.isPosting) {
          postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
          postingState.isPosting = true;
          if (postingState.canceled) {
              throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);
          }
          try {
              while (!eventQueue.isEmpty()) {
                  postSingleEvent(eventQueue.remove(0), postingState);
              }
          } finally {
              postingState.isPosting = false;
              postingState.isMainThread = false;
          }
      }
  }
</code></pre>
<p>这里的 <em>currentPostingThreadState</em>用到了ThreadLocal这种概念,ThreadLocal是指每个线程都有自己的独有变量,线程之间不互相干扰,是线程同步的另一种解决方法.ThreadLocal在第一次获取数据的时候如果没有的话就会调用它自己的initialValue方法,现在是返回一个 <em>PostingThreadState</em> 对象</p>
<pre><code class="java">/** For ThreadLocal, much faster to set (and get multiple values). */
   final static class PostingThreadState {
       final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;();
       boolean isPosting;
       boolean isMainThread;
       Subscription subscription;
       Object event;
       boolean canceled;
   }
</code></pre>
<p>其中的 <em>eventQueue</em> 相当于一个事件处理队列,isPosting用来做单条发送的间隔开关,就是每次消化一个事件,isMainThread用来表示是否在主线程发布,对应EventBus的ThreadMode4种模式的处理,后续会讲到.下面进入 <em>postSingleEvent</em> 方法</p>
<pre><code class="java">
    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
        Class&lt;?&gt; eventClass = event.getClass();
        boolean subscriptionFound = false;
        if (eventInheritance) {
            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);
            int countTypes = eventTypes.size();
            for (int h = 0; h &lt; countTypes; h++) {
                Class&lt;?&gt; clazz = eventTypes.get(h);
                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
            }
        } else {
            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
        }
        if (!subscriptionFound) {
            if (logNoSubscriberMessages) {
                Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass);
            }
            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;
                    eventClass != SubscriberExceptionEvent.class) {
                post(new NoSubscriberEvent(this, event));
            }
        }
</code></pre>
<p>下面来解释一下 <em>eventInheritance</em> 这个开关,通过字面理解是 “事件继承” ,通过查阅文档说明,解释如下</p>
<blockquote>
<p>默认情况下,EventBus认为绑定事件Event Class是具有继承性的,也就是说绑定了Event Class的父类方法在post Event class的时候也会触发.<br>关闭这项功能,可以加快事件传递的速度.如果关闭的话,大概事件post速度大概会提高20%,如果是复杂的Event继承关系的话,速度会提升大于20%</p>
</blockquote>
<p>默认是开启 <em>事件继承</em> 功能的,所以我们进入 <em>lookupAllEventTypes</em> 方法</p>
<pre><code class="java">/** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */
   private static List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) {
       synchronized (eventTypesCache) {
           List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);
           if (eventTypes == null) {
               eventTypes = new ArrayList&lt;&gt;();
               Class&lt;?&gt; clazz = eventClass;
               while (clazz != null) {
                   eventTypes.add(clazz);
                   addInterfaces(eventTypes, clazz.getInterfaces());
                   clazz = clazz.getSuperclass();
               }
               eventTypesCache.put(eventClass, eventTypes);
           }
           return eventTypes;
       }
   }
</code></pre>
<pre><code class="java">/** Recurses through super interfaces. */
    static void addInterfaces(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces) {
        for (Class&lt;?&gt; interfaceClass : interfaces) {
            if (!eventTypes.contains(interfaceClass)) {
                eventTypes.add(interfaceClass);
                addInterfaces(eventTypes, interfaceClass.getInterfaces());
            }
        }
    }
</code></pre>
<p>通过代码很容易理解,获取当前post的Event class的所有父类和接口类,然后放入 <em>eventTypes</em> 集合中,分别发送一次,这样当你post一个事件的时候,相当于该事件对象的所有父类和接口类都post了一次.<br>直观一点举例,比如一个叫CommonEvent的类,父类是BaseEvent,接口是IEvent,那么当你post CommonEvent的时候,所有接受BaseEvent 和IEvent的绑定方法也会触发.</p>
<p>这里为了加快速度,把类的关系链存入了一个集合作为缓存使用.</p>
<pre><code class="java">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) {
        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;
        synchronized (this) {
            subscriptions = subscriptionsByEventType.get(eventClass);
        }
        if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {
            for (Subscription subscription : subscriptions) {
                postingState.event = event;
                postingState.subscription = subscription;
                boolean aborted = false;
                try {
                    postToSubscription(subscription, event, postingState.isMainThread);
                    aborted = postingState.canceled;
                } finally {
                    postingState.event = null;
                    postingState.subscription = null;
                    postingState.canceled = false;
                }
                if (aborted) {
                    break;
                }
            }
            return true;
        }
        return false;
</code></pre>
<p>下面马上进入post之后的回调处理,首先通过Event找到所有绑定该事件的方法集合,这里返回的是一个 <em>CopyOnWriteArrayList<subscription></subscription></em> ,然后遍历之,逐条调用绑定方法.进入 <em>postToSubscription</em> ,根据ThreadMode来做不同的回调处理.</p>
<pre><code class="java">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
        switch (subscription.subscriberMethod.threadMode) {
            case POSTING:
                invokeSubscriber(subscription, event);
                break;
            case MAIN:
                if (isMainThread) {
                    invokeSubscriber(subscription, event);
                } else {
                    mainThreadPoster.enqueue(subscription, event);
                }
                break;
            case BACKGROUND:
                if (isMainThread) {
                    backgroundPoster.enqueue(subscription, event);
                } else {
                    invokeSubscriber(subscription, event);
                }
                break;
            case ASYNC:
                asyncPoster.enqueue(subscription, event);
                break;
            default:
                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);
        }
    }
</code></pre>
<p><em>postToSubscription</em> 这个方法就是回调的核心逻辑所在,通过threadMode的不同来对应不同的处理关系.<br>先翻译一下关于ThreadMode的文档说明:</p>
<ol>
<li>ThreadMode: POSTING<br>接收者会在与post方法的同一个线程中同步执行,这种方式的开销最小,主要是避免了线程切换,这种模式推荐使用在可以快速完成的简单任务并且不需要阻塞主线程.<pre><code class="java"> // Called in the same thread (default)
 // ThreadMode is optional here
 @Subscribe(threadMode = ThreadMode.POSTING)
 public void onMessage(MessageEvent event) {
     log(event.message);
 }
</code></pre>
</li>
<li>ThreadMode: MAIN<br>接收者会在android的主线程中被调用,如果post的事件是在主线程中,那么这时调用方法会直接被调用和上面的Posting一样,这种模式推荐处理很快并且不会阻塞主线程的逻辑<pre><code class="java">// Called in Android UI&#39;s main thread
@Subscribe(threadMode = ThreadMode.MAIN)
public void onMessage(MessageEvent event) {
textField.setText(event.message);
}
</code></pre>
</li>
<li>ThreadMode: BACKGROUND<br>接收者会在一个后台线程中别调用,如果post事件不是在主线程中,那么调用事件就会直接在post的线程中执行,如果是在主线程中post的话,EventBus会启用一个后台线程来处理所有这类event事件,事件回调应该迅速并且不会阻塞后台线程<pre><code class="java">// Called in the background thread
@Subscribe(threadMode = ThreadMode.BACKGROUND)
public void onMessage(MessageEvent event){
   saveToDisk(event.message);
}
</code></pre>
</li>
<li>ThreadMode: ASYNC<br>事件回调会在一个单独的子线程中完成,这种情况下事件回调的线程是独立于主线程和post所在的线程的,是一个单独的线程,事件的post是不会等待回调方法的执行完成与否的,这种模式应该用于事件回调需要执行一段事件,比如网络请求等,要避免触发类似大量的长时间运行的异步线程.EventBus使用一个线程池来管理和回收这种线程.<pre><code class="java">// Called in a separate thread
@Subscribe(threadMode = ThreadMode.ASYNC)
public void onMessage(MessageEvent event){
   backend.send(event.message);
}
</code></pre>
<a href="http://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/" title="官方ThreadMode说明" target="_blank" rel="external">官方ThreadMode说明</a></li>
</ol>
<p>  看完了官方说明之后,我们再来看代码具体实现,这个时候就已经很清晰了</p>
<pre><code class="java">  private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
       switch (subscription.subscriberMethod.threadMode) {
           case POSTING:
               invokeSubscriber(subscription, event);
               break;
           case MAIN:
               if (isMainThread) {
                   invokeSubscriber(subscription, event);
               } else {
                   mainThreadPoster.enqueue(subscription, event);
               }
               break;
           case BACKGROUND:
               if (isMainThread) {
                   backgroundPoster.enqueue(subscription, event);
               } else {
                   invokeSubscriber(subscription, event);
               }
               break;
           case ASYNC:
               asyncPoster.enqueue(subscription, event);
               break;
           default:
               throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);
       }
   }
</code></pre>
<p>  switch对应4中不同的ThreadMode,默认的模式使用的是POSTING,就是post在哪个线程那么回调就在哪个线程中.</p>
<pre><code class="java">  void invokeSubscriber(Subscription subscription, Object event) {
      try {
          subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
      } catch (InvocationTargetException e) {
          handleSubscriberException(subscription, event, e.getCause());
      } catch (IllegalAccessException e) {
          throw new IllegalStateException(&quot;Unexpected exception&quot;, e);
      }
  }
</code></pre>
<p>  <em>invokeSubscriber</em> 方法就是通过反射来回调绑定方法,结果非常简单.</p>
<p>  如果是 <em>MAIN</em> 模式下,判断是否在主线程,如果在主线程直接调用,如果在子线程中,通过 <em>mainThreadPoster</em> 来回到主线程中.</p>
<p>  来看 <em>mainThreadPoster</em> 的内部实现,实际上就是一个在主线程中的Handler.</p>
<pre><code class="java">   mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
</code></pre>
<pre><code class="java">  final class HandlerPoster extends Handler {

    private final PendingPostQueue queue;
    private final int maxMillisInsideHandleMessage;
    private final EventBus eventBus;
    private boolean handlerActive;

    HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) {
        super(looper);
        this.eventBus = eventBus;
        this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;
        queue = new PendingPostQueue();
    }

    void enqueue(Subscription subscription, Object event) {
        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
        synchronized (this) {
            queue.enqueue(pendingPost);
            if (!handlerActive) {
                handlerActive = true;
                if (!sendMessage(obtainMessage())) {
                    throw new EventBusException(&quot;Could not send handler message&quot;);
                }
            }
        }
    }

    @Override
    public void handleMessage(Message msg) {
        boolean rescheduled = false;
        try {
            long started = SystemClock.uptimeMillis();
            while (true) {
                PendingPost pendingPost = queue.poll();
                if (pendingPost == null) {
                    synchronized (this) {
                        // Check again, this time in synchronized
                        pendingPost = queue.poll();
                        if (pendingPost == null) {
                            handlerActive = false;
                            return;
                        }
                    }
                }
                eventBus.invokeSubscriber(pendingPost);
                long timeInMethod = SystemClock.uptimeMillis() - started;
                if (timeInMethod &gt;= maxMillisInsideHandleMessage) {
                    if (!sendMessage(obtainMessage())) {
                        throw new EventBusException(&quot;Could not send handler message&quot;);
                    }
                    rescheduled = true;
                    return;
                }
            }
        } finally {
            handlerActive = rescheduled;
        }
    }
  }
</code></pre>
<p>  handler内部的handleMessage是一个死循环,每次通过enqueue方法来吧回调事件放入队列中,第一次的情况下发现handlerActive为否,说明没有启动,通过放一个空的message给handleMessage方法来启动死循环,如果已经启动了,handleMessage内部在不断的poll队列中的事件,依次执行回调方法,直到里面没有事件为止.同时在最底下还有个时间差判断,如果执行了十秒还没有执行完成的话,断开循环抛出异常,算是一个复位操作(个人理解)</p>
<p>  再看ThreadMode的backGround模式,如果在主线程中,那么就交给backgroundPoster处理,如果在子线程中就直接处理了.来看backgroundPoster的逻辑</p>
<pre><code class="java">  final class BackgroundPoster implements Runnable {

    private final PendingPostQueue queue;
    private final EventBus eventBus;

    private volatile boolean executorRunning;

    BackgroundPoster(EventBus eventBus) {
        this.eventBus = eventBus;
        queue = new PendingPostQueue();
    }

    public void enqueue(Subscription subscription, Object event) {
        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
        synchronized (this) {
            queue.enqueue(pendingPost);
            if (!executorRunning) {
                executorRunning = true;
                eventBus.getExecutorService().execute(this);
            }
        }
    }

    @Override
    public void run() {
        try {
            try {
                while (true) {
                    PendingPost pendingPost = queue.poll(1000);
                    if (pendingPost == null) {
                        synchronized (this) {
                            // Check again, this time in synchronized
                            pendingPost = queue.poll();
                            if (pendingPost == null) {
                                executorRunning = false;
                                return;
                            }
                        }
                    }
                    eventBus.invokeSubscriber(pendingPost);
                }
            } catch (InterruptedException e) {
                Log.w(&quot;Event&quot;, Thread.currentThread().getName() + &quot; was interruppted&quot;, e);
            }
        } finally {
            executorRunning = false;
        }
    }

  }
</code></pre>
<p>  <em>BackgroundPoster</em> 就是一个简单的线程,当触发之后把自己交给EventBus的线程词来调用,自己的run方法内部维护一个死循环,不断从队列里面poll事件,直到没有为止,和上面的mainThreadPoster的做法类似.</p>
<p>  最后是ThreadMode的ASYNC模式,直接交给 <em>asyncPoster</em> 来处理了,可以猜想应该也是一个线程只不过是每次触发都是一个新的线程,放入线程池中.</p>
<pre><code class="java">  class AsyncPoster implements Runnable {

    private final PendingPostQueue queue;
    private final EventBus eventBus;

    AsyncPoster(EventBus eventBus) {
        this.eventBus = eventBus;
        queue = new PendingPostQueue();
    }

    public void enqueue(Subscription subscription, Object event) {
        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
        queue.enqueue(pendingPost);
        eventBus.getExecutorService().execute(this);
    }

    @Override
    public void run() {
        PendingPost pendingPost = queue.poll();
        if(pendingPost == null) {
            throw new IllegalStateException(&quot;No pending post available&quot;);
        }
        eventBus.invokeSubscriber(pendingPost);
    }

  }
</code></pre>
<p>  代码非常简单,每次 <em>enqueue</em> 把自己交给线程池去调用.</p>
<p>  最后就是注销绑定事件的unregister方法,也很简单,通过map的对应关系,把所有相关的事件移除就可以了</p>
<pre><code class="java">  /** Unregisters the given subscriber from all event classes. */
   public synchronized void unregister(Object subscriber) {
       List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);
       if (subscribedTypes != null) {
           for (Class&lt;?&gt; eventType : subscribedTypes) {
               unsubscribeByEventType(subscriber, eventType);
           }
           typesBySubscriber.remove(subscriber);
       } else {
           Log.w(TAG, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());
       }
   }
</code></pre>
<p>  还剩余sticky事件的处理,下面重点讲一下<br>  sticky事件讲的是当前事件在post的时候还没有相应的绑定事件,当register相应的event的时候就会触发,那么可以想象在register的时候肯定回去存放sticky时间短额地方去查找有没有对应的事件,然后post一下去回调响应.</p>
<p>  首先看postSticky方法:</p>
<pre><code class="java">  /**
     * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky
     * event of an event&#39;s type is kept in memory for future access by subscribers using {@link Subscribe#sticky()}.
     */
    public void postSticky(Object event) {
        synchronized (stickyEvents) {
            stickyEvents.put(event.getClass(), event);
        }
        // Should be posted after it is putted, in case the subscriber wants to remove immediately
        post(event);
    }
</code></pre>
<p>  先放入 <em>stickEvents</em> 容器,尝试post一下<br>  然后在register的subscribe方法中,遍历stickEvents容器,如果找到了对应的event就post一下.</p>
<pre><code class="java">  // Must be called in synchronized block
   private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {

      ...

       if (subscriberMethod.sticky) {
           if (eventInheritance) {
               // Existing sticky events of all subclasses of eventType have to be considered.
               // Note: Iterating over all events may be inefficient with lots of sticky events,
               // thus data structure should be changed to allow a more efficient lookup
               // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).
               Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();
               for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {
                   Class&lt;?&gt; candidateEventType = entry.getKey();
                   if (eventType.isAssignableFrom(candidateEventType)) {
                       Object stickyEvent = entry.getValue();
                       checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                   }
               }
           } else {
               Object stickyEvent = stickyEvents.get(eventType);
               checkPostStickyEventToSubscription(newSubscription, stickyEvent);
           }
       }
   }
</code></pre>
<p>  然后看checkPostStickyEventToSubscription方法</p>
<pre><code class="java">  private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
      if (stickyEvent != null) {
          // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
          // --&gt; Strange corner case, which we don&#39;t take care of here.
          postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
      }
  }
</code></pre>
<p>  如果找到了对应的sticky事件就post到回调方法,非常清晰.</p>
<h3 id="内部集合PendingPostQueue分析"><a href="#内部集合PendingPostQueue分析" class="headerlink" title="内部集合PendingPostQueue分析"></a>内部集合PendingPostQueue分析</h3><p>  这里 <em>PendingPostQueue</em> 是一个双端链表的简单实现,链表的好处在于插入和删除的效率要比数组更高,遍历是慢于数组的,这里运用场景就是不断的从里面取最后一个event事件,那么用链表是非常合适的.</p>
<p>  ##总结<br>  EventBus这个库,通过读源码学到了很多东西,其内部构成就是一个简单观察者模式的实现,但是需要明白java的反射原理,多线程处理,以及各种线程同步的知识,受益匪浅.<br>  内部代码量也不是很多,核心代码仅仅不到千行却实现了这么小巧方便的代码库,非常高端.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/11/28/2016/android instant run原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/28/2016/android instant run原理/" itemprop="url">android Instant Run原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-28T20:10:00+08:00">
                2016-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  起因：在android6.0的手机上，app第一次安装的时候启动特别的慢，会黑屏很长时间，开始是以为在application中干的事情太多了，可能还有写耗时的操作影响了启动时长，在最底层的application的onCreate方法加了一句log，然后重新安装，发现log居然很久之后才打印出来，那么排除了是application里面的操作影响，后来上网搜索了一下，说是Instant Run造成的，故特意查找了些资料，研究了其内部原理</p>
<h3 id="Instant-Run-官方说明"><a href="#Instant-Run-官方说明" class="headerlink" title="Instant Run 官方说明"></a>Instant Run 官方说明</h3><blockquote>
<p> 使用Instant Run，您无需构建新的apk，就可以将更改<em>推送</em>至方法，将现有应用资源<em>推送</em>至正在运行的应用，所以几乎立刻就能看到代码的更改。</p>
</blockquote>
<p>这里说明了instant的两个特性，一个是不用生成新的apk几乎立刻就可以看到代码的更改，另一个说是<em>推送</em>至设备。后面会详细说明。</p>
<h3 id="传统的代码修改及编译部署流程"><a href="#传统的代码修改及编译部署流程" class="headerlink" title="传统的代码修改及编译部署流程"></a>传统的代码修改及编译部署流程</h3><p><img src="/images/2016/11/1.png" alt="andorid 部署流程"></p>
<p>构建整个apk-&gt;部署app-&gt;app重启-&gt;重启activity<br>而Instant Run会用更少的时间</p>
<h3 id="Instant-Run编译与部署流程"><a href="#Instant-Run编译与部署流程" class="headerlink" title="Instant Run编译与部署流程"></a>Instant Run编译与部署流程</h3><p><img src="images/2016/11/2.png" alt="Instant Run部署流程"><br>只构建修改的部分-&gt;部署修改的dev或资源-&gt;热部署，温部署，冷部署</p>
<table>
<thead>
<tr>
<th>代码更改</th>
<th>Instant Run行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>更改现有方法的代码实现</td>
<td>通过热交换支持：这是最快的交换类型，使更改能够更快的显示。您的应用保持运行，下次调用存根方法时会使用具有新实现的存根方法</td>
</tr>
<tr>
<td>更改或移除现有资源</td>
<td>通过温交换支持：这种交换速度也非常快，但Instant Run在将更改的资源推送至您的应用时必须重新启动当前的行为。您的应用保持运行，只是会出现小的提示，这是正常情况</td>
</tr>
<tr>
<td>结构行代码更改，例如：添加移除或更改 注释，实例字段，静态字段，静态方法签名，实例方法签名，更改当前类从其继承的父类，更改实现的界面列表，更改类的静态初始值设定项，对使用动态资源ID的布局元素重新排序</td>
<td>通过冷交换支持，这种交换速度有点慢，因为尽管不需要新的apk，Instant Run在推送结构性代码更改的时候必须重启整个应用</td>
</tr>
<tr>
<td>更改应用manifast，更改应用引用的资源，更改andorid的widget</td>
<td>android studio会重新部署，生成新的apk，这是因为manifast等文件是安装在设备中的，无法通过更新的方式修改</td>
</tr>
</tbody>
</table>
<h3 id="Instant-Run原理"><a href="#Instant-Run原理" class="headerlink" title="Instant Run原理"></a>Instant Run原理</h3><p>  我们知道app的入口在application中，在manifast中的applcationID就是app的唯一标示，也是程序的入口，如果反编译通过运行Instant Run生成的apk会发现里面的构成是这样的</p>
<p><img src="images/2016/11/3.PNG" alt="  Instant Run apk构成"></p>
<p>着重看里面的两个dex和instant-run.zip文件。首先看一下两个dex的源码：<br><img src="images/2016/11/5.PNG" alt=""></p>
<p>可以看到里面就是简单的app的信息，包括application的class和包名<br>再看第二个dex</p>
<p><img src="/images/2016/11/6.PNG" alt=""></p>
<p>里面是一堆class文件，不过没有一个是我们的自己的，那可以猜出来我们自己的代码放在了instant-run.zip文件中，解压之后如下图</p>
<p><img src="/images/2016/11/7.PNG" alt=""></p>
<p>真正的代码在这里了。</p>
<p>同时反编译解码manifast之后，会发现我们的applcationId被替换成instant run的application BootstrapApplication，那么我们可以猜出instant-run代码作为一个宿主程序，将app作为资源加载起来，和插件话一个思路，那么instant run是怎么把代码运行起来的呢？</p>
<h3 id="对原始代码的处理"><a href="#对原始代码的处理" class="headerlink" title="对原始代码的处理"></a>对原始代码的处理</h3><p>  在第一次构建apk的时候，在每一个类中通过asm修改class文件注入一个$change成员变量，同时在每个方法的顶部增加如下代码</p>
<pre><code class="java">  IncrementalChange localIncrementalChange = $change;
        if (localIncrementalChange != null) {
            localIncrementalChange.access$dispatch(
                    &quot;onCreate.(Landroid/os/Bundle;)V&quot;, new Object[] { this,
                            ... });
            return;
    }
</code></pre>
<p>  每个方法的都有哦，可以理解如果发生变化，那么原始方法就会调用$change中对应的方法，来达到替换方法的目的<br>  后续运行的时候，dx补丁类，生成补丁dex，其中被修改类的补丁类是在类原名后面增加$override复制修改类的大部分代码，然后把原始类的$change赋值，这样就可以在调用原始类方法的时候调用补丁类中的对应方法了。</p>
<h3 id="application的启动"><a href="#application的启动" class="headerlink" title="application的启动"></a>application的启动</h3><p>  首先程序的入口是BootstrapApplication，通过它来加载classLoader，而classLoader负责加载dex文件，那么如何才能把我们补丁的dex加载到程序中呢？<br>  Instant run是通过在程序classLoader的树状结构中插入补丁dex来解决问题，如下图</p>
<p><img src="images/2016/11/classloader.png" alt="  "><br>这里有个概念叫双亲委派模式，是一个典型的应用场景，首先是子类如果要加载dex的时候会通过父类去查找，如果父类没有找到，就会去父类的父类去查找，如果一直没有找到就会在子类中加载，并缓存之，instant run就是给pathClassLoader中插入了一个中间父类loader叫IncrementalClassLoader,这样就解决了类加载的问题。</p>
<p>在BootstrapApplication中先初始化各种loader然后通过反射调用源程序的applcation方法，同时修改<br>1.替换ActivityThread的mInitialApplication为realApplication  </p>
<p>2.替换mAllApplications 中所有的Application为realApplication  </p>
<p>3.替换ActivityThread的mPackages,mResourcePackages中的mLoaderApk中的application为realApplication。  </p>
<p>这样就解决了类加载的问题。热插件的原理也是通过这个来实现</p>
<h3 id="如何修改资源"><a href="#如何修改资源" class="headerlink" title="如何修改资源"></a>如何修改资源</h3><p>如果resource.ap_文件有改变，那么新建一个AssetManager对象newAssetManager，然后用newAssetManager对象替换所有当前Resource、Resource.Theme的mAssets成员变量。 2.如果当前的已经有Activity启动了，还需要替换所有Activity中mAssets成员变量</p>
<h3 id="如何把更新载入程序"><a href="#如何把更新载入程序" class="headerlink" title="如何把更新载入程序"></a>如何把更新载入程序</h3><p>instant run会额外加载一个server，server在不断的监听来发现有补丁更新，通过socket传递给app，然后server来完成热更新，冷更新和温更新，最后重启</p>
<p>1.如果后缀为“.dex”,冷部署处理handleColdSwapPatch<br>2.如果后缀为“classes.dex.3”,热部署处理handleHotSwapPatch<br>3.其他情况,温部署，处理资源handleResourcePatch  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/11/16/2016/java和android中遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/16/2016/java和android中遇到的问题/" itemprop="url">java和android中遇到的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-16T14:32:00+08:00">
                2016-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java获取当前的方法名和类名"><a href="#java获取当前的方法名和类名" class="headerlink" title="java获取当前的方法名和类名"></a>java获取当前的方法名和类名</h2><p>原来真的可以，以前太想当然了，居然光是想着得整体反射才能获取到，没想到在方法内部就可以，遇到问题不能凭感觉，要求证之后再下结论，永远保持怀疑的态度</p>
<pre><code class="java">Thread.currentThread().getStackTrace()[1].getClassName();
Thread.currentThread().getStackTrace()[1].getMethodName();
</code></pre>
<h2 id="gson-parse转换带有非法字符的字符串时报错"><a href="#gson-parse转换带有非法字符的字符串时报错" class="headerlink" title="gson parse转换带有非法字符的字符串时报错"></a>gson parse转换带有非法字符的字符串时报错</h2><p>   今天遇到一个问题，服务器返回的HashKey中是通过base64生成的字符串，里面有个“=”，这个时候通过gson parse的时候就会报MalformedJsonException异常<br>   ，后来通过gson的toJson方法来解决，也就是用gson再转一次，这样就会把里面的“=”转化为16进制的字符串了。</p>
<pre><code class="java">public static String toJson(Map&lt;String, String&gt; paramMap) {
        //所有的参数最终都要拼接成一个JsonObject对象，然后通过一个叫param的参数发送到服务器
        JsonObject jsonObject = new JsonObject();
        if (paramMap != null &amp;&amp; !paramMap.isEmpty()) {
            for (String key : paramMap.keySet()) {
                String value = paramMap.get(key);
                if (TextUtils.isEmpty(key) || TextUtils.isEmpty(value)) {
                    continue;
                }
                //通过jsonParser可以解决java的\“转义的问题
                //如果文本中带空格的，请使用整个对象转json的方式
                JsonParser parser = new JsonParser();
                try {
                    JsonElement jsonElement = parser.parse(value);
                    jsonObject.add(key, jsonElement);
                } catch (JsonSyntaxException e) {
                    e.printStackTrace();
                    //如果字符串不符合格式，gson会报MalformedJsonException异常，比如字符串中包含等号，&lt;,&gt;等特殊符号，不能直接转换
                    //目前在简报的服务器返回HashKey中发现有等号的清空下无法解析，故在这里增加了处理
                    try {
                        value = GsonUtils.ObjectToJson(value);
                        JsonElement jsonElement = parser.parse(value);
                        jsonObject.add(key, jsonElement);
                    } catch (JsonSyntaxException e1) {
                        e1.printStackTrace();
                        //如果再次转换还是失败的话，使用JsonReader的宽容模式
                        try {
                            JsonReader jsonReader = new JsonReader(new StringReader(value));
                            jsonReader.setLenient(true);
                            JsonElement jsonElement = parser.parse(jsonReader);
                            jsonObject.add(key, jsonElement);
                        } catch (Exception e2) {
                            e2.printStackTrace();
                            NetLogger.log(&quot;HttpUtil toJson meet error param ,the param is &quot; + value + &quot;,please check the value is correct!!!&quot;);
                        }
                    }
                }

            }
        }
        NetLogger.log(&quot;toJson =&quot; + jsonObject.toString());
        return jsonObject.toString();
      }
</code></pre>
<h2 id="关于java中BigInteger的原理分析"><a href="#关于java中BigInteger的原理分析" class="headerlink" title="关于java中BigInteger的原理分析"></a>关于java中BigInteger的原理分析</h2><p>  通过内部的数组来分段存放数字集合，最后再拼成一个整体返回<br>  <a href="http://www.hollischuang.com/archives/176" title="BigInteger原理" target="_blank" rel="external">BigInteger原理</a></p>
<h2 id="为什么在android的api中有些方法明明是public的-但是在外部调用的时候就是编译错误-显示为不可以使用的状态"><a href="#为什么在android的api中有些方法明明是public的-但是在外部调用的时候就是编译错误-显示为不可以使用的状态" class="headerlink" title="为什么在android的api中有些方法明明是public的,但是在外部调用的时候就是编译错误,显示为不可以使用的状态?"></a>为什么在android的api中有些方法明明是public的,但是在外部调用的时候就是编译错误,显示为不可以使用的状态?</h2><p>  原因是在方法或者field的注释中有一个 <em>@hide</em> 的注解,这个注解的作用就是告诉javaDoc,凡是带了这个注解的方法或者field都会把javaDoc忽略,也就是说对外是看不到这个方法.但是在内部是可以使用的.有点像android的internal包,只能手机本身调用,外部是无法直接调用的.这样做的目的是比如有些方法还不是很稳定,就先把它标记为对外暂时不可用,等后期稳定了之后再打开.</p>
<p>  不过通过java的发射是可以调用这些带有 <em>@hide</em> 的方法和filed的.</p>
<p><a href="http://stackoverflow.com/questions/17035271/what-does-hide-mean-in-the-android-source-code" title="What does @hide mean in the Android source code?" target="_blank" rel="external">What does @hide mean in the Android source code?</a></p>
<h2 id="EventBus在子线程中post事件遇到的问题"><a href="#EventBus在子线程中post事件遇到的问题" class="headerlink" title="EventBus在子线程中post事件遇到的问题"></a>EventBus在子线程中post事件遇到的问题</h2><p>  之前遇到一个问题,就是EventBus在post事件的时候如果是在子线程中,同时回到事件更新UI了,就会导致网络请求的数据没有了,不知道为什么.今天看了源码明白了其中的缘由.<br>  源码,在EventBus中,当你没有指定事件回调的ThreadMode的话,回调事件就会在post所在线程中执行了,那如果你在子线程中post事件,在主线程中的回调事件没有修改ThreadMode话回调事件就会在子线程中运行,这个时候如果更新UI,就会报异常,但是由于EventBus把异常给catch到了,所以页面没有什么异常反应.看着就好像没啥变化一样.<br>  然后再说为啥请求就没有数据了呢,是因为有个同事把post事件放在网络请求的回调来发送的,但是网络请求的回调默认不是在主线程中处理的,所以就会导致post的事件是在子线程中发送的,然后就会报异常就是不能在子线程中更新UI.这个时候,activity的UI是就不会响应UI更新了.</p>
<h2 id="android的子线程中真的不能更新UI吗"><a href="#android的子线程中真的不能更新UI吗" class="headerlink" title="android的子线程中真的不能更新UI吗?"></a>android的子线程中真的不能更新UI吗?</h2><p>  如果在Activity的onCreate方法中直接new子线程然后在里面更新UI是不会报错的.原因是检查线程是否是子线程的方法在onCreate的时候还没有调用呢.<br><a href="http://www.cnblogs.com/xuyinhuan/p/5930287.html" title="Android中子线程真的不能更新UI吗？" target="_blank" rel="external">  Android中子线程真的不能更新UI吗？</a></p>
<h2 id="在生成android-AIDL的过程中老是提示失败"><a href="#在生成android-AIDL的过程中老是提示失败" class="headerlink" title="在生成android AIDL的过程中老是提示失败"></a>在生成android AIDL的过程中老是提示失败</h2><p>  通过网上的教程尝试通过AIDL传递复杂对象,比如一个序列化对象Book,然后把Book.java,Book.aidl,TestAidlInterface.aidl 这三个文件放在同一个包中,老是无法通过编译,没有生成响应的java文件.后来鼓捣了半天,发现把 Book.java 文件放在其他的java目录中就可以了.也就是说aidl文件放在专用的aidl包中,java类放在普通的java包中.猜测可能是新版的android studio做了调整.</p>
<h2 id="在android-5-0及以上的版本中直接通过intent调用startService-bindService-stopService等方法的时候报错-java-lang-IllegalArgumentException-Service-Intent-must-be-explicit-Intent-act-XXXXXXXX-flg-0x10000000"><a href="#在android-5-0及以上的版本中直接通过intent调用startService-bindService-stopService等方法的时候报错-java-lang-IllegalArgumentException-Service-Intent-must-be-explicit-Intent-act-XXXXXXXX-flg-0x10000000" class="headerlink" title="在android 5.0及以上的版本中直接通过intent调用startService,bindService,stopService等方法的时候报错 java.lang.IllegalArgumentException: Service Intent must be explicit: Intent { act=XXXXXXXX flg=0x10000000 }"></a>在android 5.0及以上的版本中直接通过intent调用startService,bindService,stopService等方法的时候报错 <em>java.lang.IllegalArgumentException: Service Intent must be explicit: Intent { act=XXXXXXXX flg=0x10000000 }</em></h2><p>  这是因为在5.0的android源码中增加了对intent的package的限制.下面来看bindService的直接调用方 <em>ContextImpl</em> 中的 <em>bindService</em> 方法:</p>
<pre><code class="java">  @Override
   public boolean bindService(Intent service, ServiceConnection conn,
           int flags) {
       warnIfCallingFromSystemProcess();
       return bindServiceCommon(service, conn, flags, mMainThread.getHandler(),
               Process.myUserHandle());
   }
</code></pre>
<pre><code class="java">  private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler
             handler, UserHandle user) {
         IServiceConnection sd;
         if (conn == null) {
             throw new IllegalArgumentException(&quot;connection is null&quot;);
         }
         if (mPackageInfo != null) {
             sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);
         } else {
             throw new RuntimeException(&quot;Not supported in system context&quot;);
         }
         validateServiceIntent(service);
         try {
             IBinder token = getActivityToken();
             if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null
                     &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion
                     &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                 flags |= BIND_WAIVE_PRIORITY;
             }
             service.prepareToLeaveProcess(this);
             int res = ActivityManagerNative.getDefault().bindService(
                 mMainThread.getApplicationThread(), getActivityToken(), service,
                 service.resolveTypeIfNeeded(getContentResolver()),
                 sd, flags, getOpPackageName(), user.getIdentifier());
             if (res &lt; 0) {
                 throw new SecurityException(
                         &quot;Not allowed to bind to service &quot; + service);
             }
             return res != 0;
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
</code></pre>
<p>  注意上面方法中的 <em>validateServiceIntent</em> 方法,这个就是上面报错的原因所在了.</p>
<pre><code class="java">  private void validateServiceIntent(Intent service) {
       if (service.getComponent() == null &amp;&amp; service.getPackage() == null) {
           if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) {
               IllegalArgumentException ex = new IllegalArgumentException(
                       &quot;Service Intent must be explicit: &quot; + service);
               throw ex;
           } else {
               Log.w(TAG, &quot;Implicit intents with startService are not safe: &quot; + service
                       + &quot; &quot; + Debug.getCallers(2, 3));
           }
       }
   }
</code></pre>
<p>  可以看到,这里对intent内部的package属性做了判断,如果大于APIlevel21并且package为空的话就会抛出上面提到的异常.<br>  解决方法很简单,在intent初始化的时候设置一下package就可以了.</p>
<pre><code class="java">  Intent intent = new Intent(action);
  intent.setPackage(getPackageName());
  bindService(intent);
</code></pre>
<blockquote>
<p>注意:如果在使用AIDL时,这里传入的package应该是服务端对应的包名,也就是你想让谁来处理这个intent,这里的package就传谁的.<br>注意:这里getPackageName这个方法返回的是application的包名,也就是apk的包名,不要和java反射的获取包名方法混淆了,java的获取包名是通过class.getPackage().getName() 来获取的.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/11/09/2016/git 技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/09/2016/git 技巧/" itemprop="url">git 技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-09T14:08:00+08:00">
                2016-11-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="如何把已经加入暂存区的文件移除"><a href="#如何把已经加入暂存区的文件移除" class="headerlink" title="如何把已经加入暂存区的文件移除"></a>如何把已经加入暂存区的文件移除</h2><p>git reset <file name=""><br>如果要移除暂存区全部文件使用<br>git reset</file></p>
<h2 id="如何把其它分支的提交合并到当前分支"><a href="#如何把其它分支的提交合并到当前分支" class="headerlink" title="如何把其它分支的提交合并到当前分支"></a>如何把其它分支的提交合并到当前分支</h2><p>git cherry_pick commitId 就可以了，然后push到远程分支</p>
<h3 id="基于某个tag来创建分支"><a href="#基于某个tag来创建分支" class="headerlink" title="基于某个tag来创建分支"></a>基于某个tag来创建分支</h3><p>git checkout -b 分支名称 tag名称 就可以了</p>
<h3 id="如何删除一个本地仓库"><a href="#如何删除一个本地仓库" class="headerlink" title="如何删除一个本地仓库"></a>如何删除一个本地仓库</h3><p>直接把文件目录下的 <em>.git</em> 文件夹删除就可以了。</p>
<blockquote>
<p>rm -rf .git</p>
</blockquote>
<h3 id="如何把一个已经添加到代码库中的文件加入到ignore中"><a href="#如何把一个已经添加到代码库中的文件加入到ignore中" class="headerlink" title="如何把一个已经添加到代码库中的文件加入到ignore中"></a>如何把一个已经添加到代码库中的文件加入到ignore中</h3><p>通过下面到命令从版本库中把指定的文件删除</p>
<blockquote>
<p>git rm –cached 文件名</p>
</blockquote>
<p>然后把该文件加入到 <em>.gitignore</em> 中，提交后就可以生效了,如果是文件夹的话在rm 后面加上 <strong>-f</strong> 就可以了</p>
<h3 id="如何修改本地分支所追踪的远程分支"><a href="#如何修改本地分支所追踪的远程分支" class="headerlink" title="如何修改本地分支所追踪的远程分支"></a>如何修改本地分支所追踪的远程分支</h3><p>假如现在你本地的一个分支追踪（track）是远程master分支，你想让它改为追踪远程develop分支</p>
<blockquote>
<p>git branch –set–upstream-to=origin/[远程分支名称] [本地分支名称]</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/11/05/2016/Programming Principles 翻译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/05/2016/Programming Principles 翻译/" itemprop="url">Programming Principles 翻译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-05T18:11:00+08:00">
                2016-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h2><h3 id="通用的"><a href="#通用的" class="headerlink" title="通用的"></a>通用的</h3><h4 id="KISS-keep-It-Simple-Stupid"><a href="#KISS-keep-It-Simple-Stupid" class="headerlink" title="KISS(keep It Simple Stupid)"></a>KISS(keep It Simple Stupid)</h4><p>大部分保持简单的系统要比复杂的系统运行的更好</p>
<p>为什么呢？</p>
<ul>
<li>更少的代码消耗更少的时间，有更少的bug，并且更容易修改</li>
<li>大道至简（Simplicity is the ultimate sophistication）</li>
<li>最完美的不是没有什么可以增加的，而是没有什么是可以删减的，也就是最终的精简</li>
</ul>
<h4 id="YAGNI"><a href="#YAGNI" class="headerlink" title="YAGNI"></a>YAGNI</h4><p>YAGNI是“你不会需要他的：不要实现它除非你确实需要它”</p>
<p>为什么呢？</p>
<ul>
<li>任何在未来才可能用到的功能，意味着会浪费当前迭代的精力</li>
<li>它会导致代码臃肿（bloat），使软件更加的庞杂</li>
</ul>
<p>如何做？</p>
<ul>
<li>永远去实现你确实需要的事物，永远不要去实现你只是预见到未来才能用到的事物</li>
</ul>
<h4 id="仅仅做可以运行的最简单的事物"><a href="#仅仅做可以运行的最简单的事物" class="headerlink" title="仅仅做可以运行的最简单的事物"></a>仅仅做可以运行的最简单的事物</h4><p>为什么呢？<br>如果我们作用于问题的真正所在，就可以最大化的解决问题</p>
<p>如何做呢？<br>问问你自己“什么才是可以使它起作用的最简单的方式”</p>
<h4 id="关注隔离"><a href="#关注隔离" class="headerlink" title="关注隔离"></a>关注隔离</h4><p>关注隔离是一种把程序分离成清晰的层次的设计原则，致使每一层关注不同的位置。比如业务逻辑是一种关注方向，而UI又是另一个方向的关注<br>调整UI不应该影响业务逻辑，同理反之。</p>
<p>‘’’<br>引用自  Edsger W. Dijkstra（1974）：<br>  我所说的“关注隔离”是唯一的一种可以使思维想法有序的技术，虽然不一定完美，这是一种“使你聚焦于某些方面”：这并不是说忽略其它的方面，而只是说在正确的关注点上<br>  工作，其它方面都是不可见的。<br>‘’’<br>为什么呢？</p>
<ul>
<li>更容易的开发和维护系统应用</li>
<li>如果分层合理，那么每一个独立的层都可以被复用，开发和升级</li>
</ul>
<p>如何做？</p>
<ul>
<li>尽可能的分解系统为不同的独立模块</li>
</ul>
<h4 id="保证事物DRY（dont-repeat-yourself）"><a href="#保证事物DRY（dont-repeat-yourself）" class="headerlink" title="保证事物DRY（dont repeat yourself）"></a>保证事物DRY（dont repeat yourself）</h4><p>在程序中每一个元素都必须保证唯一性，无歧义，独一代表性</p>
<p>每个定义在源代码中应该只有一份实现。如果同样的功能实现出现在不同的地方，最好是把他们合并成一个公共的的抽象</p>
<p>为什么呢？</p>
<ul>
<li>重复（不管是有意无意）都会导致维护困难，未知的因素和逻辑混乱</li>
<li>单一元素的调整不应该引起不想关逻辑调整</li>
<li>通常逻辑相关的改动应该是可预测和均匀的，并且保持同步</li>
</ul>
<p>如何做？</p>
<ul>
<li>把业务逻辑，表达式，if表达式，数学运算等应该只出现在一个地方</li>
<li>在程序中找出某一功能点的单一明确的定义,然后通过该定义来生成可以用的实例</li>
<li>rule of three</li>
</ul>
<h4 id="为修改人员编写代码"><a href="#为修改人员编写代码" class="headerlink" title="为修改人员编写代码"></a>为修改人员编写代码</h4><p>为什么呢?</p>
<ul>
<li>对任何工程而言维护都是需要花费很多代价的</li>
</ul>
<p>如何做?</p>
<ul>
<li>做一个维护者</li>
<li>在编写代码的时候想想修改你代码的是一个有严重暴力倾向的精神病患者,并且他还知道你住在哪里</li>
<li>在编写代码和提交的时候想想菜鸟会非常乐意从你的代码中学习</li>
<li>不要使我思考</li>
<li>使用最小惊讶原则</li>
</ul>
<h4 id="避免过早优化"><a href="#避免过早优化" class="headerlink" title="避免过早优化"></a>避免过早优化</h4><p>摘自 Donald Knuth:</p>
<blockquote>
<p>程序员浪费大量的精力在思考或者担心程序中非紧急模块的效率,并且被认为包含消极冲突<br>我们应该忘记小小的效率提升,大约百分之97的概率:过早优化是万恶之源</p>
</blockquote>
<p>明白什么是”过早”,和不是”过早”是问题的核心</p>
<p>为什么呢?</p>
<ul>
<li>你预先不知道到底问题的瓶颈在哪里</li>
<li>优化过后,代码变得难以阅读和修改<br>如何做?</li>
<li>是它工作快而正确</li>
<li>不要优化知道你确实并且知道瓶颈所在</li>
</ul>
<h4 id="最小化耦合"><a href="#最小化耦合" class="headerlink" title="最小化耦合"></a>最小化耦合</h4><p>耦合是指功能和模块之间等层级相互依赖;低耦合是好的,换句话说,耦合是指单元B有可能会停止是由在单元A中有未知的改动而造成的.</p>
<p>为什么呢?</p>
<ul>
<li>对一个模块的某处修改一般会引起其他的模块的连锁反应</li>
<li>组装模块需要更多的精力和时间由于内部模块之间的依赖</li>
<li>模块会变得特别难以复用和测试由于依赖模块也必须被引入</li>
<li>开发人员可能会很恐惧修改代码因为他们也不确定会引起其他问题</li>
</ul>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>不要和陌生人说话</p>
<p>为什么呢?</p>
<ul>
<li>这样经常会导致紧密的耦合</li>
<li>这样会暴露更多的实现细节</li>
</ul>
<p>如何做?<br>对象中的方法只应该调用的方法有:</p>
<ul>
<li>对象本身</li>
<li>方法中的参数</li>
<li>方法中创建的对象</li>
<li>对象中的成员变量和属性</li>
</ul>
<h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>为什么呢?</p>
<ul>
<li>类之间的耦合更少</li>
<li>使用继承,子类容易造成猜测,违背里氏替换原则</li>
</ul>
<p>如何做?</p>
<ul>
<li>测试能否符合里氏替换来决定使用继承</li>
<li>当二者关系是 “has a “ 或 “use a” 时使用组合,当二者关系是 “is a” 时使用继承</li>
</ul>
<h3 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h3><p>正交性的核心思想是两个无关的概念不应该在系统中相互关联</p>
<h3 id="健壮性原则"><a href="#健壮性原则" class="headerlink" title="健壮性原则"></a>健壮性原则</h3><p>对你所做的持有保守态度,对接受到别人的东西保持宽容态度.<br>合作服务以来与相互之间的接口,通常情况下接口会以进化到不确定的数据为结尾.一个幼稚的实现一般是拒绝合作如果收到一个不太严格的数据格式.而老练的接口通常情况下会忽略它无法识别的数据继续执行.</p>
<p>为什么呢?</p>
<ul>
<li>为了可以升级服务你需要确认提供者可以做出调整来支持各种需求特别是在对现有客户端引起最小调整的情况下.</li>
</ul>
<p>如何做呢?<br>发送给其他系统的代码应该转换为明确的格式,但是从别的地方接收到的数据应该代码应该同时也可以接受含义不太明确的数据</p>
<h3 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h3><p>模块的内聚指的是指他们的职责是一个有意义的集合.越高内聚越好.</p>
<p>如果不这样会怎么样?</p>
<ul>
<li>增加模块间的理解难度</li>
<li>增加修改难度,因为修改当前领域的逻辑会导致其他模块的变化.</li>
<li>影响组件模块的复用性</li>
</ul>
<p>如何做呢?<br>组件相关的功能应该共享一个单一职责</p>
<h3 id="LSP里氏替换原则"><a href="#LSP里氏替换原则" class="headerlink" title="LSP里氏替换原则"></a>LSP里氏替换原则</h3><p>LSP期望的对象行为是:<br>程序中的对象转换为子类对象之后是无需做任何调整的,也就是子类可以完美替换父类</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>软件中的实例应该对修改关闭,对扩展开放.当然在不修改源代码的基础上的修改是可以的</p>
<p>为什么呢?<br>通过对现有代码的最小改动来保证可维护性和稳定性</p>
<p>如何做呢?</p>
<ul>
<li>书写可以扩展的实体(相反的是可以被修改的类)</li>
<li>只是扩展需要调整的地方,其他的地方隐藏<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3>一个只应该有一个修改的原因</li>
</ul>
<p>为什么呢?<br>修改只应该对于必要的类或者类</p>
<p>如何做?<br>遵守 Curly’s Law.</p>
<h3 id="隐藏实现细节"><a href="#隐藏实现细节" class="headerlink" title="隐藏实现细节"></a>隐藏实现细节</h3><p>软件应该隐藏接口的实现细节,不要暴露不必要的实现细节</p>
<p>为什么呢?<br>当实现细节调整后,实现接口的客户端不应该做调整</p>
<p>如何做?</p>
<ul>
<li>最小化类和成员的可访问性</li>
<li>不要在公共的地方暴露数据</li>
<li>不要在一个类接口中提供私有的实现</li>
<li>减少耦合来隐藏更多的实现细节<h3 id="Curly’s-Law"><a href="#Curly’s-Law" class="headerlink" title="Curly’s Law"></a>Curly’s Law</h3>Curly’s Law是一个关于代码选择单一,清晰的目标:只做一件事</li>
</ul>
<h3 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h3><p>一个良好的设计定义是对变化的封装于API之后,当发生预期的变化时,修改只是局限于当前.<br>为什么呢?</p>
<ul>
<li>修改发生的时候保证最小的修改范围</li>
</ul>
<p>如何做?</p>
<ul>
<li>把各种概念封装与API之后</li>
<li>尽可能的把各个概念放入自己的所属模块中</li>
</ul>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>将臃肿的接口拆分成多个小的独立的接口.接口应该更多的依赖于调用它的代码而不是实现它的代码.<br>为什么呢?</p>
<ul>
<li>如果一个类实现了一个它不需要的接口,调用者需要知道这个实现方法是永远不会被调用的.<br>如何做呢?</li>
<li>避免臃肿接口,类不应该实现违背了单一职责原则的接口</li>
</ul>
<h3 id="童子军规则"><a href="#童子军规则" class="headerlink" title="童子军规则"></a>童子军规则</h3><p>在美国有一条童子军规适用于我们的职业:当你离开一个地方的时候,保证这个地方比你来的时候更干净.<br>为什么呢?</p>
<ul>
<li>当你对现存的代码做调整的时候,代码质量往往在下降,累计技术债务.遵守童子军军规可以使我们更加关注提交代码的质量,技术债务会被连续的重构减少,无论多么小.<br>如何做呢?</li>
<li>每次提交保证没有降低代码质量</li>
<li>每当发现一些不够清晰的代码的时候,应该抓住机会来把它整理的更加清晰</li>
</ul>
<h3 id="命令查询分离"><a href="#命令查询分离" class="headerlink" title="命令查询分离"></a>命令查询分离</h3><p>这条原则指的是每一个方法都应该作为一条命令去执行或查询并返回数据.问一个问题不应该修改答案<br>有了这个原则,程序员可以更有信心的编码.查询方法可以再任何地方以任何顺序使用,因为他们不会改变状态.使用命令,必须更加小心.<br>为什么呢?</p>
<ul>
<li>通过将方法清楚地分离成查询和命令,程序员可以在不知道每个方法的实现细节的情况下用额外的置信度进行编码</li>
</ul>
<p>如何做?</p>
<ul>
<li>把每一个方法当做一个查询或者命令</li>
<li>遵循命名定义,隐含的说明该方法是一个命令还是查询.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/10/17/2016/Object-C 细节/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/17/2016/Object-C 细节/" itemprop="url">Object-C 细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-17T14:24:00+08:00">
                2016-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul>
<li>NSMutableDictionary的allKey和allValue方法返回的都是不可变数组</li>
<li>可以通过NSMutableArray 的arrayToArray来转换数组为可变数组</li>
<li>可以通过NSString的stringByReplacingOccurrencesOfString方法来替换字符串</li>
</ul>
<h2 id="不通过系统自动创建xib的方式来新建xib的时候遇到的问题"><a href="#不通过系统自动创建xib的方式来新建xib的时候遇到的问题" class="headerlink" title="不通过系统自动创建xib的方式来新建xib的时候遇到的问题"></a>不通过系统自动创建xib的方式来新建xib的时候遇到的问题</h2><p>  当新建xib的时候，系统不会自动把controller和xib做关联，第一步就是把xib文件的class指定为对应的controller<br>  第二部就是把xib中的view和controller中的view关联，这样就不会报错了</p>
<p>  之前之所以报错，是应为xib中的view和controller的view没有绑定在一起导致的，而直接在创建controller的时候创建xib，系统会自动把两个view绑定在一起<br>  所以不会报错！<br>  <a href="http://stackoverflow.com/questions/4763519/loaded-nib-but-the-view-outlet-was-not-set-new-to-interfacebuilder" target="_blank" rel="external">http://stackoverflow.com/questions/4763519/loaded-nib-but-the-view-outlet-was-not-set-new-to-interfacebuilder</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/10/05/2016/linux相关知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/05/2016/linux相关知识/" itemprop="url">linux相关知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-05T14:45:00+08:00">
                2016-10-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="linux硬链接-Hard-link-和符号链接-Symbolic-link-的作用和创建方式"><a href="#linux硬链接-Hard-link-和符号链接-Symbolic-link-的作用和创建方式" class="headerlink" title="linux硬链接(Hard link)和符号链接(Symbolic link)的作用和创建方式"></a>linux硬链接(Hard link)和符号链接(Symbolic link)的作用和创建方式</h3><p>  在linux文件系统中,保存在磁盘分区中的文件不管是什么类型都给它分配了一个编号,称为索引节点(Inode index).硬链接指的就是多个文件名指向了同一个索引节点,硬链接的作用就是允许一个文件有多个指向的有效路径名称,这样用户就可以通过硬链接来指向重要文件,当删除了其中一个节点并不会影响文件本身和其他的连接,保证文件的安全,只有当所有的连接全部都删除后,文件才会被真正删除.类似于文件”指针”.符号链接又叫软链接,有点类似于windows的快捷方式,他实际上是一个特殊的文件,文件实际上是一个文本文件,其中包含另一个文件的位置信息.</p>
<p>  创建一个空文件f1     touch f1<br>  创建一个硬链接f2     ln f1 f2<br>  创建一个软链接f3     ln -s f1 f3<br>  查看文件属性         ls -li<br>  可以看到f1,f2文件的索引节点相同,文件大小相同,而f1,f3文件索引和文件大小都不相同</p>
<p>  输入文本到f1         echo “I am f1 file” &gt;&gt; f1<br>  输出f1,f2,f3文本    cat f1<br>                     “I am f1 file”<br>                     cat f2<br>                     “I am f1 file”<br>                     cat f3<br>                     “I am f1 file”<br>  删除f1              rm f1<br>  输出f2,f3文本       cat f2<br>                     “I am f1 file”<br>                     cat f3<br>                     No such file or directory</p>
<h3 id="basename-和-dirname"><a href="#basename-和-dirname" class="headerlink" title="basename 和 dirname"></a>basename 和 dirname</h3><p>basename 命令可以获取到路径最后的文件名<br>dirname 命令可以获取到路径除了文件名的前面部分</p>
<p>比如:<br>basename /user/yy —&gt; yy<br>dirname /user/yy —&gt; /user                     </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/06/15/2016/java design pattern/java design pattern - command pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/15/2016/java design pattern/java design pattern - command pattern/" itemprop="url">java design pattern - command pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-15T21:13:00+08:00">
                2016-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#命令模式">命令模式</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中，经常会遇到对一系列操作的封装，比如筛选的时候各种条件的处理，可以把每一种查询条件封装成统一的<br>  命令对象，最后装入一个集合中，完成筛选操作，这个显著的场景就可以使用命令模式来完成。各个操作彼此独立，而且<br>  遵循统一的接口，便于遍历和统一处理。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>  命令模式是一种结构模式，旨在对一系列操作做封装，统一调用。<br>  命令模式由4个角色组成：</p>
<ul>
<li>command 命令接口</li>
<li>concreteCommand 具体的命令，内部通过行为方法调用了receiver</li>
<li>receiver 具体的业务逻辑对象</li>
<li>invoker command的调用者</li>
</ul>
<p><img src="/images/2016/06/command_pattern_uml.gif" alt="command pattern"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/06/15/2016/java design pattern/java design pattern - command pattern/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/06/14/2016/java design pattern/java design pattern - strategy pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/14/2016/java design pattern/java design pattern - strategy pattern/" itemprop="url">java design pattern - strategy pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-14T21:37:00+08:00">
                2016-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#策略模式">策略模式</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  编程中经常会遇到为达到目的有多种策略或者实现方式，这个时候可以使用策略模式来完成。<br>  比如商店打折有多种策略，又比如要实现一种目标可以有多种方法，这些都可以使用策略模式</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>  策略模式是一种非常简单行为模式，旨在提供多种不同实现来满足程序要求，主要由3个角色组成：</p>
<ul>
<li>strategy 行为接口</li>
<li>ConcreteStrategy 不同实现策略</li>
<li>Context  上下文引用</li>
</ul>
<p><img src="/images/2016/06/Strategy_Pattern_uml.png" alt="strategy pattern"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/06/14/2016/java design pattern/java design pattern - strategy pattern/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/06/14/2016/java design pattern/java design pattern - interpreter pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/14/2016/java design pattern/java design pattern - interpreter pattern/" itemprop="url">java design pattern - interpreter pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-14T21:12:00+08:00">
                2016-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#解释器模式">解释器模式</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  解释器模式在编程中很少用到，一般是用来自己定义一套简单的语法语句通过解释器解释执行，在这里简单的实现一下完事。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>  解释器模式是一种行为模式，用来通过解释器来解析简单语句并执行。<br>  比如可以通过解释器来模拟一个简单的四则运算。<br>  解释器模式主要由4个角色组成：</p>
<ul>
<li>abstractExpression 定义了通用的解释行为方法 inerpreter(context)</li>
<li>TerminalExpression 具体值参数，在四则运算中就是数字</li>
<li>NonTerminalExpression 操作符 ，对应四则运算的加减乘除</li>
<li>context 上下文对象，用来保存一些常用的值等中间信息</li>
</ul>
<p><img src="/images/2016/06/interpreter_pattern_uml.jpg" alt="interpreter pattern"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/06/14/2016/java design pattern/java design pattern - interpreter pattern/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/06/13/2016/java design pattern/java design pattern - mediator pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/13/2016/java design pattern/java design pattern - mediator pattern/" itemprop="url">java design pattern - mediator pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-13T22:09:00+08:00">
                2016-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#中介者模式">中介者模式</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中经常会遇到两个或者多个复杂对象相互通讯的问题，如果对象之后互相引用的话会造成耦合严重，后续无法改动的问题<br>  这个时候可以考虑通过中介者模式来从中间完成中介的作用，来降低耦合度。</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>  中介者模式是一种结构话模式，旨在通过一个中介者对象来完成负责对象之间的通讯。<br>  主要由4个角色组成：</p>
<ul>
<li>mediator 中介者接口，定义了通讯的行为方式</li>
<li>ConcreteMediator 具体实现中介，内部有所有负责对象的引用</li>
<li>User 抽象的复杂对象，内部引用了中介对象</li>
<li>ConcreteUser  具体复杂对象，内部的行为调用了中介对象的行为   </li>
</ul>
<p><img src="/images/2016/06/mediator_uml.gif" alt="mediator pattern"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/06/13/2016/java design pattern/java design pattern - mediator pattern/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/06/13/2016/java design pattern/java design pattern - chain of responsibility/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/13/2016/java design pattern/java design pattern - chain of responsibility/" itemprop="url">java design pattern - chain of responsibility</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-13T21:36:00+08:00">
                2016-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#责任链模式">责任链模式</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中，经常会遇到链式处理的结构，比如一个请假流程，需要逐级审批，符合权限的管理角色来决定是否可以处理请求，如果可以<br>  处理就直接处理，不能处理就交由上级或下一个指定人员来处理，这种情况就可以使用责任链模式。</p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>  责任链模式是一种结构模式，主要通过Handler抽象方法来完成一个链式操作。主要由两个角色组成：</p>
<ul>
<li>Handler 抽象的处理类，内部实现setSuccessor方法和抽象的handleRequest方法</li>
<li>ConcreteHandler  Handler的具体实现</li>
</ul>
<p><img src="/images/2016/06/chain_of_responsibility_uml.gif" alt="chain of responsibility"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/06/13/2016/java design pattern/java design pattern - chain of responsibility/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/06/01/2016/java design pattern/java design pattern - composite pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/01/2016/java design pattern/java design pattern - composite pattern/" itemprop="url">java desigh pattern - composite pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-01T20:25:00+08:00">
                2016-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#组合模式">组合模式</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中遇到树形结构的时候可以优先考虑组合模式，比如文件管理，比如组织结构等。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>  组合模式是一种结构模式，把一组相似或相同对象组合成树状结构来展示，组合模式使得我们可以对不同的结构对象进行相同的操作。</p>
<p>  组合模式由3个角色组成：</p>
<ul>
<li>Component接口或抽象类</li>
<li>Leaf 叶节点，没有下级对象</li>
<li>Composite 组合节点，内部包含下属对象的集合</li>
</ul>
<p><img src="/images/2016/06/Comosite_pattern_uml.png" alt="composite pattern"><br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/06/01/2016/java design pattern/java design pattern - composite pattern/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/06/01/2016/java design pattern/java design pattern - proxy pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/01/2016/java design pattern/java design pattern - proxy pattern/" itemprop="url">java design pattern - proxy pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-01T16:32:00+08:00">
                2016-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#代理模式">代理模式</a></li>
<li><a href="#动态代理">动态代理</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中，如果要实现AOP编程或者用到要对对象方法的权限控制的时候，可以使用代理模式</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>  代理模式是一种结构化模式，可以通过调用代理类来间接的调用真实对象的方法，同时可以在调用的同时增加一些扩张。<br>  代理模式由3个角色构成：</p>
<ul>
<li>subject 抽象接口</li>
<li>realSubject 真实对象</li>
<li>proxy 代理类</li>
</ul>
<p><img src="/images/2016/06/proxy_pattern_uml.png" alt="proxy pattern"><br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/06/01/2016/java design pattern/java design pattern - proxy pattern/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pheobusyy.github.io/2016/06/01/2016/java design pattern/java design pattern - flyweight pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JustinYan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到JustinYan的个人blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/01/2016/java design pattern/java design pattern - flyweight pattern/" itemprop="url">java design pattern - flyweight pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-01T13:49:00+08:00">
                2016-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#享元模式">享元模式</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中如果某些对象数目过多会对系统性能造成很大的影响，比如在java中如果只是一味的创建新的对象话，对内存会有很大的压力<br>  这个时候我们可以考虑通过共享数据对象的方法来缓解这一问题，在这里就用到了享元模式。</p>
<p>  下面是正常的没有使用享元模式的demo：</p>
<pre><code class="java">  public class NoUserFlyWeight {
    private String state;

    public NoUserFlyWeight(String state) {
        this.state = state;
    }

    public void operator() {
        System.out.println(&quot;NoUserFlyWeight state =&quot; + state);
    }

    public static void main(String[] args) {
        NoUserFlyWeight noUserFlyWeight = new NoUserFlyWeight(&quot;state1&quot;);
        noUserFlyWeight.operator();
        noUserFlyWeight = new NoUserFlyWeight(&quot;state2&quot;);
        noUserFlyWeight.operator();

        noUserFlyWeight = new NoUserFlyWeight(&quot;state3&quot;);
        noUserFlyWeight.operator();

        noUserFlyWeight = new NoUserFlyWeight(&quot;state1&quot;);
        noUserFlyWeight.operator();

        noUserFlyWeight = new NoUserFlyWeight(&quot;state3&quot;);
        noUserFlyWeight.operator();
    }
  }
</code></pre>
<p>  在这里每次使用noUserFlyWeight的时候都创建了新的对象，对系统性能会有很大的影响，同时不太满足单例的情景，因为需要使用不同状态“state”。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>  享元模式是一样结构化模式，旨在通过共享技术来重复利用相同或相似的对象。比如在java中String字符串是final的，就是通过享元模式来利用相同字符的字符串，在常量池中<br>  共享相同的字符串来达到减少内存的目的。<br>  享元模式里面有两个概念，外部状态和内部状态。<br>  对象要共享的话就涉及到如何归纳那些对象属性可以共享，就是创建出来打大家都一样，这样就可以共享。那些属性不能共享，需要把它转换成外部状态，通过方法调用来实现，也就是从细粒度上来划分对象的属性。可以共享的就内部状态，对外开放通过方法调用就是外部状态。</p>
<p><img src="/images/2016/06/flyweight_pattern_uml.png" alt="flyweight pattern"><br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/06/01/2016/java design pattern/java design pattern - flyweight pattern/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JustinYan</p>
              <p class="site-description motion-element" itemprop="description">JustinYan的个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">97</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">Kategorien</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JustinYan</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
