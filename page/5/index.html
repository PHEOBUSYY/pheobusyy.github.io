<!DOCTYPE html><html class="has-navbar-fixed-top" lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title></title><script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script><link rel="stylesheet" type="text/css" href="/css/bulma.css"><link rel="stylesheet" type="text/css" href="/css/justyan.css"><link rel="stylesheet" type="text/css" href="/highlight/styles/dracula.css"><link rel="icon" href="/img/favicon.png"></head><body><section class="hero is-info is-medium"><div class="hero-head"><nav class="navbar is-fixed-top is-info"><div class="container"><div class="navbar-brand"><a class="navbar-item"><img class="navbar-circle" src="https://avatars2.githubusercontent.com/u/9360264?s=50&amp;u=5e88482f7319a8ce65ed618bcede72ea97a7f5aa&amp;v=4"></a><span class="navbar-burger burger" data-target="navbarMenuHeroA"><span></span><span></span><span></span></span></div><div class="navbar-menu" id="navbarMenuHeroA"><div class="navbar-end"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/category">Categories</a><a class="navbar-item" href="/contact">Contact</a><span class="navbar-item"><a class="button is-info is-inverted" href="https://github.com/PHEOBUSYY"><span class="icon"><i class="fab fa-github"></i></span><span>Github</span></a></span></div></div></div></nav></div><div class="hero-body"><div class="has-text-centered"><h1 class="title">欢迎来到JustYan的个人blog</h1><h2 class="subtitle">永远不要因为你觉得某个目标无法实现就否决它-《原则》</h2></div></div><div class="hero-foot"><nav class="tabs is-boxed"><div class="container"><ul><li class="is-active"><a href="/">All</a></li><li><a href="/tags/programming">Programming</a></li><li><a href="/tags/reading">Reading</a></li><li><a href="/tags/life">Life</a></li><li><a href="/tags/note">Note</a></li><li><a href="/tags/others">Others</a></li></ul></div></nav></div></section><div id="content-outer"><div id="content-inner"><div id="list-posts"><a class="post-item" href="/2016/05/28/2016/java design pattern/java design pattern - adapter pattern/"><div><span class="post-item-title">java design pattern - adapter pattern</span><span class="post-item-date">2016-05-28</span><span class="post-item-excerpt"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#适配器模式">适配器模式</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中我们经常会遇到驴头不对马嘴的情况，比如以前是继承A的接口的对象，现在外部调用的时候需要该对象已B接口的形式来调用<br>  ，这个时候我们可以让对象同时集成A和B接口来达到目的，不过，这样又违反了开闭原则，这个时候我们可以使用适配器模式来达到目的。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>  适配器模式是一种结构模式，可以帮助我们把对象以不同的接口方式来调用。主要由3个角色组成：</p>
<ul>
<li>Target 外部调用要求的接口方式</li>
<li>Adapter 中间用来协调的适配器</li>
<li><p>Adaptee 原始对象</p>
<p>首先，我们让Adapter继承实现Target接口，其次在Adapter中构造Adaptee对象，然后在Target方法中调用Adaptee中相应的方法。过程非常简单。</p>
</li>
</ul>
<p><img src="/images/2016/05/adapter_pattern_uml.png" alt="adapter pattern"><br></span></div></a><div class="post-tags"></div><a class="post-item" href="/2016/05/28/2016/java design pattern/java design pattern - decorator pattern/"><div><span class="post-item-title">java design pattern - decorator pattern</span><span class="post-item-date">2016-05-28</span><span class="post-item-excerpt"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#装饰模式">装饰模式</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>   在编程中，经常会遇到要对原来的某个对象进行功能上的扩展，这个时候如果直接在原来的类基础上直接修改的话违反了开闭原则<br>   同时可能会影响到原来的功能。这个时候我们可以通过装饰模式来达到功能上的扩展，而不影响原来的功能。</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>  装饰模式顾名思义就是对一个对象进行装饰（wrap）来达到功能扩展的目的。一般由4个角色来组成，分别为：  </p>
<ul>
<li>Component 要扩展对象的实现接口  </li>
<li>ConcreteComponent 要扩展的具体对象  </li>
<li>Decorator 继承于Component 用来装饰的基础类  </li>
<li><p>ConcreteDecorator 具体的装饰类，根据功能对Decorator中的方法进行扩展  </p>
<p>实现的步骤如下：</p>
</li>
<li>新建Decorator继承或实现于Component</li>
<li>在Decorator中添加一个Component类型的变量</li>
<li>在Decorator的构造函数中传入一个Component对象，来完成上面变量的初始化</li>
<li>在Decorator中实现所有Component中定义的方法，里面调用Component变量中对应的方法</li>
<li>ConcreteDecorator继承Decorator，在里面对需要调整的方法进行复写修改</li>
</ul>
<p><img src="/images/2016/05/decorator_pattern_uml.png" alt="decorator pattern"><br></span></div></a><div class="post-tags"></div><a class="post-item" href="/2016/05/28/2016/java design pattern/java design pattern - facade pattern/"><div><span class="post-item-title">java design pattern - facade pattern</span><span class="post-item-date">2016-05-28</span><span class="post-item-excerpt"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#外观模式">外观模式</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>   在编程中当我们遇到一个非常复杂或者难懂的系统的时候，感到很棘手，很多情况是由于系统内部的逻辑相互依赖，或者无法获取到源码所造成的<br>   在这种情况下我们可以使用外观模式或者叫做门面模式来处理。<br>   外观模式提供了一个简单接口供外部调用，而在接口内部来封装了外部要求调用复杂系统的不同行为逻辑，从而实现了外部对复杂系统的隔离。达到解耦合的目的。<br>   下面是一个模拟没有使用外观模式的demo：</p>
<pre><code class="java">   public class NoUserFacade {
    public static void main(String[] args) {
        PartA partA = new PartA();
        PartB partB = new PartB();
        PartC partC = new PartC();
        partA.doSomething();
        partB.doSomething();
        partC.doSomething();
    }

    public static class PartA {
        public void doSomething() {
            System.out.println&lt;!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 --&gt;

- [场景](#场景)
- [外观模式](#外观模式)
- [总结](#总结)
- [参考资料](#参考资料)

&lt;!-- /TOC --&gt;(&quot;partA doSomething&quot;);
        }
    }

    public static class PartB {
        public void doSomething() {
            System.out.println(&quot;partA doSomething&quot;);
        }
    }

    public static class PartC {
        public void doSomething() {
            System.out.println(&quot;partA doSomething&quot;);
        }
    }

  }
</code></pre>
<p>  在这里用partA,partB,partC来表示复杂系统的内部行为逻辑，如果我们在用的时候就象在main函数中的调用，很有能是非常的混乱，同时也对测试造成了很大的困难。下面我们使用外观模式来解决上面遇到的问题。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>  外观模式是一种结构型模式，它提供了一个简单的接口给外部调用，外观模式可以：</p>
<ul>
<li>使一个library或者类库方便调用，易懂，方便测试</li>
<li>减少了对类库内部的逻辑依赖，使的系统更加的灵活</li>
<li>通过一个设计良好的接口来封装那些设计不规范或者使用不便的API</li>
</ul>
<p><img src="/images/2016/05/Facade_design_pattern_in_UML.png" alt="facade pattern"></p></span></div></a><div class="post-tags"></div><a class="post-item" href="/2016/05/27/2016/java design pattern/java design pattern - Builder pattern/"><div><span class="post-item-title">java design pattern - Builder pattern</span><span class="post-item-date">2016-05-27</span><span class="post-item-excerpt"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#建造者模式">建造者模式</a></li>
<li><a href="#对象内部builder实现">对象内部builder实现</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在平时我们会遇到复杂对象的构造过程，对象内部的组成部分属于多个或者一个复杂对象的情况，同时又很在意内部组成的组装顺序<br>  这个时候，我们可以使用构造者模式来把对象内部组成的创建和组装来划分开，达到解耦合。同时对外部隐藏了对象内部的具体实现。</p>
<pre><code class="java">  public class GaiFan {
    private String cai;
    private String rice;

    public String getCai() {
        return cai;
    }

    public void setCai(String cai) {
        this.cai = cai;
    }

    public String getRice() {
        return rice;
    }

    public void setRice(String rice) {
        this.rice = rice;
    }

    @Override
    public String toString() {
        return &quot;GaiFan{&quot; +
                &quot;cai=&#39;&quot; + cai + &#39;\&#39;&#39; +
                &quot;, rice=&#39;&quot; + rice + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
</code></pre>
<pre><code class="java">  public class NoUserBuilder {
    public static void main(String[] args) {
        GaiFan gaifan = new GaiFan();
        gaifan.setCai(&quot;宫保鸡丁&quot;);
        gaifan.setRice(&quot;宫保鸡丁米饭&quot;);
        System.out.println(&quot;gaifan=&quot;+gaifan);
        gaifan = new GaiFan();
        gaifan.setCai(&quot;鱼香肉丝&quot;);
        gaifan.setRice(&quot;鱼香肉丝米饭&quot;);
        System.out.println(&quot;gaifan=&quot;+gaifan);
    }
  }
</code></pre>
<p>  在这里我们使用盖饭来表示要构造的对象。盖饭由两个重要部分组成，菜和米饭，在没有使用建造者模式的时候直接创建盖饭对象<br>  同时设置对应的属性，在这里首先是暴露了盖饭内部的做法实现，同时如果菜和米饭的创建十分复杂的时候这里的逻辑会很混乱<br>  再如果要调整盖饭制作顺序的话，这个单独的创建对象显然无法胜任。这个时候我们可以使用建造者模式来帮组我们解决问题。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>  建造者模式是一种对象创建模式，不同于工厂和抽象工厂模式，建造者模式主要着眼于对象的内部组成创建和构造顺序。建造者模式由4个主要角色构成：<br>  要创建的对象（Product），抽象的构造对象（Builder），具体的构造对象（concrete builder），导演类（Derector）。其中Builder抽象定义了对象<br>  的构造顺序，具体的构造对象内部实现具体要构造对象的各个组成的创建，导演类负责根据不同创建者来生成不同的对象。</p>
<p><img src="/images/2016/05/design_pattern_builder.png" alt="builder pattern"><br></span></div></a><div class="post-tags"></div><a class="post-item" href="/2016/05/26/2016/java design pattern/java design pattern-memento pattern/"><div><span class="post-item-title">java design pattern-memento pattern</span><span class="post-item-date">2016-05-26</span><span class="post-item-excerpt"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#备忘录模式">备忘录模式</a></li>
<li><a href="#实现过程">实现过程</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在编程中经常遇到要回退某一个对象状态的场景，比如游戏中在打架前存盘，如果失败了可以回退到之前的状态，又比如执行了错误<br>  操作之后要回退到之前的某一个操作等等，总之就是在之前保存了对象状态，用户后悔了之后可以回滚，一种“后悔药”的感觉<br>  如果不用设计模式直接实现的话，是这个样子的：</p>
<pre><code class="java">  public class NoMementoUse {
   private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public static void main(String[] args) {
        //用来保存状态
        String preState = &quot;&quot;;
        NoMementoUse noMementoUse = new NoMementoUse();
        noMementoUse.setState(&quot;state first&quot;);
        preState = noMementoUse.getState();
        noMementoUse.setState(&quot;state second&quot;);
        //后悔了
        noMementoUse.setState(preState);
        System.out.println(&quot;state=&quot;+noMementoUse.getState());
    }
  }
</code></pre>
<p>  在上面的实现中，通过一个preState来保存状态，后悔了之后把preState回写到对象中，这里有两个问题：一个是暴露了对象中state属性，另一个是如果要实现更复杂的回退<br>  逻辑的话，不好扩展。在这种场景下，可以使用备忘录模式。<br></span></div></a><div class="post-tags"></div><a class="post-item" href="/2016/05/26/2016/java design pattern/java design pattern - state pattern/"><div><span class="post-item-title">java design pattern - state pattern</span><span class="post-item-date">2016-05-26</span><span class="post-item-excerpt"><!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#场景">场景</a></li>
<li><a href="#状态模式">状态模式</a></li>
<li><a href="#实现过程">实现过程</a></li>
<li><a href="#另一种实现方式">另一种实现方式</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  在程序中要根据对象的不同状态来执行不同的逻辑的时候可以考虑使用状态模式。下面来看没有使用状态模式的代码</p>
<pre><code class="java">  public class NoUseStatePattern {
    public int value;

    public void handle() {
        if (value &lt; 100) {
            System.out.println(&quot;value begin=&quot; + value);
        } else if (value &gt;= 100 &amp;&amp; value &lt;= 200) {
            System.out.println(&quot;value middle=&quot; + value);
        } else {
            System.out.println(&quot;value end=&quot; + value);
        }
    }

    public static void main(String[] args) {
        NoUseStatePattern noUseStatePattern = new NoUseStatePattern();
        noUseStatePattern.value = 10;
        noUseStatePattern.handle();

        noUseStatePattern.value = 120;
        noUseStatePattern.handle();

        noUseStatePattern.value = 220;
        noUseStatePattern.handle();
    }
}
</code></pre>
<p>  在这里要根据value的值来执行不同的逻辑，目前来看没什么大问题，但是如果后续要增加多个value的判断或者根据value的不同执行更复杂的<br>  逻辑的时候，上面的代码就会有点力不从心了，这个时候我们可以使用状态模式来替换上面的逻辑。</p>
<pre><code class="java">  public class UserStatePattern {
    private int value;
    private State state;

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
    }

    public void handle(){
        if (getValue() &lt; 100) {
            setState(new BeginState());
        } else if (getValue() &gt;= 100 &amp;&amp; getValue() &lt; 200) {
            setState(new MiddleState());
        } else {
            setState(new EndState());
        }
        state.handle(this);
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public static void main(String[] args) {
        UserStatePattern userStatePattern = new UserStatePattern();
        userStatePattern.setValue(10);
        userStatePattern.handle();
        userStatePattern.handle();
        userStatePattern.handle();
    }
}
</code></pre>
<p>  看上去很简单多不对，所白了就是把if else判断封装了一下，方便以后扩展，同时也更加的灵活。<br></span></div></a><div class="post-tags"></div><a class="post-item" href="/2016/03/30/2016/编程中遇到的环境问题/"><div><span class="post-item-title">编程中遇到的环境问题</span><span class="post-item-date">2016-03-30</span><span class="post-item-excerpt">纪录一些平时很少遇到的问题android
Error: Could not create the Jjavaava Virtual Machine.Error: A fatal exception has occurred. Program will exit.Invalid maximum ...</span></div></a><div class="post-tags"></div><a class="post-item" href="/2016/03/29/2016/java 内部类－Nested Classes/"><div><span class="post-item-title">java 内部类－Nested Classes</span><span class="post-item-date">2016-03-29</span><span class="post-item-excerpt"><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在java中允许在一个内内部定义另一个类，这个被定义的类就叫做内部类（很形象嘛）.比如下面示例：</p>
<pre><code class="java"> class OuterClass {
   ...
   static class StaticNestedClass{
     ...
   }
   ...
   class NestedClass{
     ...
   }
 }
</code></pre>
<p>其中，StaticNestedClass叫做静态内部类，也叫嵌套类，NestedClass叫做成员内部类。其中成员内部类又包括匿名内部类(Anonymous innerClass)和局部内部类(local innerCalss)内部类是外部类中一个成员;</p>
<p>成员内部类可以访问其外部类的成员，包括其中的作用于为private的成员,其内部有一个对外部类的引用，所依可以获取到外部类所有的成员。<br>静态内部类和其外部类是平级关系，与一个普通的外部类作用类似，没有对其外部类的引用。</p>
<h2 id="为什么使用内部类"><a href="#为什么使用内部类" class="headerlink" title="为什么使用内部类"></a>为什么使用内部类</h2><ul>
<li>一种可以把逻辑按组合整合在一起的方法</li>
<li>增强封装</li>
<li>增加代码的可读性和可维护性</li>
<li>一种变相支持多重继承的方式（后面会讲到）</li>
<li>闭包（回调）类似lambda</span></div></a><div class="post-tags"></div><a class="post-item" href="/2016/03/07/2016/2016-03-07-《成功，动机与目标》读书笔记－/"><div><span class="post-item-title">《成功，动机与目标》读书笔记－</span><span class="post-item-date">2016-03-07</span><span class="post-item-excerpt"><h2 id="第九章-“如果…就…”的力量————制定简单有效的计划"><a href="#第九章-“如果…就…”的力量————制定简单有效的计划" class="headerlink" title="第九章 “如果…就…”的力量————制定简单有效的计划"></a>第九章 “如果…就…”的力量————制定简单有效的计划</h2><p><strong>“不做准备，就是在准备失败。” ——————本杰明.富兰克林</strong><br></span></div></a><div class="post-tags"></div><a class="post-item" href="/2016/03/01/android 知识点/"><div><span class="post-item-title">android知识点</span><span class="post-item-date">2016-03-01</span><span class="post-item-excerpt"><p>android知识点汇总</p>
<h2 id="ActivityLifecycleCallbacks的使用"><a href="#ActivityLifecycleCallbacks的使用" class="headerlink" title="ActivityLifecycleCallbacks的使用"></a>ActivityLifecycleCallbacks的使用</h2><p>  ActivityLifecycleCallbacks用来在application中统一监听activity的生命周期回调</p>
<h2 id="为什么在theme设置layoutmargin等以layout开头的属性无效"><a href="#为什么在theme设置layoutmargin等以layout开头的属性无效" class="headerlink" title="为什么在theme设置layoutmargin等以layout开头的属性无效"></a>为什么在theme设置layout<em>margin等以layout</em>开头的属性无效</h2><p>  这是因为以layout_开头的属性是用来告诉父控件如何放置该控件位置的，必须明确了外部viewGroup的类型之后才可以生效，   所以在theme中设置无效，需要在具体调用的xml中设置对应的style才可以生效</p>
<p>  <a href="http://stackoverflow.com/questions/3775587/to-use-layout-marginleft-in-a-button-style-applied-as-a-theme" title="To use layout_marginLeft in a button style applied as a theme?">  To use layout_marginLeft in a button style applied as a theme?</a></p>
<h2 id="如何修改全局的view属性，比如改变当前activity或者application的button背景"><a href="#如何修改全局的view属性，比如改变当前activity或者application的button背景" class="headerlink" title="如何修改全局的view属性，比如改变当前activity或者application的button背景"></a>如何修改全局的view属性，比如改变当前activity或者application的button背景</h2><p>  方法一.theme中引用style，然后设置为当前activity的theme</p>
<pre><code class="xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
  &lt;style name=&quot;MyRedTheme&quot; parent=&quot;android:Theme.Light&quot;&gt;
    &lt;item name=&quot;android:textAppearance&quot;&gt;@style/MyRedTextAppearance&lt;/item&gt;
  &lt;/style&gt;
  &lt;style name=&quot;MyRedTextAppearance&quot; parent=&quot;@android:style/TextAppearance&quot;&gt;
    &lt;item name=&quot;android:textColor&quot;&gt;#F00&lt;/item&gt;
    &lt;item name=&quot;android:textStyle&quot;&gt;bold&lt;/item&gt;
  &lt;/style&gt;
&lt;/resources&gt;
</code></pre>
<p>  方法二.自定义一个view</p>
<pre><code class="java">  public class RedTextView extends TextView{
    public RedTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
        setTextColor(Color.RED);
    }
  }
</code></pre>
<p>  <a href="http://stackoverflow.com/questions/3078081/setting-global-styles-for-views-in-android" title="Setting global styles for Views in Android">  Setting global styles for Views in Android</a><br></span></div></a><div class="post-tags"><a href="tags/blog/"><span class="post-tag">blog</span></a><a href="tags/github/"><span class="post-tag">github</span></a><a href="tags/android/"><span class="post-tag">android</span></a></div></div><nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination"><div class="pagination-list"><a class="extend prev" rel="prev" href="/page/4/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span></div></nav></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> JustYan </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span><br><a href="/">Home</a></div></div><script src="/js/justyan.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>